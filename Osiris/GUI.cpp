#include <stdio.h>
#include <iostream>


#pragma region J1

class jvmyboh {
public:
    std::string eanvwzbrkerkm;
    std::string ydhktm;
    bool zvlmsvgc;
    int svqdit;
    int vpsuttgkhs;
    jvmyboh();
    void lyalvxqdnjmpj(int pbaundaqsw, double nafqcgqddspw, std::string sqokbjoiwy, std::string xpholz, double hfixujfgtipt, bool zegcjgyotxypdyv, bool ljqokblmikbqlfv);
    bool qacyaanpwgfa(int takbvcxatq, int luwopajbqcvhszc, bool owryhz, std::string ejkkosovsnbyzy, int nvzgqapehpfsx, int xmqxbz);
    void drjznnqvjuqkaihuctlysedi(bool vromialvyyte, int yfkzqnxnlomyot, double wlunhuhyxj, double iktzl, int qecjomgpaafsaj, int tarssytnbchj, bool nxeiurspy, std::string rozeuohbu, bool omubjwn, int xkmmzwmnhbizg);
    bool nbcskldpldmivbyipekqop(std::string jmisyphy, bool reachmbzfeu, bool lxuve, std::string hgyfckahq, int uritgmr, std::string abvab);
    int ppenxubrdqyhh(double rwieqm, bool vdpjzknrrabd, bool caziqb, double xhzxge);
    double oblwxfigcahuaveqmeyiloy(double fblqnfghlc, double vymtobgfxwchw, double uwzotmska);
    void sztekgttrueulctuofptz(bool yetlzwytyk, int okhzauezfwdzl, int eufjystzwtuzpok, std::string vpgrqwwjmpgm, double hcimrlzacylcsfp, std::string jcevaok);
    int wngaozjjbarsfkwymsrnbadr(bool wprkwnfdmkc);
    double ckhasxznllxojuswcvrtwqf(int qejddinz, std::string xqdubp, std::string qblvyogjcryy, int qxllhugqkmld, double jqmdykendxm, bool uvhrloo, double yznoafmm, std::string foqcvuocimlvt);
    bool dhqgqaezoletyvmapef(int vllpvmh, int vbvswsdwdqmd, int qjjql, int lwgjgwafup, std::string csknmnvvcbhs, int jidfbxdfro, double dcwfloomuj, std::string zqvokdl, double fpkgmeo, std::string szxiz);

protected:
    bool qeyac;
    double ittcjsrszqayidd;
    bool rxuugj;
    int vknnoylw;
    std::string akzwrcznx;

    void wybyhhpkxgbjxvnjwxzeobrk(std::string xtbezaxftiemrj, int ygxwktlgxeuopyh, double lxnqwphqijgz, std::string flpfhuzp, std::string yxpdvop, bool ppazsrnpmpsmhux, int dsxnlcoaafemg, double biuxfprnnwms);
    int ksqyczeqjamzsvmvilim(double lwmgik, int rdbhvldwglesb, double sdvgkffsmwahw, double xughunrptneguo, int ivhtzw, std::string qabkturxd);
    void lblejqfknmqbnmedhagyt(int khzztfei, bool ghbxxxynnl, std::string igazkr);
    int etjnduqmfznrchcvrdb(bool hdenfqqp, bool heamkgvc, int qwlvdipukiif);

private:
    bool hgtzpunonrywi;
    std::string krehe;
    std::string xxtbzfmq;
    double wzantxbmpmgbyjy;
    bool lphnkkbouoxqgy;

    void cgbiqoyfcrwzsgktpigdr(int doecm, int uivphatxhzggs, double hfaukptdnhsi, bool gedjtgbhkhomci, std::string kxtjg, double wzrahtjgfjq, int qlqmsjlmm);
    int hmvduotofdt(int wuqzzc, std::string lrervykb, int jideygrowhlmuzh, double gzkftmb, double ledxfygiqxhlkl);
    void pwuqijhkmbfuebixhrt(std::string gnpib, int jstvengudumn, bool wgfavljpnvjh, std::string fpgzemkgaayda, double tgpmiilptak, bool sdzqsvunhufm);

};


void jvmyboh::cgbiqoyfcrwzsgktpigdr(int doecm, int uivphatxhzggs, double hfaukptdnhsi, bool gedjtgbhkhomci, std::string kxtjg, double wzrahtjgfjq, int qlqmsjlmm) {
    std::string pslvzdvoohesu = "egtebbqakyljemytykdgeuasdbplhcbkyorwvlnpljvrdsymodrqmpooaisuyjdxfwkultqpwobiiiqsrdluxwrzsxklgodgssso";
    double inuywvfi = 15445;
    double jpczwu = 70176;
    if (70176 != 70176) {
        int bdbabqg;
        for (bdbabqg = 71; bdbabqg > 0; bdbabqg--) {
            continue;
        }
    }
    if (15445 == 15445) {
        int ezvmgd;
        for (ezvmgd = 51; ezvmgd > 0; ezvmgd--) {
            continue;
        }
    }

}

int jvmyboh::hmvduotofdt(int wuqzzc, std::string lrervykb, int jideygrowhlmuzh, double gzkftmb, double ledxfygiqxhlkl) {
    int aatpr = 5696;
    int yegyujmyqosoqt = 2212;
    double ssvseem = 60304;
    double grysqhy = 47142;
    double nrlhalcq = 15294;
    double jutgmqutwptqcw = 40362;
    double hnnrlyptvgyx = 1319;
    bool forcobm = false;
    return 79805;
}

void jvmyboh::pwuqijhkmbfuebixhrt(std::string gnpib, int jstvengudumn, bool wgfavljpnvjh, std::string fpgzemkgaayda, double tgpmiilptak, bool sdzqsvunhufm) {
    bool yvxcogazekdwkd = true;
    std::string tbdgsjtuheu = "oziywlfigermighedpstbvndvzhrzekusfdzhjaqmplbauezjknrsvygnxvkcqwbfcetrxxhofvahnpgvigjmpugukhg";
    int qdfjy = 1168;
    bool ftcywgzbwgkl = false;
    std::string bicdd = "kjqbwcoxxzaqh";
    double ljefr = 29036;
    double oyiktthcbjkh = 646;
    std::string twczzel = "trbyefydadkrdpxdmdflqrogffel";
    std::string weymnlfehydhx = "gqncseqpaqrhgnjobykzjwgjmuonoywcypwllwmtarpieakooyfzusboyaovsfmgzptqqbjqpifyfaxcqa";
    if (std::string("gqncseqpaqrhgnjobykzjwgjmuonoywcypwllwmtarpieakooyfzusboyaovsfmgzptqqbjqpifyfaxcqa") != std::string("gqncseqpaqrhgnjobykzjwgjmuonoywcypwllwmtarpieakooyfzusboyaovsfmgzptqqbjqpifyfaxcqa")) {
        int hvtezmkz;
        for (hvtezmkz = 56; hvtezmkz > 0; hvtezmkz--) {
            continue;
        }
    }
    if (std::string("gqncseqpaqrhgnjobykzjwgjmuonoywcypwllwmtarpieakooyfzusboyaovsfmgzptqqbjqpifyfaxcqa") != std::string("gqncseqpaqrhgnjobykzjwgjmuonoywcypwllwmtarpieakooyfzusboyaovsfmgzptqqbjqpifyfaxcqa")) {
        int gzqmwqc;
        for (gzqmwqc = 14; gzqmwqc > 0; gzqmwqc--) {
            continue;
        }
    }
    if (1168 != 1168) {
        int cg;
        for (cg = 89; cg > 0; cg--) {
            continue;
        }
    }
    if (std::string("gqncseqpaqrhgnjobykzjwgjmuonoywcypwllwmtarpieakooyfzusboyaovsfmgzptqqbjqpifyfaxcqa") == std::string("gqncseqpaqrhgnjobykzjwgjmuonoywcypwllwmtarpieakooyfzusboyaovsfmgzptqqbjqpifyfaxcqa")) {
        int lh;
        for (lh = 74; lh > 0; lh--) {
            continue;
        }
    }

}

void jvmyboh::wybyhhpkxgbjxvnjwxzeobrk(std::string xtbezaxftiemrj, int ygxwktlgxeuopyh, double lxnqwphqijgz, std::string flpfhuzp, std::string yxpdvop, bool ppazsrnpmpsmhux, int dsxnlcoaafemg, double biuxfprnnwms) {
    std::string wxfrskmq = "pphelxxhkodgtvilwtbmingik";
    double mvnqbdrudssadhz = 13326;
    double jbnfnmbudmatzb = 5835;
    bool dheurwgeqrcpxa = false;
    bool rtred = false;
    int ogbbfiut = 2893;
    double kldbobaepgofkhb = 6947;
    bool dfsogpbsre = true;
    if (std::string("pphelxxhkodgtvilwtbmingik") != std::string("pphelxxhkodgtvilwtbmingik")) {
        int xvfjrvg;
        for (xvfjrvg = 21; xvfjrvg > 0; xvfjrvg--) {
            continue;
        }
    }

}

int jvmyboh::ksqyczeqjamzsvmvilim(double lwmgik, int rdbhvldwglesb, double sdvgkffsmwahw, double xughunrptneguo, int ivhtzw, std::string qabkturxd) {
    bool yrspnahwuydgra = false;
    std::string brsnpgergp = "comxxxvpgqdhkpbiggw";
    bool zwrapcakk = true;
    int tbmjjjfidmirsb = 938;
    std::string ocofazouczjwen = "xekwdleksrjlimcbpbxsvdgxwwx";
    if (false != false) {
        int vx;
        for (vx = 57; vx > 0; vx--) {
            continue;
        }
    }
    if (std::string("xekwdleksrjlimcbpbxsvdgxwwx") == std::string("xekwdleksrjlimcbpbxsvdgxwwx")) {
        int tbuoza;
        for (tbuoza = 35; tbuoza > 0; tbuoza--) {
            continue;
        }
    }
    if (true == true) {
        int geknm;
        for (geknm = 22; geknm > 0; geknm--) {
            continue;
        }
    }
    if (false != false) {
        int irfxvzi;
        for (irfxvzi = 21; irfxvzi > 0; irfxvzi--) {
            continue;
        }
    }
    return 20292;
}

void jvmyboh::lblejqfknmqbnmedhagyt(int khzztfei, bool ghbxxxynnl, std::string igazkr) {

}

int jvmyboh::etjnduqmfznrchcvrdb(bool hdenfqqp, bool heamkgvc, int qwlvdipukiif) {
    std::string xqicxzxxqadocr = "psocpxmzkxgnzzstlzunvtbuxniwoonaqktublbeidpfbfw";
    int tyfpnjp = 2051;
    double rsekcjhdznbn = 24035;
    bool yrldlek = false;
    if (24035 != 24035) {
        int ggwoqa;
        for (ggwoqa = 54; ggwoqa > 0; ggwoqa--) {
            continue;
        }
    }
    if (false != false) {
        int uukkr;
        for (uukkr = 89; uukkr > 0; uukkr--) {
            continue;
        }
    }
    return 8844;
}

void jvmyboh::lyalvxqdnjmpj(int pbaundaqsw, double nafqcgqddspw, std::string sqokbjoiwy, std::string xpholz, double hfixujfgtipt, bool zegcjgyotxypdyv, bool ljqokblmikbqlfv) {
    double fophqsd = 24363;
    bool trxkcgolk = true;
    double jyyygthjelmq = 20879;
    bool xmixuiync = true;
    bool rbiocwvlblouiql = true;
    std::string zrjbjdwawwts = "ygtugowarlnqdva";
    std::string gfwiycfxe = "ucoohpvouosojktqgobaghvfynbrlrppqbpgynhflfimglwluzbusimsebdxzuaosqspgdhbgz";
    bool bwstbzcfdk = false;
    if (std::string("ucoohpvouosojktqgobaghvfynbrlrppqbpgynhflfimglwluzbusimsebdxzuaosqspgdhbgz") == std::string("ucoohpvouosojktqgobaghvfynbrlrppqbpgynhflfimglwluzbusimsebdxzuaosqspgdhbgz")) {
        int yeirdda;
        for (yeirdda = 11; yeirdda > 0; yeirdda--) {
            continue;
        }
    }
    if (true == true) {
        int kczeiolewe;
        for (kczeiolewe = 90; kczeiolewe > 0; kczeiolewe--) {
            continue;
        }
    }
    if (20879 == 20879) {
        int vga;
        for (vga = 78; vga > 0; vga--) {
            continue;
        }
    }
    if (std::string("ucoohpvouosojktqgobaghvfynbrlrppqbpgynhflfimglwluzbusimsebdxzuaosqspgdhbgz") != std::string("ucoohpvouosojktqgobaghvfynbrlrppqbpgynhflfimglwluzbusimsebdxzuaosqspgdhbgz")) {
        int qcqctzz;
        for (qcqctzz = 31; qcqctzz > 0; qcqctzz--) {
            continue;
        }
    }

}

bool jvmyboh::qacyaanpwgfa(int takbvcxatq, int luwopajbqcvhszc, bool owryhz, std::string ejkkosovsnbyzy, int nvzgqapehpfsx, int xmqxbz) {
    int vndey = 6665;
    int lumma = 8600;
    double texgdlgn = 28282;
    std::string llhulmdsgc = "wtfwwiszogputhxyihxtltllmibhwtnjctohoytajnulrrzsfxymccmfjjvjzbfkwxnjdhsepenpvgjnpkxobianlwcbjfh";
    double pqaesbcbcfekwv = 35887;
    std::string yrqpvoel = "tdhrifdkmekiadzoshqkzxluolxcrgulhbyrfdzdpqyyjychkpuwjgocftatuczfifqy";
    bool kbpwjpjhkd = true;
    double ukeuoncdq = 26097;
    std::string bcprtrkxmetyosr = "ajmkkvphkckiqoakbl";
    if (6665 != 6665) {
        int xxnhdz;
        for (xxnhdz = 1; xxnhdz > 0; xxnhdz--) {
            continue;
        }
    }
    if (6665 != 6665) {
        int xno;
        for (xno = 36; xno > 0; xno--) {
            continue;
        }
    }
    if (35887 != 35887) {
        int tnvemq;
        for (tnvemq = 64; tnvemq > 0; tnvemq--) {
            continue;
        }
    }
    return false;
}

void jvmyboh::drjznnqvjuqkaihuctlysedi(bool vromialvyyte, int yfkzqnxnlomyot, double wlunhuhyxj, double iktzl, int qecjomgpaafsaj, int tarssytnbchj, bool nxeiurspy, std::string rozeuohbu, bool omubjwn, int xkmmzwmnhbizg) {
    double kpixxdhvl = 1451;
    double eycjjh = 33770;
    bool tuvigivq = true;
    std::string rimkzwknmfk = "jxcpqmpgiasnobyalvgmkwhhplshyrenlsphacnzqarnqfwzkixeyslcfxukrwdttolyroxloecg";
    int linrlknhvoyj = 741;
    bool spupoqzzkuhba = false;
    std::string lwkebybpz = "khvliglfeqcibegfb";
    bool aogejatzu = false;
    std::string ubnwugptcfdegz = "ftbcyyveoztmbeouaxarntucn";
    if (std::string("jxcpqmpgiasnobyalvgmkwhhplshyrenlsphacnzqarnqfwzkixeyslcfxukrwdttolyroxloecg") != std::string("jxcpqmpgiasnobyalvgmkwhhplshyrenlsphacnzqarnqfwzkixeyslcfxukrwdttolyroxloecg")) {
        int vznfrnex;
        for (vznfrnex = 85; vznfrnex > 0; vznfrnex--) {
            continue;
        }
    }

}

bool jvmyboh::nbcskldpldmivbyipekqop(std::string jmisyphy, bool reachmbzfeu, bool lxuve, std::string hgyfckahq, int uritgmr, std::string abvab) {
    double hfqjmwugivdcdcl = 4215;
    std::string tctfubzij = "zavmacvbyrohddjgkjx";
    double pxhrgpvkgdewqqm = 13723;
    int antqprzxx = 1859;
    bool odicx = false;
    std::string sszxsjtcqdu = "kvihphayvdajjqnwzuqwztfnoabrz";
    double mftgpcyjwaxmjr = 7062;
    if (13723 != 13723) {
        int dcjvnxn;
        for (dcjvnxn = 32; dcjvnxn > 0; dcjvnxn--) {
            continue;
        }
    }
    return false;
}

int jvmyboh::ppenxubrdqyhh(double rwieqm, bool vdpjzknrrabd, bool caziqb, double xhzxge) {
    int mmgkcajlxlqligb = 2019;
    int teiqtgrmdi = 9215;
    std::string nudlzlgpfjs = "kqcospxligxitkownmqaoldmhocaeaikmkpkztvvkiefacpocxjdxvjprcytyvfxiiscogdfelrqwooeerqnl";
    double ibirdyyy = 30130;
    int ocfll = 854;
    if (2019 == 2019) {
        int gd;
        for (gd = 59; gd > 0; gd--) {
            continue;
        }
    }
    if (9215 != 9215) {
        int csyywwyehg;
        for (csyywwyehg = 32; csyywwyehg > 0; csyywwyehg--) {
            continue;
        }
    }
    return 97334;
}

double jvmyboh::oblwxfigcahuaveqmeyiloy(double fblqnfghlc, double vymtobgfxwchw, double uwzotmska) {
    double itknvhzlbnrnfhf = 11697;
    double imenzysy = 2522;
    double nilxapzdtzyk = 1054;
    bool qagvusbjvacru = true;
    std::string bskvmduddbzdg = "imstlwqrhdodusiliougawtftyqochp";
    int rmwkuhxboyisaqd = 8914;
    std::string jpfqcxhrisbrtd = "ylijvsshyigrfxvdircomqcmazxcnqicqpasmtlfomkxsbbmsjiumsuwmro";
    double clchgyqbjpa = 13190;
    if (11697 != 11697) {
        int xqxkcslzuq;
        for (xqxkcslzuq = 1; xqxkcslzuq > 0; xqxkcslzuq--) {
            continue;
        }
    }
    return 82374;
}

void jvmyboh::sztekgttrueulctuofptz(bool yetlzwytyk, int okhzauezfwdzl, int eufjystzwtuzpok, std::string vpgrqwwjmpgm, double hcimrlzacylcsfp, std::string jcevaok) {
    int fdvnsrvtbg = 829;
    int zgsqlxshdg = 1001;
    int jgqhgtzqber = 3444;
    std::string fwxvjsjfxegjtah = "ofysrlrpopddwauywrfnpcxxzcgsnvnblzncrsospdbnxsyevszhmqrajstdkjvcraywuqmsw";
    bool hgqivjgetvaju = false;
    std::string wmgruaome = "cjmrwrgazysvmpmpnzexeimn";
    if (std::string("cjmrwrgazysvmpmpnzexeimn") == std::string("cjmrwrgazysvmpmpnzexeimn")) {
        int gx;
        for (gx = 88; gx > 0; gx--) {
            continue;
        }
    }
    if (std::string("ofysrlrpopddwauywrfnpcxxzcgsnvnblzncrsospdbnxsyevszhmqrajstdkjvcraywuqmsw") != std::string("ofysrlrpopddwauywrfnpcxxzcgsnvnblzncrsospdbnxsyevszhmqrajstdkjvcraywuqmsw")) {
        int gc;
        for (gc = 79; gc > 0; gc--) {
            continue;
        }
    }
    if (1001 == 1001) {
        int jfw;
        for (jfw = 77; jfw > 0; jfw--) {
            continue;
        }
    }
    if (false == false) {
        int kmgdnp;
        for (kmgdnp = 11; kmgdnp > 0; kmgdnp--) {
            continue;
        }
    }
    if (829 == 829) {
        int lw;
        for (lw = 2; lw > 0; lw--) {
            continue;
        }
    }

}

int jvmyboh::wngaozjjbarsfkwymsrnbadr(bool wprkwnfdmkc) {
    bool nqhwxyentqcdpv = true;
    std::string etpcg = "hczykjdvozqqvpjeztqeiwrapuouzmarnkvun";
    bool zzohgphtpwkkdhx = true;
    bool zhchctgritifm = true;
    std::string ocadohroo = "bfmuakapsloicqqqowqfrbnrurmnadtrgaundrqrmudvpzfcgwqfyibrurpye";
    std::string svahmjqo = "jvnhsfnkhgeejqrzvmdwstqksavpracqzkphtqslyclbzdrbmkrgmgrhxtklzjesifazridva";
    int jnlatnpbptpzo = 2149;
    if (true == true) {
        int mxgwow;
        for (mxgwow = 93; mxgwow > 0; mxgwow--) {
            continue;
        }
    }
    if (true == true) {
        int rdq;
        for (rdq = 9; rdq > 0; rdq--) {
            continue;
        }
    }
    if (2149 == 2149) {
        int vo;
        for (vo = 92; vo > 0; vo--) {
            continue;
        }
    }
    if (true != true) {
        int ecychhm;
        for (ecychhm = 52; ecychhm > 0; ecychhm--) {
            continue;
        }
    }
    return 54138;
}

double jvmyboh::ckhasxznllxojuswcvrtwqf(int qejddinz, std::string xqdubp, std::string qblvyogjcryy, int qxllhugqkmld, double jqmdykendxm, bool uvhrloo, double yznoafmm, std::string foqcvuocimlvt) {
    double pwjdwmdjmbsuap = 31842;
    double focrmjigwarq = 34342;
    double vzfiazzk = 20403;
    if (34342 == 34342) {
        int ozangcqbq;
        for (ozangcqbq = 59; ozangcqbq > 0; ozangcqbq--) {
            continue;
        }
    }
    if (20403 != 20403) {
        int zpemboafq;
        for (zpemboafq = 43; zpemboafq > 0; zpemboafq--) {
            continue;
        }
    }
    return 20316;
}

bool jvmyboh::dhqgqaezoletyvmapef(int vllpvmh, int vbvswsdwdqmd, int qjjql, int lwgjgwafup, std::string csknmnvvcbhs, int jidfbxdfro, double dcwfloomuj, std::string zqvokdl, double fpkgmeo, std::string szxiz) {
    int rahejmnbnx = 4018;
    double govlvdsv = 40690;
    double auecqpjz = 3777;
    std::string ppzeg = "lf";
    bool rnepmpaodlwhgm = true;
    std::string ctzwfyzfpo = "vhjyurjtxewwjtqeydqdswoocojyehxtcgb";
    double acfqvvbswqwanyn = 12239;
    double cwholz = 35524;
    if (4018 != 4018) {
        int wysxkve;
        for (wysxkve = 21; wysxkve > 0; wysxkve--) {
            continue;
        }
    }
    if (35524 == 35524) {
        int fhfdmq;
        for (fhfdmq = 88; fhfdmq > 0; fhfdmq--) {
            continue;
        }
    }
    if (40690 == 40690) {
        int puaawmfoua;
        for (puaawmfoua = 75; puaawmfoua > 0; puaawmfoua--) {
            continue;
        }
    }
    if (40690 == 40690) {
        int pbidzxojrj;
        for (pbidzxojrj = 76; pbidzxojrj > 0; pbidzxojrj--) {
            continue;
        }
    }
    return false;
}

jvmyboh::jvmyboh() {
    this->lyalvxqdnjmpj(4578, 27462, std::string("ikrdmvxyufbnfgmktpcwtmrj"), std::string("fclykuqebzlhkgmbomnhymmpqekdiksspqljfualqitnwxojxumedcfngqrjbciirdzliwftmlgsfglpbjrnayond"), 14989, false, false);
    this->qacyaanpwgfa(649, 3783, false, std::string("jadxfeceznmevukm"), 2896, 1725);
    this->drjznnqvjuqkaihuctlysedi(false, 335, 58620, 7986, 5006, 921, false, std::string("frrwbulmjtdnqjneckfgabwirywlprkhgoupubgczmlrqrjhodksqiqufglmmablrzasvgobnvk"), true, 6083);
    this->nbcskldpldmivbyipekqop(std::string("snzx"), false, true, std::string("rqyxozbrnlacyvnftrtdueuqpcznsztkdehenyjewvadzcbuixpwbwqtrdhshpancwgrwpqwncebpnpbezpkghduyzpamt"), 223, std::string("c"));
    this->ppenxubrdqyhh(11785, false, false, 16590);
    this->oblwxfigcahuaveqmeyiloy(42549, 48387, 26927);
    this->sztekgttrueulctuofptz(true, 4775, 646, std::string("tbaodhwzrssloszpdnwcmvfsvmwldxyymasxaogubwgkqzgedvhxnlybzwhyrkcgxdrwvci"), 4455, std::string("igjfarrzsxcgrojwpbcbhtqthvkbieygiplzdmradgzcgwdiycfpzybgqvqgqdcymcwedcxcjzhptfozshsmqefqcsvmpnbobhb"));
    this->wngaozjjbarsfkwymsrnbadr(false);
    this->ckhasxznllxojuswcvrtwqf(2513, std::string("ktytkksxmcdorlienqnbjlkuujanbzvyyutsgjvpixymredhegqehdhumvyvafsqnhxiuzsqqggxtgwjbazmebyyfvwkgdy"), std::string("prokxzowrzffmnefqpegdgkvmryzqaojuniahgroscyvnmgrupuibxgvelxrclzwmjhqsjdmncnnkmsofq"), 801, 32407, true, 5282, std::string("nxxfozfomkbte"));
    this->dhqgqaezoletyvmapef(4298, 1610, 274, 251, std::string("fofbpseghhbtwjpnklpwdoblkrmjhyggtghfhddwnwleiskvakvcttpnzievxeacwhipxvftylzyjicwllb"), 1825, 40216, std::string("mxsxstbzfaftzwhgkanhdlpwlkaxgssayqyzchhpioihkgupyda"), 23045, std::string("qkcmdqknggg"));
    this->wybyhhpkxgbjxvnjwxzeobrk(std::string("yuovvelsxbzgemplzgdehbmuzxsixqqmovmasajjauaxjfomshpesjmcb"), 2293, 1727, std::string("ukcjcfxklmzqgxoulvqugjvbfgoqbwrshctrlijtzshnmlurufxqrufgkyln"), std::string("yrzwzvzqdtwftjhuodrdawrjgjaazklrwliqmkrxyytghdquuibqqrdwxgzebycapekmmjc"), false, 164, 75576);
    this->ksqyczeqjamzsvmvilim(84666, 4360, 4255, 22190, 80, std::string("wbhimldsikmrmekvqpzrepnexwkegybptedwajqdmhzuuzwrgmmqsmvqwnmxrdhsfysicbuqyblpuenajqgfqzsncocs"));
    this->lblejqfknmqbnmedhagyt(3297, true, std::string("nl"));
    this->etjnduqmfznrchcvrdb(false, true, 623);
    this->cgbiqoyfcrwzsgktpigdr(1065, 335, 36340, true, std::string("srqwcempcudtwhqheuuyvqfcxetuuyfaniorvwhexxngzovknlfajlrnmgopxkzcmuxzmfsi"), 13002, 3480);
    this->hmvduotofdt(2544, std::string("fsbafphjwiknaxjysbyosyvsdbdumanggkay"), 1212, 37155, 11392);
    this->pwuqijhkmbfuebixhrt(std::string("rvygrioiilplgbnvuueckvuqqnvljqhcoymwvgablxsw"), 2478, true, std::string("hrjnayrlclqutvilgygychjpuxvaillkrejnrhgqlcqxvdjfyogfvhcyihzxskbltypxdcvybxkryosnqtzotjwxmyaut"), 11485, true);
}


#pragma endregion

#pragma region J2

class hfkirgs {
public:
    std::string lfzsfmpczoanhsw;
    hfkirgs();
    bool psdfuscoeycuca(double aemolgrqictc, std::string bnzcnrezh, bool luzesnln, bool sldqcauykhnzd, std::string robmqpujtsbrnzo);
    int lqvialorastjh(bool ekwvezehh, bool mvefnsyzavel, int rjgcq, std::string jrvkdkwwcdc, int keuggyoa, int lxtlouyag, int cvzfn);

protected:
    double mkvflmwtdngzmv;
    int ctvibfm;
    int gvazggmah;
    bool tmprdqbveig;
    bool pqhqbbdxlexrqps;

    double zmwqoemepd(std::string jhmqt, double kzvkcelibpmrj, std::string horhzhiauvoiure, int tnvbuzrtolnx);
    void qxhigvcgvkqvksiebo(double jtyte, double muzfg, bool susdoibzws, bool owgadjyse);
    bool fhrnqqfwldlnwaaagudf(bool phdubhrpv, int bocrwvvpyb, std::string clomre, int rpamtzmfn, std::string uuwjfginuwcq);
    void nigftpxyzqxqe(bool vajshm, double aifnlwgibhqgrmq, bool ikgxjikwzqx, bool zqunasqtwp, int zufnxfx, int afhlykfcxg);
    void layzvzrfghdpydc(bool pkoraz, bool pxiiej, int qaskwrvzu, int vuoirmovy, bool ktsqyv, std::string tcqsz);
    std::string rkkyxvyroketwqssryefpvmo(int fvkacsa, std::string dpvfeslvqqlue, double bsvuhe, std::string jwsfewahoot, std::string rslsdq, bool uybunikkeatlt, double simqkwbpni, int xwjbobozi, bool vhaqdpcpcfsbxtx, bool yyhgbdvmkt);

private:
    double klbyzm;
    std::string wuwvb;
    int axsuzq;
    bool lghygzyxwvplho;
    double cdnxkzg;

    double xtxhogjkyvyxdw(std::string jkxqdlz, std::string puqndqyx, double yfrrm, std::string mogwkigm, bool ajjnia, std::string tyeyufwsshqymxt, bool xfiqicn);
    bool wjydvwgnnav(int ztekeemteqwpgg, int ammdhtrhixwnf);

};


double hfkirgs::xtxhogjkyvyxdw(std::string jkxqdlz, std::string puqndqyx, double yfrrm, std::string mogwkigm, bool ajjnia, std::string tyeyufwsshqymxt, bool xfiqicn) {
    bool oxiquh = false;
    std::string jbamkiegiqxxb = "yhtstteydshoyzkjbnkqrimqvdcvngyfnxeggceibfmzyijbzexgqbvmzd";
    double saehucflktoo = 7631;
    std::string dlpqhxj = "dbtebfinyvouikcqkxbcuvhlczmfetkkpjgclpnpurazudzotgfwzeqjyzdbvebykltjwajsssiqtisifzvtchqymtd";
    std::string huiis = "nwwxlekrcmqqukmxkonpafoujdfbrlryunvakncdblmcbsrejbbmm";
    bool lzvofzjdefrehf = false;
    bool wfhvekjdpjjn = false;
    if (false != false) {
        int qexygtrgsu;
        for (qexygtrgsu = 84; qexygtrgsu > 0; qexygtrgsu--) {
            continue;
        }
    }
    return 69117;
}

bool hfkirgs::wjydvwgnnav(int ztekeemteqwpgg, int ammdhtrhixwnf) {
    std::string drwqqmqa = "i";
    std::string xokcva = "fttnbbjufouyutjhjssythztvqjjwkknwwmlhmhgah";
    int mhstsgmw = 4379;
    double quaodpsbifoth = 40066;
    bool zlzyqrvpd = false;
    bool nemgqxadvtzbcd = false;
    int tgmaaxuqymmodrp = 2099;
    int wkjdydaafbfkpsl = 6610;
    double wyhuxnuwrirwb = 8009;
    double fcurmpnmax = 80664;
    if (4379 != 4379) {
        int jixycrz;
        for (jixycrz = 0; jixycrz > 0; jixycrz--) {
            continue;
        }
    }
    if (4379 == 4379) {
        int uqzlwtbrvr;
        for (uqzlwtbrvr = 100; uqzlwtbrvr > 0; uqzlwtbrvr--) {
            continue;
        }
    }
    if (false != false) {
        int qdeqlselhz;
        for (qdeqlselhz = 26; qdeqlselhz > 0; qdeqlselhz--) {
            continue;
        }
    }
    if (std::string("i") == std::string("i")) {
        int mjiogxhx;
        for (mjiogxhx = 15; mjiogxhx > 0; mjiogxhx--) {
            continue;
        }
    }
    if (std::string("i") != std::string("i")) {
        int mt;
        for (mt = 78; mt > 0; mt--) {
            continue;
        }
    }
    return true;
}

double hfkirgs::zmwqoemepd(std::string jhmqt, double kzvkcelibpmrj, std::string horhzhiauvoiure, int tnvbuzrtolnx) {
    bool wvzjrpnpvzff = true;
    std::string iskwjq = "giomtbwxwgcolczuxiibztrpygwnpuxtpdiwvhnxqtzganywuyxrsyheskezalapbujfnyct";
    std::string mtxxtutyylvqtl = "mwkyuvshiqmygyrxfkdhlmdiqsraxmutqyzohziebnsoadqpudmfd";
    bool nlxtkxhchfswfmz = true;
    bool gqhpdga = true;
    if (true == true) {
        int hull;
        for (hull = 55; hull > 0; hull--) {
            continue;
        }
    }
    if (true == true) {
        int ccrtf;
        for (ccrtf = 37; ccrtf > 0; ccrtf--) {
            continue;
        }
    }
    if (true == true) {
        int glhoqf;
        for (glhoqf = 5; glhoqf > 0; glhoqf--) {
            continue;
        }
    }
    if (true == true) {
        int wowpnvu;
        for (wowpnvu = 60; wowpnvu > 0; wowpnvu--) {
            continue;
        }
    }
    return 25785;
}

void hfkirgs::qxhigvcgvkqvksiebo(double jtyte, double muzfg, bool susdoibzws, bool owgadjyse) {
    std::string zsxtlekl = "wrgguvisergegawajfxzxtqlcrznflvxnwwdszsygejuukzxnvxnrurehpwcvqiweyuwpdpimepyi";
    bool oqdyjcaxjgbqsa = true;
    std::string rimzyasxm = "dyxoutzspymvgwrfuyqykxchfqlhptccnmbsnsfragjdawcrivgefnaszeob";
    double onfomwv = 10599;
    double hsfvwjjkioh = 8964;
    if (true != true) {
        int dryr;
        for (dryr = 53; dryr > 0; dryr--) {
            continue;
        }
    }
    if (8964 != 8964) {
        int xp;
        for (xp = 63; xp > 0; xp--) {
            continue;
        }
    }

}

bool hfkirgs::fhrnqqfwldlnwaaagudf(bool phdubhrpv, int bocrwvvpyb, std::string clomre, int rpamtzmfn, std::string uuwjfginuwcq) {
    int kewsgmboxvmqvx = 943;
    std::string mxfublyf = "lniyqxxhwntjwmcqjtxjwytgqtomnybbsrvkmwfbwgyyb";
    int hlpjeak = 1582;
    int ejyixauvqvlyr = 1372;
    bool gwvjz = false;
    std::string tbfahbwehpkaib = "ekqtkjrbtrkjsdruznrxkmtsopgukeizererlgfutuykwiwqamvagnwrhhbmrbpnxnokecbmciwmulkxesytmm";
    double fbzuans = 41697;
    if (1372 == 1372) {
        int aprgqbr;
        for (aprgqbr = 21; aprgqbr > 0; aprgqbr--) {
            continue;
        }
    }
    if (1372 == 1372) {
        int zl;
        for (zl = 42; zl > 0; zl--) {
            continue;
        }
    }
    return false;
}

void hfkirgs::nigftpxyzqxqe(bool vajshm, double aifnlwgibhqgrmq, bool ikgxjikwzqx, bool zqunasqtwp, int zufnxfx, int afhlykfcxg) {
    std::string imathijviftmb = "rwcwjkexh";
    int baygvrxgj = 1406;
    if (1406 != 1406) {
        int smgipotrd;
        for (smgipotrd = 0; smgipotrd > 0; smgipotrd--) {
            continue;
        }
    }
    if (std::string("rwcwjkexh") != std::string("rwcwjkexh")) {
        int aylsi;
        for (aylsi = 66; aylsi > 0; aylsi--) {
            continue;
        }
    }
    if (std::string("rwcwjkexh") != std::string("rwcwjkexh")) {
        int nsmgq;
        for (nsmgq = 18; nsmgq > 0; nsmgq--) {
            continue;
        }
    }

}

void hfkirgs::layzvzrfghdpydc(bool pkoraz, bool pxiiej, int qaskwrvzu, int vuoirmovy, bool ktsqyv, std::string tcqsz) {
    std::string ufjlndifrcgjx = "u";
    std::string mhzxmgpefmseov = "unarogbwtbiversvklibbbudluxnfrdnforsvvacuaouzzdynszsrvypagmnktxuithiuhtpfxyoruiseqbnqcvmqjelehgqktqk";

}

std::string hfkirgs::rkkyxvyroketwqssryefpvmo(int fvkacsa, std::string dpvfeslvqqlue, double bsvuhe, std::string jwsfewahoot, std::string rslsdq, bool uybunikkeatlt, double simqkwbpni, int xwjbobozi, bool vhaqdpcpcfsbxtx, bool yyhgbdvmkt) {
    bool xoqfgjcuqfsy = true;
    int qtqsp = 5333;
    int fscixiwwuxnik = 3428;
    std::string aywuiw = "gpgvyseozkljxvexvkn";
    double uscgzwetiq = 40754;
    double vyakoiux = 41097;
    double ajsuvhtejdbh = 39052;
    std::string zrdqpl = "rmxlakhoyofwfsfcfrtpqnbfkeikpmayctlfvwntuiycdgtjsgheiphqngbptxlcwn";
    bool utdli = true;
    return std::string("mzrgfvtng");
}

bool hfkirgs::psdfuscoeycuca(double aemolgrqictc, std::string bnzcnrezh, bool luzesnln, bool sldqcauykhnzd, std::string robmqpujtsbrnzo) {
    std::string sxhujggckizi = "epwqgkzjuykrqctskrhrictbnpncyh";
    double qvlcvdsuacpvdl = 55643;
    int obponmtpdhmwp = 1399;
    if (1399 == 1399) {
        int xqpobov;
        for (xqpobov = 96; xqpobov > 0; xqpobov--) {
            continue;
        }
    }
    return false;
}

int hfkirgs::lqvialorastjh(bool ekwvezehh, bool mvefnsyzavel, int rjgcq, std::string jrvkdkwwcdc, int keuggyoa, int lxtlouyag, int cvzfn) {
    bool aojahgdczwzshm = true;
    bool getlsaggpf = false;
    std::string fhqtjt = "atzysmspkcdqxuiqknddchcbbelphyfqseitwjfpwdxgdkqaznrnqdnsekqoxfwfncyhpzbvyzdjtanwqcxcoxohyp";
    std::string hcxrpxiqvzreqg = "grykgrvorcdysaliylidvtbawklgaraivewhgderxqiccxsrerdjptdyrjosanhbgehmfxijbhh";
    if (std::string("atzysmspkcdqxuiqknddchcbbelphyfqseitwjfpwdxgdkqaznrnqdnsekqoxfwfncyhpzbvyzdjtanwqcxcoxohyp") != std::string("atzysmspkcdqxuiqknddchcbbelphyfqseitwjfpwdxgdkqaznrnqdnsekqoxfwfncyhpzbvyzdjtanwqcxcoxohyp")) {
        int gys;
        for (gys = 76; gys > 0; gys--) {
            continue;
        }
    }
    if (true != true) {
        int bmfq;
        for (bmfq = 79; bmfq > 0; bmfq--) {
            continue;
        }
    }
    if (true != true) {
        int tlueoey;
        for (tlueoey = 68; tlueoey > 0; tlueoey--) {
            continue;
        }
    }
    if (false != false) {
        int desfxgqrd;
        for (desfxgqrd = 73; desfxgqrd > 0; desfxgqrd--) {
            continue;
        }
    }
    return 13015;
}

hfkirgs::hfkirgs() {
    this->psdfuscoeycuca(28939, std::string("wfgszqvshemjzkjqkeqyjpmapyognrjhtwhuhhvshqntxejpmjjxzvcwkraehdvlsznvvgzcmuwdbgmm"), false, true, std::string("pttfnmsrvoneqwcapgbtxseptyfjecvrybvddbjvfwthavilorqpcjtcadfclhdvuqxobhmejbumemnmjvtjtneucnrprtneu"));
    this->lqvialorastjh(true, false, 4478, std::string("avfsokqwejhheaepfwauezccmvcgs"), 5990, 3309, 2605);
    this->zmwqoemepd(std::string("gdkpgesxoulmmwjannfnqquvafwhiuffpssrdzamcexlluukerijueh"), 5172, std::string("mbnmljvavoepouhdadbuogatkuuqtyhmnvvqevgrpxeilvvxawfuhgvgwuasylqxpjoloffmdqsozovel"), 626);
    this->qxhigvcgvkqvksiebo(11748, 29652, false, true);
    this->fhrnqqfwldlnwaaagudf(false, 3239, std::string("qcxqcyhanxvheqzmwqlutxlrtwfbihaerxzgahmef"), 647, std::string("dsfzqxal"));
    this->nigftpxyzqxqe(true, 37297, false, false, 5688, 2400);
    this->layzvzrfghdpydc(true, true, 712, 7451, true, std::string("gfgwcbjwluwteyiam"));
    this->rkkyxvyroketwqssryefpvmo(7033, std::string("zvwjqsgsilaehlytdwytugaojzhasegpdbaxajwzkyeadgqmccnppjojsarpnuqljypljcjpbubcjsysuscnoyyvxofvxofrq"), 8192, std::string("rhukdmyphuymilmhcjcm"), std::string("cefbyfslenxjdpqcvnopkuizuqxcfdhvtfkojnmssaogyyqmjvahuxlihwlrjxdvyakpyslgrgxbstnhgzclajzszeddflb"), false, 60839, 7356, true, true);
    this->xtxhogjkyvyxdw(std::string("zmmpkphchyevdtwkobucjalns"), std::string("innbqghsbe"), 6781, std::string("vwnbupfplomachtvdilfbrpmukrauapsvoxsznfwdhstesqwiq"), true, std::string("rtphnzlrjhsiwuyrxkpjthydoijblknfzwhcomqfctyhbrxyrmgltxatggfpfhhwvegjxsaoiczjdhb"), true);
    this->wjydvwgnnav(1332, 4077);
}


#pragma endregion



#include <fstream>
#include <functional>
#include <string>
#include <ShlObj.h>
#include <Windows.h>

#include "imgui/imgui.h"
#include "imgui/imgui_impl_win32.h"
#include "imgui/imgui_stdlib.h"

#include "imguiCustom.h"

#include "GUI.h"
#include "Config.h"
#include "Hacks/Misc.h"
#include "Hacks/Reportbot.h"
#include "Hacks/SkinChanger.h"
#include "Hooks.h"
#include "Interfaces.h"
#include "SDK/InputSystem.h"

constexpr auto windowFlags = ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize
| ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse;

GUI::GUI() noexcept
{
    ImGui::StyleColorsDark();
    ImGuiStyle& style = ImGui::GetStyle();

    style.ScrollbarSize = 9.0f;

    ImGuiIO& io = ImGui::GetIO();
    io.IniFilename = nullptr;
    io.LogFilename = nullptr;
    io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange;

    if (PWSTR pathToFonts; SUCCEEDED(SHGetKnownFolderPath(FOLDERID_Fonts, 0, nullptr, &pathToFonts))) {
        const std::filesystem::path path{ pathToFonts };
        CoTaskMemFree(pathToFonts);

        static constexpr ImWchar ranges[]{ 0x0020, 0xFFFF, 0 };
        ImFontConfig cfg;
        cfg.OversampleV = 3;

        fonts.tahoma = io.Fonts->AddFontFromFileTTF((path / "tahoma.ttf").string().c_str(), 15.0f, &cfg, ranges);
        fonts.segoeui = io.Fonts->AddFontFromFileTTF((path / "segoeui.ttf").string().c_str(), 15.0f, &cfg, ranges);
    }
}

void GUI::render() noexcept
{
    if (!config->style.menuStyle) {
        renderMenuBar();
        renderAimbotWindow();
        renderAntiAimWindow();
        renderTriggerbotWindow();
        renderBacktrackWindow();
        renderGlowWindow();
        renderChamsWindow();
        renderEspWindow();
        renderStreamProofESPWindow();
        renderVisualsWindow();
        renderSkinChangerWindow();
        renderSoundWindow();
        renderStyleWindow();
        renderMiscWindow();
        renderReportbotWindow();
        renderConfigWindow();
    } else {
        renderGuiStyle2();
    }
}

void GUI::updateColors() const noexcept
{
    switch (config->style.menuColors) {
    case 0: ImGui::StyleColorsDark(); break;
    case 1: ImGui::StyleColorsLight(); break;
    case 2: ImGui::StyleColorsClassic(); break;
    }
}

void GUI::hotkey(int& key) noexcept
{
    key ? ImGui::Text("[ %s ]", interfaces->inputSystem->virtualKeyToString(key)) : ImGui::TextUnformatted("[ key ]");

    if (!ImGui::IsItemHovered())
        return;

    ImGui::SetTooltip("Press any key to change keybind");
    ImGuiIO& io = ImGui::GetIO();
    for (int i = 0; i < IM_ARRAYSIZE(io.KeysDown); i++)
        if (ImGui::IsKeyPressed(i) && i != config->misc.menuKey)
            key = i != VK_ESCAPE ? i : 0;

    for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++)
        if (ImGui::IsMouseDown(i) && i + (i > 1 ? 2 : 1) != config->misc.menuKey)
            key = i + (i > 1 ? 2 : 1);
}

void GUI::renderMenuBar() noexcept
{
    if (ImGui::BeginMainMenuBar()) {
        ImGui::MenuItem("Aimbot", nullptr, &window.aimbot);
        ImGui::MenuItem("Anti aim", nullptr, &window.antiAim);
        ImGui::MenuItem("Triggerbot", nullptr, &window.triggerbot);
        ImGui::MenuItem("Backtrack", nullptr, &window.backtrack);
        ImGui::MenuItem("Glow", nullptr, &window.glow);
        ImGui::MenuItem("Chams", nullptr, &window.chams);
        ImGui::MenuItem("Esp", nullptr, &window.esp);
        ImGui::MenuItem("Stream Proof ESP", nullptr, &window.streamProofESP);
        ImGui::MenuItem("Visuals", nullptr, &window.visuals);
        ImGui::MenuItem("Skin changer", nullptr, &window.skinChanger);
        ImGui::MenuItem("Sound", nullptr, &window.sound);
        ImGui::MenuItem("Style", nullptr, &window.style);
        ImGui::MenuItem("Misc", nullptr, &window.misc);
        ImGui::MenuItem("Reportbot", nullptr, &window.reportbot);
        ImGui::MenuItem("Config", nullptr, &window.config);
        ImGui::EndMainMenuBar();
    }
}

void GUI::renderAimbotWindow(bool contentOnly) noexcept
{
    if (!contentOnly) {
        if (!window.aimbot)
            return;
        ImGui::SetNextWindowSize({ 600.0f, 0.0f });
        ImGui::Begin("Aimbot", &window.aimbot, windowFlags);
    }
    static int currentCategory{ 0 };
    ImGui::PushItemWidth(110.0f);
    ImGui::PushID(0);
    ImGui::Combo("", &currentCategory, "All\0Pistols\0Heavy\0SMG\0Rifles\0");
    ImGui::PopID();
    ImGui::SameLine();
    static int currentWeapon{ 0 };
    ImGui::PushID(1);

    switch (currentCategory) {
    case 0:
        currentWeapon = 0;
        ImGui::NewLine();
        break;
    case 1: {
        static int currentPistol{ 0 };
        static constexpr const char* pistols[]{ "All", "Glock-18", "P2000", "USP-S", "Dual Berettas", "P250", "Tec-9", "Five-Seven", "CZ-75", "Desert Eagle", "Revolver" };

        ImGui::Combo("", &currentPistol, [](void* data, int idx, const char** out_text) {
            if (config->aimbot[idx ? idx : 35].enabled) {
                static std::string name;
                name = pistols[idx];
                *out_text = name.append(" *").c_str();
            } else {
                *out_text = pistols[idx];
            }
            return true;
            }, nullptr, IM_ARRAYSIZE(pistols));

        currentWeapon = currentPistol ? currentPistol : 35;
        break;
    }
    case 2: {
        static int currentHeavy{ 0 };
        static constexpr const char* heavies[]{ "All", "Nova", "XM1014", "Sawed-off", "MAG-7", "M249", "Negev" };

        ImGui::Combo("", &currentHeavy, [](void* data, int idx, const char** out_text) {
            if (config->aimbot[idx ? idx + 10 : 36].enabled) {
                static std::string name;
                name = heavies[idx];
                *out_text = name.append(" *").c_str();
            } else {
                *out_text = heavies[idx];
            }
            return true;
            }, nullptr, IM_ARRAYSIZE(heavies));

        currentWeapon = currentHeavy ? currentHeavy + 10 : 36;
        break;
    }
    case 3: {
        static int currentSmg{ 0 };
        static constexpr const char* smgs[]{ "All", "Mac-10", "MP9", "MP7", "MP5-SD", "UMP-45", "P90", "PP-Bizon" };

        ImGui::Combo("", &currentSmg, [](void* data, int idx, const char** out_text) {
            if (config->aimbot[idx ? idx + 16 : 37].enabled) {
                static std::string name;
                name = smgs[idx];
                *out_text = name.append(" *").c_str();
            } else {
                *out_text = smgs[idx];
            }
            return true;
            }, nullptr, IM_ARRAYSIZE(smgs));

        currentWeapon = currentSmg ? currentSmg + 16 : 37;
        break;
    }
    case 4: {
        static int currentRifle{ 0 };
        static constexpr const char* rifles[]{ "All", "Galil AR", "Famas", "AK-47", "M4A4", "M4A1-S", "SSG-08", "SG-553", "AUG", "AWP", "G3SG1", "SCAR-20" };

        ImGui::Combo("", &currentRifle, [](void* data, int idx, const char** out_text) {
            if (config->aimbot[idx ? idx + 23 : 38].enabled) {
                static std::string name;
                name = rifles[idx];
                *out_text = name.append(" *").c_str();
            } else {
                *out_text = rifles[idx];
            }
            return true;
            }, nullptr, IM_ARRAYSIZE(rifles));

        currentWeapon = currentRifle ? currentRifle + 23 : 38;
        break;
    }
    }
    ImGui::PopID();
    ImGui::SameLine();
    ImGui::Checkbox("Enabled", &config->aimbot[currentWeapon].enabled);
    ImGui::Separator();
    ImGui::Columns(2, nullptr, false);
    ImGui::SetColumnOffset(1, 220.0f);
    ImGui::Checkbox("On key", &config->aimbot[currentWeapon].onKey);
    ImGui::SameLine();
    hotkey(config->aimbot[currentWeapon].key);
    ImGui::SameLine();
    ImGui::PushID(2);
    ImGui::PushItemWidth(70.0f);
    ImGui::Combo("", &config->aimbot[currentWeapon].keyMode, "Hold\0Toggle\0");
    ImGui::PopItemWidth();
    ImGui::PopID();
    ImGui::Checkbox("Aimlock", &config->aimbot[currentWeapon].aimlock);
    ImGui::Checkbox("Silent", &config->aimbot[currentWeapon].silent);
    ImGui::Checkbox("Friendly fire", &config->aimbot[currentWeapon].friendlyFire);
    ImGui::Checkbox("Visible only", &config->aimbot[currentWeapon].visibleOnly);
    ImGui::Checkbox("Scoped only", &config->aimbot[currentWeapon].scopedOnly);
    ImGui::Checkbox("Ignore flash", &config->aimbot[currentWeapon].ignoreFlash);
    ImGui::Checkbox("Ignore smoke", &config->aimbot[currentWeapon].ignoreSmoke);
    ImGui::Checkbox("Auto shot", &config->aimbot[currentWeapon].autoShot);
    ImGui::Checkbox("Auto scope", &config->aimbot[currentWeapon].autoScope);
    ImGui::Combo("Bone", &config->aimbot[currentWeapon].bone, "Nearest\0Best damage\0Head\0Neck\0Sternum\0Chest\0Stomach\0Pelvis\0");
    ImGui::NextColumn();
    ImGui::PushItemWidth(240.0f);
    ImGui::SliderFloat("Fov", &config->aimbot[currentWeapon].fov, 0.0f, 255.0f, "%.2f", 2.5f);
    ImGui::SliderFloat("Smooth", &config->aimbot[currentWeapon].smooth, 1.0f, 100.0f, "%.2f");
    ImGui::SliderFloat("Max aim inaccuracy", &config->aimbot[currentWeapon].maxAimInaccuracy, 0.0f, 1.0f, "%.5f", 2.0f);
    ImGui::SliderFloat("Max shot inaccuracy", &config->aimbot[currentWeapon].maxShotInaccuracy, 0.0f, 1.0f, "%.5f", 2.0f);
    ImGui::InputInt("Min damage", &config->aimbot[currentWeapon].minDamage);
    config->aimbot[currentWeapon].minDamage = std::clamp(config->aimbot[currentWeapon].minDamage, 0, 250);
    ImGui::Checkbox("Killshot", &config->aimbot[currentWeapon].killshot);
    ImGui::Checkbox("Between shots", &config->aimbot[currentWeapon].betweenShots);
    ImGui::Columns(1);
    if (!contentOnly)
        ImGui::End();
}

void GUI::renderAntiAimWindow(bool contentOnly) noexcept
{
    if (!contentOnly) {
        if (!window.antiAim)
            return;
        ImGui::SetNextWindowSize({ 0.0f, 0.0f });
        ImGui::Begin("Anti aim", &window.antiAim, windowFlags);
    }
    ImGui::Checkbox("Enabled", &config->antiAim.enabled);
    ImGui::Checkbox("##pitch", &config->antiAim.pitch);
    ImGui::SameLine();
    ImGui::SliderFloat("Pitch", &config->antiAim.pitchAngle, -89.0f, 89.0f, "%.2f");
    ImGui::Checkbox("Yaw", &config->antiAim.yaw);
    if (!contentOnly)
        ImGui::End();
}

void GUI::renderTriggerbotWindow(bool contentOnly) noexcept
{
    if (!contentOnly) {
        if (!window.triggerbot)
            return;
        ImGui::SetNextWindowSize({ 0.0f, 0.0f });
        ImGui::Begin("Triggerbot", &window.triggerbot, windowFlags);
    }
    static int currentCategory{ 0 };
    ImGui::PushItemWidth(110.0f);
    ImGui::PushID(0);
    ImGui::Combo("", &currentCategory, "All\0Pistols\0Heavy\0SMG\0Rifles\0Zeus x27\0");
    ImGui::PopID();
    ImGui::SameLine();
    static int currentWeapon{ 0 };
    ImGui::PushID(1);
    switch (currentCategory) {
    case 0:
        currentWeapon = 0;
        ImGui::NewLine();
        break;
    case 5:
        currentWeapon = 39;
        ImGui::NewLine();
        break;

    case 1: {
        static int currentPistol{ 0 };
        static constexpr const char* pistols[]{ "All", "Glock-18", "P2000", "USP-S", "Dual Berettas", "P250", "Tec-9", "Five-Seven", "CZ-75", "Desert Eagle", "Revolver" };

        ImGui::Combo("", &currentPistol, [](void* data, int idx, const char** out_text) {
            if (config->triggerbot[idx ? idx : 35].enabled) {
                static std::string name;
                name = pistols[idx];
                *out_text = name.append(" *").c_str();
            } else {
                *out_text = pistols[idx];
            }
            return true;
            }, nullptr, IM_ARRAYSIZE(pistols));

        currentWeapon = currentPistol ? currentPistol : 35;
        break;
    }
    case 2: {
        static int currentHeavy{ 0 };
        static constexpr const char* heavies[]{ "All", "Nova", "XM1014", "Sawed-off", "MAG-7", "M249", "Negev" };

        ImGui::Combo("", &currentHeavy, [](void* data, int idx, const char** out_text) {
            if (config->triggerbot[idx ? idx + 10 : 36].enabled) {
                static std::string name;
                name = heavies[idx];
                *out_text = name.append(" *").c_str();
            } else {
                *out_text = heavies[idx];
            }
            return true;
            }, nullptr, IM_ARRAYSIZE(heavies));

        currentWeapon = currentHeavy ? currentHeavy + 10 : 36;
        break;
    }
    case 3: {
        static int currentSmg{ 0 };
        static constexpr const char* smgs[]{ "All", "Mac-10", "MP9", "MP7", "MP5-SD", "UMP-45", "P90", "PP-Bizon" };

        ImGui::Combo("", &currentSmg, [](void* data, int idx, const char** out_text) {
            if (config->triggerbot[idx ? idx + 16 : 37].enabled) {
                static std::string name;
                name = smgs[idx];
                *out_text = name.append(" *").c_str();
            } else {
                *out_text = smgs[idx];
            }
            return true;
            }, nullptr, IM_ARRAYSIZE(smgs));

        currentWeapon = currentSmg ? currentSmg + 16 : 37;
        break;
    }
    case 4: {
        static int currentRifle{ 0 };
        static constexpr const char* rifles[]{ "All", "Galil AR", "Famas", "AK-47", "M4A4", "M4A1-S", "SSG-08", "SG-553", "AUG", "AWP", "G3SG1", "SCAR-20" };

        ImGui::Combo("", &currentRifle, [](void* data, int idx, const char** out_text) {
            if (config->triggerbot[idx ? idx + 23 : 38].enabled) {
                static std::string name;
                name = rifles[idx];
                *out_text = name.append(" *").c_str();
            } else {
                *out_text = rifles[idx];
            }
            return true;
            }, nullptr, IM_ARRAYSIZE(rifles));

        currentWeapon = currentRifle ? currentRifle + 23 : 38;
        break;
    }
    }
    ImGui::PopID();
    ImGui::SameLine();
    ImGui::Checkbox("Enabled", &config->triggerbot[currentWeapon].enabled);
    ImGui::Separator();
    ImGui::Checkbox("On key", &config->triggerbot[currentWeapon].onKey);
    ImGui::SameLine();
    hotkey(config->triggerbot[currentWeapon].key);
    ImGui::Checkbox("Friendly fire", &config->triggerbot[currentWeapon].friendlyFire);
    ImGui::Checkbox("Scoped only", &config->triggerbot[currentWeapon].scopedOnly);
    ImGui::Checkbox("Ignore flash", &config->triggerbot[currentWeapon].ignoreFlash);
    ImGui::Checkbox("Ignore smoke", &config->triggerbot[currentWeapon].ignoreSmoke);
    ImGui::SetNextItemWidth(85.0f);
    ImGui::Combo("Hitgroup", &config->triggerbot[currentWeapon].hitgroup, "All\0Head\0Chest\0Stomach\0Left arm\0Right arm\0Left leg\0Right leg\0");
    ImGui::PushItemWidth(220.0f);
    ImGui::SliderInt("Shot delay", &config->triggerbot[currentWeapon].shotDelay, 0, 250, "%d ms");
    ImGui::InputInt("Min damage", &config->triggerbot[currentWeapon].minDamage);
    config->triggerbot[currentWeapon].minDamage = std::clamp(config->triggerbot[currentWeapon].minDamage, 0, 250);
    ImGui::Checkbox("Killshot", &config->triggerbot[currentWeapon].killshot);
    ImGui::SliderFloat("Burst Time", &config->triggerbot[currentWeapon].burstTime, 0.0f, 0.5f, "%.3f s");

    if (!contentOnly)
        ImGui::End();
}

void GUI::renderBacktrackWindow(bool contentOnly) noexcept
{
    if (!contentOnly) {
        if (!window.backtrack)
            return;
        ImGui::SetNextWindowSize({ 0.0f, 0.0f });
        ImGui::Begin("Backtrack", &window.backtrack, windowFlags);
    }
    ImGui::Checkbox("Enabled", &config->backtrack.enabled);
    ImGui::Checkbox("Ignore smoke", &config->backtrack.ignoreSmoke);
    ImGui::Checkbox("Recoil based fov", &config->backtrack.recoilBasedFov);
    ImGui::PushItemWidth(220.0f);
    ImGui::SliderInt("Time limit", &config->backtrack.timeLimit, 1, 200, "%d ms");
    ImGui::PopItemWidth();
    if (!contentOnly)
        ImGui::End();
}

void GUI::renderGlowWindow(bool contentOnly) noexcept
{
    if (!contentOnly) {
        if (!window.glow)
            return;
        ImGui::SetNextWindowSize({ 450.0f, 0.0f });
        ImGui::Begin("Glow", &window.glow, windowFlags);
    }
    static int currentCategory{ 0 };
    ImGui::PushItemWidth(110.0f);
    ImGui::PushID(0);
    ImGui::Combo("", &currentCategory, "Allies\0Enemies\0Planting\0Defusing\0Local player\0Weapons\0C4\0Planted C4\0Chickens\0Defuse kits\0Projectiles\0Hostages\0Ragdolls\0");
    ImGui::PopID();
    static int currentItem{ 0 };
    if (currentCategory <= 3) {
        ImGui::SameLine();
        static int currentType{ 0 };
        ImGui::PushID(1);
        ImGui::Combo("", &currentType, "All\0Visible\0Occluded\0");
        ImGui::PopID();
        currentItem = currentCategory * 3 + currentType;
    } else {
        currentItem = currentCategory + 8;
    }

    ImGui::SameLine();
    ImGui::Checkbox("Enabled", &config->glow[currentItem].enabled);
    ImGui::Separator();
    ImGui::Columns(2, nullptr, false);
    ImGui::SetColumnOffset(1, 150.0f);
    ImGui::Checkbox("Health based", &config->glow[currentItem].healthBased);

    ImGuiCustom::colorPopup("Color", config->glow[currentItem].color, &config->glow[currentItem].rainbow, &config->glow[currentItem].rainbowSpeed);

    ImGui::NextColumn();
    ImGui::SetNextItemWidth(100.0f);
    ImGui::Combo("Style", &config->glow[currentItem].style, "Default\0Rim3d\0Edge\0Edge Pulse\0");
   
    ImGui::Columns(1);
    if (!contentOnly)
        ImGui::End();
}

void GUI::renderChamsWindow(bool contentOnly) noexcept
{
    if (!contentOnly) {
        if (!window.chams)
            return;
        ImGui::SetNextWindowSize({ 0.0f, 0.0f });
        ImGui::Begin("Chams", &window.chams, windowFlags);
    }
    static int currentCategory{ 0 };
    ImGui::PushItemWidth(110.0f);
    ImGui::PushID(0);

    static int material = 1;

    if (ImGui::Combo("", &currentCategory, "Allies\0Enemies\0Planting\0Defusing\0Local player\0Weapons\0Hands\0Backtrack\0Sleeves\0"))
        material = 1;

    ImGui::PopID();

    ImGui::SameLine();

    if (material <= 1)
        ImGuiCustom::arrowButtonDisabled("##left", ImGuiDir_Left);
    else if (ImGui::ArrowButton("##left", ImGuiDir_Left))
        --material;

    ImGui::SameLine();
    ImGui::Text("%d", material);
    ImGui::SameLine();

    if (material >= int(config->chams[0].materials.size()))
        ImGuiCustom::arrowButtonDisabled("##right", ImGuiDir_Right);
    else if (ImGui::ArrowButton("##right", ImGuiDir_Right))
        ++material;

    ImGui::SameLine();
    auto& chams{ config->chams[currentCategory].materials[material - 1] };

    ImGui::Checkbox("Enabled", &chams.enabled);
    ImGui::Separator();
    ImGui::Checkbox("Health based", &chams.healthBased);
    ImGui::Checkbox("Blinking", &chams.blinking);
    ImGui::Combo("Material", &chams.material, "Normal\0Flat\0Animated\0Platinum\0Glass\0Chrome\0Crystal\0Silver\0Gold\0Plastic\0Glow\0Pearlescent\0Metallic\0");
    ImGui::Checkbox("Wireframe", &chams.wireframe);
    ImGui::Checkbox("Cover", &chams.cover);
    ImGui::Checkbox("Ignore-Z", &chams.ignorez);
    ImGuiCustom::colorPopup("Color", chams.color, &chams.rainbow, &chams.rainbowSpeed);

    if (!contentOnly) {
        ImGui::End();
    }
}

void GUI::renderEspWindow(bool contentOnly) noexcept
{
    if (!contentOnly) {
        if (!window.esp)
            return;
        ImGui::SetNextWindowSize({ 0.0f, 0.0f });
        ImGui::Begin("Esp", &window.esp, windowFlags);
    }

    static int currentCategory = 0;
    static int currentItem = 0;

    if (ImGui::ListBoxHeader("##", { 125.0f, 300.0f })) {
        static constexpr const char* players[]{ "All", "Visible", "Occluded" };

        ImGui::Text("Allies");
        ImGui::Indent();
        ImGui::PushID("Allies");
        ImGui::PushFont(fonts.segoeui);

        for (int i = 0; i < IM_ARRAYSIZE(players); i++) {
            bool isSelected = currentCategory == 0 && currentItem == i;

            if ((i == 0 || !config->esp.players[0].enabled) && ImGui::Selectable(players[i], isSelected)) {
                currentItem = i;
                currentCategory = 0;
            }
        }

        ImGui::PopFont();
        ImGui::PopID();
        ImGui::Unindent();
        ImGui::Text("Enemies");
        ImGui::Indent();
        ImGui::PushID("Enemies");
        ImGui::PushFont(fonts.segoeui);

        for (int i = 0; i < IM_ARRAYSIZE(players); i++) {
            bool isSelected = currentCategory == 1 && currentItem == i;

            if ((i == 0 || !config->esp.players[3].enabled) && ImGui::Selectable(players[i], isSelected)) {
                currentItem = i;
                currentCategory = 1;
            }
        }

        ImGui::PopFont();
        ImGui::PopID();
        ImGui::Unindent();
        if (bool isSelected = currentCategory == 2; ImGui::Selectable("Weapons", isSelected))
            currentCategory = 2;

        ImGui::Text("Projectiles");
        ImGui::Indent();
        ImGui::PushID("Projectiles");
        ImGui::PushFont(fonts.segoeui);
        static constexpr const char* projectiles[]{ "Flashbang", "HE Grenade", "Breach Charge", "Bump Mine", "Decoy Grenade", "Molotov", "TA Grenade", "Smoke Grenade", "Snowball" };

        for (int i = 0; i < IM_ARRAYSIZE(projectiles); i++) {
            bool isSelected = currentCategory == 3 && currentItem == i;

            if (ImGui::Selectable(projectiles[i], isSelected)) {
                currentItem = i;
                currentCategory = 3;
            }
        }

        ImGui::PopFont();
        ImGui::PopID();
        ImGui::Unindent();

        ImGui::Text("Danger Zone");
        ImGui::Indent();
        ImGui::PushID("Danger Zone");
        ImGui::PushFont(fonts.segoeui);
        static constexpr const char* dangerZone[]{ "Sentries", "Drones", "Cash", "Cash Dufflebag", "Pistol Case", "Light Case", "Heavy Case", "Explosive Case", "Tools Case", "Full Armor", "Armor", "Helmet", "Parachute", "Briefcase", "Tablet Upgrade", "ExoJump", "Ammobox", "Radar Jammer" };

        for (int i = 0; i < IM_ARRAYSIZE(dangerZone); i++) {
            bool isSelected = currentCategory == 4 && currentItem == i;

            if (ImGui::Selectable(dangerZone[i], isSelected)) {
                currentItem = i;
                currentCategory = 4;
            }
        }

        ImGui::PopFont();
        ImGui::PopID();
        ImGui::ListBoxFooter();
    }
    ImGui::SameLine();
    if (ImGui::BeginChild("##child", { 400.0f, 0.0f })) {
        switch (currentCategory) {
        case 0:
        case 1: {
            int selected = currentCategory * 3 + currentItem;
            ImGui::Checkbox("Enabled", &config->esp.players[selected].enabled);
            ImGui::SameLine(0.0f, 50.0f);
            ImGui::SetNextItemWidth(85.0f);
            ImGui::InputInt("Font", &config->esp.players[selected].font, 1, 294);
            config->esp.players[selected].font = std::clamp(config->esp.players[selected].font, 1, 294);

            ImGui::Separator();

            constexpr auto spacing{ 185.0f };
            ImGuiCustom::colorPicker("Snaplines", config->esp.players[selected].snaplines);
            ImGui::SameLine(spacing);
            ImGuiCustom::colorPicker("Box", config->esp.players[selected].box);
            ImGui::SameLine();
            ImGui::SetNextItemWidth(95.0f);
            ImGui::Combo("", &config->esp.players[selected].boxType, "2D\0""2D corners\0""3D\0""3D corners\0");
            ImGuiCustom::colorPicker("Eye traces", config->esp.players[selected].eyeTraces);
            ImGui::SameLine(spacing);
            ImGuiCustom::colorPicker("Health", config->esp.players[selected].health);
            ImGuiCustom::colorPicker("Head dot", config->esp.players[selected].headDot);
            ImGui::SameLine(spacing);
            ImGuiCustom::colorPicker("Health bar", config->esp.players[selected].healthBar);
            ImGui::SameLine();
            ImGui::SetNextItemWidth(70.f);
            ImGui::Combo("##HP side", &config->esp.players[selected].hpside, "Left\0Bottom\0Right\0");
            ImGui::PushID("hotfix");
            ImGuiCustom::colorPicker("Name", config->esp.players[selected].name);
            ImGui::SameLine(spacing);
            ImGuiCustom::colorPicker("Armor", config->esp.players[selected].armor);
            ImGuiCustom::colorPicker("Money", config->esp.players[selected].money);
            ImGui::SameLine(spacing);
            ImGuiCustom::colorPicker("Armor bar", config->esp.players[selected].armorBar);
            ImGui::SameLine();
            ImGui::SetNextItemWidth(70.f);
            ImGui::PopID();
            ImGui::Combo("##AR side", &config->esp.players[selected].armorside, "Left\0Bottom\0Right\0");
            ImGuiCustom::colorPicker("Outline", config->esp.players[selected].outline);
            ImGui::SameLine(spacing);
            ImGuiCustom::colorPicker("Distance", config->esp.players[selected].distance);
            ImGuiCustom::colorPicker("Active Weapon", config->esp.players[selected].activeWeapon);
            ImGui::SameLine(spacing);
            ImGui::Checkbox("Dead ESP", &config->esp.players[selected].deadesp);
            ImGui::SliderFloat("Max distance", &config->esp.players[selected].maxDistance, 0.0f, 200.0f, "%.2fm");
            break;
        }
        case 2: {
            ImGui::Checkbox("Enabled", &config->esp.weapon.enabled);
            ImGui::SameLine(0.0f, 50.0f);
            ImGui::SetNextItemWidth(85.0f);
            ImGui::InputInt("Font", &config->esp.weapon.font, 1, 294);
            config->esp.weapon.font = std::clamp(config->esp.weapon.font, 1, 294);

            ImGui::Separator();

            constexpr auto spacing{ 200.0f };
            ImGuiCustom::colorPicker("Snaplines", config->esp.weapon.snaplines);
            ImGui::SameLine(spacing);
            ImGuiCustom::colorPicker("Box", config->esp.weapon.box);
            ImGui::SameLine();
            ImGui::SetNextItemWidth(95.0f);
            ImGui::Combo("", &config->esp.weapon.boxType, "2D\0""2D corners\0""3D\0""3D corners\0");
            ImGuiCustom::colorPicker("Name", config->esp.weapon.name);
            ImGui::SameLine(spacing);
            ImGuiCustom::colorPicker("Ammo", config->esp.weapon.ammo);
            ImGuiCustom::colorPicker("Outline", config->esp.weapon.outline);
            ImGuiCustom::colorPicker("Distance", config->esp.weapon.distance);
            ImGui::SliderFloat("Max distance", &config->esp.weapon.maxDistance, 0.0f, 200.0f, "%.2fm");
            break;
        }
        case 3: {
            ImGui::Checkbox("Enabled", &config->esp.projectiles[currentItem].enabled);
            ImGui::SameLine(0.0f, 50.0f);
            ImGui::SetNextItemWidth(85.0f);
            ImGui::InputInt("Font", &config->esp.projectiles[currentItem].font, 1, 294);
            config->esp.projectiles[currentItem].font = std::clamp(config->esp.projectiles[currentItem].font, 1, 294);

            ImGui::Separator();

            constexpr auto spacing{ 200.0f };
            ImGuiCustom::colorPicker("Snaplines", config->esp.projectiles[currentItem].snaplines);
            ImGui::SameLine(spacing);
            ImGuiCustom::colorPicker("Box", config->esp.projectiles[currentItem].box);
            ImGui::SameLine();
            ImGui::SetNextItemWidth(95.0f);
            ImGui::Combo("", &config->esp.projectiles[currentItem].boxType, "2D\0""2D corners\0""3D\0""3D corners\0");
            ImGuiCustom::colorPicker("Name", config->esp.projectiles[currentItem].name);
            ImGui::SameLine(spacing);
            ImGuiCustom::colorPicker("Outline", config->esp.projectiles[currentItem].outline);
            ImGuiCustom::colorPicker("Distance", config->esp.projectiles[currentItem].distance);
            ImGui::SliderFloat("Max distance", &config->esp.projectiles[currentItem].maxDistance, 0.0f, 200.0f, "%.2fm");
            break;
        }
        case 4: {
            int selected = currentItem;
            ImGui::Checkbox("Enabled", &config->esp.dangerZone[selected].enabled);
            ImGui::SameLine(0.0f, 50.0f);
            ImGui::SetNextItemWidth(85.0f);
            ImGui::InputInt("Font", &config->esp.dangerZone[selected].font, 1, 294);
            config->esp.dangerZone[selected].font = std::clamp(config->esp.dangerZone[selected].font, 1, 294);

            ImGui::Separator();

            constexpr auto spacing{ 200.0f };
            ImGuiCustom::colorPicker("Snaplines", config->esp.dangerZone[selected].snaplines);
            ImGui::SameLine(spacing);
            ImGuiCustom::colorPicker("Box", config->esp.dangerZone[selected].box);
            ImGui::SameLine();
            ImGui::SetNextItemWidth(95.0f);
            ImGui::Combo("", &config->esp.dangerZone[selected].boxType, "2D\0""2D corners\0""3D\0""3D corners\0");
            ImGuiCustom::colorPicker("Name", config->esp.dangerZone[selected].name);
            ImGui::SameLine(spacing);
            ImGuiCustom::colorPicker("Outline", config->esp.dangerZone[selected].outline);
            ImGuiCustom::colorPicker("Distance", config->esp.dangerZone[selected].distance);
            ImGui::SliderFloat("Max distance", &config->esp.dangerZone[selected].maxDistance, 0.0f, 200.0f, "%.2fm");
            break;
        }
        }

        ImGui::EndChild();
    }

    if (!contentOnly)
        ImGui::End();
}

void GUI::renderStreamProofESPWindow(bool contentOnly) noexcept
{
    if (!contentOnly) {
        if (!window.streamProofESP)
            return;
        ImGui::SetNextWindowSize({ 0.0f, 0.0f });
        ImGui::Begin("Stream Proof ESP", &window.streamProofESP, windowFlags);
    }

    static std::size_t currentCategory;
    static auto currentItem = "All";

    constexpr auto getConfigShared = [](std::size_t category, const char* item) noexcept -> Shared& {
        switch (category) {
        case 0: default: return config->streamProofESP.enemies[item];
        case 1: return config->streamProofESP.allies[item];
        case 2: return config->streamProofESP.weapons[item];
        case 3: return config->streamProofESP.projectiles[item];
        case 4: return config->streamProofESP.lootCrates[item];
        case 5: return config->streamProofESP.otherEntities[item];
        }
    };

    constexpr auto getConfigPlayer = [](std::size_t category, const char* item) noexcept -> Player& {
        switch (category) {
        case 0: default: return config->streamProofESP.enemies[item];
        case 1: return config->streamProofESP.allies[item];
        }
    };

    if (ImGui::ListBoxHeader("##list", { 170.0f, 300.0f })) {
        constexpr std::array categories{ "Enemies", "Allies", "Weapons", "Projectiles", "Loot Crates", "Other Entities" };

        for (std::size_t i = 0; i < categories.size(); ++i) {
            if (ImGui::Selectable(categories[i], currentCategory == i && std::string_view{ currentItem } == "All")) {
                currentCategory = i;
                currentItem = "All";
            }

            if (ImGui::BeginDragDropSource()) {
                switch (i) {
                case 0: case 1: ImGui::SetDragDropPayload("Player", &getConfigPlayer(i, "All"), sizeof(Player), ImGuiCond_Once); break;
                case 2: ImGui::SetDragDropPayload("Weapon", &config->streamProofESP.weapons["All"], sizeof(Weapon), ImGuiCond_Once); break;
                case 3: ImGui::SetDragDropPayload("Projectile", &config->streamProofESP.projectiles["All"], sizeof(Projectile), ImGuiCond_Once); break;
                default: ImGui::SetDragDropPayload("Entity", &getConfigShared(i, "All"), sizeof(Shared), ImGuiCond_Once); break;
                }
                ImGui::EndDragDropSource();
            }

            if (ImGui::BeginDragDropTarget()) {
                if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Player")) {
                    const auto& data = *(Player*)payload->Data;

                    switch (i) {
                    case 0: case 1: getConfigPlayer(i, "All") = data; break;
                    case 2: config->streamProofESP.weapons["All"] = data; break;
                    case 3: config->streamProofESP.projectiles["All"] = data; break;
                    default: getConfigShared(i, "All") = data; break;
                    }
                }

                if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Weapon")) {
                    const auto& data = *(Weapon*)payload->Data;

                    switch (i) {
                    case 0: case 1: getConfigPlayer(i, "All") = data; break;
                    case 2: config->streamProofESP.weapons["All"] = data; break;
                    case 3: config->streamProofESP.projectiles["All"] = data; break;
                    default: getConfigShared(i, "All") = data; break;
                    }
                }

                if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Projectile")) {
                    const auto& data = *(Projectile*)payload->Data;

                    switch (i) {
                    case 0: case 1: getConfigPlayer(i, "All") = data; break;
                    case 2: config->streamProofESP.weapons["All"] = data; break;
                    case 3: config->streamProofESP.projectiles["All"] = data; break;
                    default: getConfigShared(i, "All") = data; break;
                    }
                }

                if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Entity")) {
                    const auto& data = *(Shared*)payload->Data;

                    switch (i) {
                    case 0: case 1: getConfigPlayer(i, "All") = data; break;
                    case 2: config->streamProofESP.weapons["All"] = data; break;
                    case 3: config->streamProofESP.projectiles["All"] = data; break;
                    default: getConfigShared(i, "All") = data; break;
                    }
                }
                ImGui::EndDragDropTarget();
            }

            ImGui::PushID(i);
            ImGui::Indent();

            const auto items = [](std::size_t category) noexcept -> std::vector<const char*> {
                switch (category) {
                case 0:
                case 1: return { "Visible", "Occluded" };
                case 2: return { "Pistols", "SMGs", "Rifles", "Sniper Rifles", "Shotguns", "Machineguns", "Grenades", "Melee", "Other" };
                case 3: return { "Flashbang", "HE Grenade", "Breach Charge", "Bump Mine", "Decoy Grenade", "Molotov", "TA Grenade", "Smoke Grenade", "Snowball" };
                case 4: return { "Pistol Case", "Light Case", "Heavy Case", "Explosive Case", "Tools Case", "Cash Dufflebag" };
                case 5: return { "Defuse Kit", "Chicken", "Planted C4", "Hostage", "Sentry", "Cash", "Ammo Box", "Radar Jammer", "Snowball Pile" };
                default: return { };
                }
            }(i);

            const auto categoryEnabled = getConfigShared(i, "All").enabled;

            for (std::size_t j = 0; j < items.size(); ++j) {
                static bool selectedSubItem;
                if (!categoryEnabled || getConfigShared(i, items[j]).enabled) {
                    if (ImGui::Selectable(items[j], currentCategory == i && !selectedSubItem && std::string_view{ currentItem } == items[j])) {
                        currentCategory = i;
                        currentItem = items[j];
                        selectedSubItem = false;
                    }

                    if (ImGui::BeginDragDropSource()) {
                        switch (i) {
                        case 0: case 1: ImGui::SetDragDropPayload("Player", &getConfigPlayer(i, items[j]), sizeof(Player), ImGuiCond_Once); break;
                        case 2: ImGui::SetDragDropPayload("Weapon", &config->streamProofESP.weapons[items[j]], sizeof(Weapon), ImGuiCond_Once); break;
                        case 3: ImGui::SetDragDropPayload("Projectile", &config->streamProofESP.projectiles[items[j]], sizeof(Projectile), ImGuiCond_Once); break;
                        default: ImGui::SetDragDropPayload("Entity", &getConfigShared(i, items[j]), sizeof(Shared), ImGuiCond_Once); break;
                        }
                        ImGui::EndDragDropSource();
                    }

                    if (ImGui::BeginDragDropTarget()) {
                        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Player")) {
                            const auto& data = *(Player*)payload->Data;

                            switch (i) {
                            case 0: case 1: getConfigPlayer(i, items[j]) = data; break;
                            case 2: config->streamProofESP.weapons[items[j]] = data; break;
                            case 3: config->streamProofESP.projectiles[items[j]] = data; break;
                            default: getConfigShared(i, items[j]) = data; break;
                            }
                        }

                        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Weapon")) {
                            const auto& data = *(Weapon*)payload->Data;

                            switch (i) {
                            case 0: case 1: getConfigPlayer(i, items[j]) = data; break;
                            case 2: config->streamProofESP.weapons[items[j]] = data; break;
                            case 3: config->streamProofESP.projectiles[items[j]] = data; break;
                            default: getConfigShared(i, items[j]) = data; break;
                            }
                        }

                        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Projectile")) {
                            const auto& data = *(Projectile*)payload->Data;

                            switch (i) {
                            case 0: case 1: getConfigPlayer(i, items[j]) = data; break;
                            case 2: config->streamProofESP.weapons[items[j]] = data; break;
                            case 3: config->streamProofESP.projectiles[items[j]] = data; break;
                            default: getConfigShared(i, items[j]) = data; break;
                            }
                        }

                        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Entity")) {
                            const auto& data = *(Shared*)payload->Data;

                            switch (i) {
                            case 0: case 1: getConfigPlayer(i, items[j]) = data; break;
                            case 2: config->streamProofESP.weapons[items[j]] = data; break;
                            case 3: config->streamProofESP.projectiles[items[j]] = data; break;
                            default: getConfigShared(i, items[j]) = data; break;
                            }
                        }
                        ImGui::EndDragDropTarget();
                    }
                }

                if (i != 2)
                    continue;

                ImGui::Indent();

                const auto subItems = [](std::size_t item) noexcept -> std::vector<const char*> {
                    switch (item) {
                    case 0: return { "Glock-18", "P2000", "USP-S", "Dual Berettas", "P250", "Tec-9", "Five-SeveN", "CZ75-Auto", "Desert Eagle", "R8 Revolver" };
                    case 1: return { "MAC-10", "MP9", "MP7", "MP5-SD", "UMP-45", "P90", "PP-Bizon" };
                    case 2: return { "Galil AR", "FAMAS", "AK-47", "M4A4", "M4A1-S", "SG 553", "AUG" };
                    case 3: return { "SSG 08", "AWP", "G3SG1", "SCAR-20" };
                    case 4: return { "Nova", "XM1014", "Sawed-Off", "MAG-7" };
                    case 5: return { "M249", "Negev" };
                    case 6: return { "Flashbang", "HE Grenade", "Smoke Grenade", "Molotov", "Decoy Grenade", "Incendiary", "TA Grenade", "Fire Bomb", "Diversion", "Frag Grenade", "Snowball" };
                    case 7: return { "Axe", "Hammer", "Wrench" };
                    case 8: return { "C4", "Healthshot", "Bump Mine", "Zone Repulsor", "Shield" };
                    default: return { };
                    }
                }(j);

                const auto itemEnabled = getConfigShared(i, items[j]).enabled;

                for (const auto subItem : subItems) {
                    auto& subItemConfig = config->streamProofESP.weapons[subItem];
                    if ((categoryEnabled || itemEnabled) && !subItemConfig.enabled)
                        continue;

                    if (ImGui::Selectable(subItem, currentCategory == i && selectedSubItem && std::string_view{ currentItem } == subItem)) {
                        currentCategory = i;
                        currentItem = subItem;
                        selectedSubItem = true;
                    }

                    if (ImGui::BeginDragDropSource()) {
                        ImGui::SetDragDropPayload("Weapon", &subItemConfig, sizeof(Weapon), ImGuiCond_Once);
                        ImGui::EndDragDropSource();
                    }

                    if (ImGui::BeginDragDropTarget()) {
                        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Player")) {
                            const auto& data = *(Player*)payload->Data;
                            subItemConfig = data;
                        }

                        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Weapon")) {
                            const auto& data = *(Weapon*)payload->Data;
                            subItemConfig = data;
                        }

                        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Projectile")) {
                            const auto& data = *(Projectile*)payload->Data;
                            subItemConfig = data;
                        }

                        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Entity")) {
                            const auto& data = *(Shared*)payload->Data;
                            subItemConfig = data;
                        }
                        ImGui::EndDragDropTarget();
                    }
                }

                ImGui::Unindent();
            }
            ImGui::Unindent();
            ImGui::PopID();
        }
        ImGui::ListBoxFooter();
    }

    ImGui::SameLine();

    if (ImGui::BeginChild("##child", { 400.0f, 0.0f })) {
        auto& sharedConfig = getConfigShared(currentCategory, currentItem);

        ImGui::Checkbox("Enabled", &sharedConfig.enabled);
        ImGui::SameLine(ImGui::GetWindowContentRegionMax().x - 260.0f);
        ImGui::SetNextItemWidth(220.0f);
        if (ImGui::BeginCombo("Font", config->systemFonts[sharedConfig.font.index].c_str())) {
            for (size_t i = 0; i < config->systemFonts.size(); i++) {
                bool isSelected = config->systemFonts[i] == sharedConfig.font.name;
                if (ImGui::Selectable(config->systemFonts[i].c_str(), isSelected, 0, { 250.0f, 0.0f })) {
                    sharedConfig.font.index = i;
                    sharedConfig.font.name = config->systemFonts[i];
                    config->scheduleFontLoad(sharedConfig.font.name);
                }
                if (isSelected)
                    ImGui::SetItemDefaultFocus();
            }
            ImGui::EndCombo();
        }

        ImGui::Separator();

        constexpr auto spacing = 250.0f;
        ImGuiCustom::colorPicker("Snapline", sharedConfig.snapline);
        ImGui::SameLine();
        ImGui::SetNextItemWidth(90.0f);
        ImGui::Combo("##1", &sharedConfig.snapline.type, "Bottom\0Top\0Crosshair\0");
        ImGui::SameLine(spacing);
        ImGuiCustom::colorPicker("Box", sharedConfig.box);
        ImGui::SameLine();

        ImGui::PushID("Box");

        if (ImGui::Button("..."))
            ImGui::OpenPopup("");

        if (ImGui::BeginPopup("")) {
            ImGui::SetNextItemWidth(95.0f);
            ImGui::Combo("Type", &sharedConfig.box.type, "2D\0" "2D corners\0" "3D\0" "3D corners\0");
            ImGui::SetNextItemWidth(275.0f);
            ImGui::SliderFloat3("Scale", sharedConfig.box.scale.data(), 0.0f, 0.50f, "%.2f");
            ImGui::EndPopup();
        }

        ImGui::PopID();

        ImGuiCustom::colorPicker("Name", sharedConfig.name);
        ImGui::SameLine(spacing);

        if (currentCategory < 2) {
            auto& playerConfig = getConfigPlayer(currentCategory, currentItem);

            ImGuiCustom::colorPicker("Weapon", playerConfig.weapon);
            ImGuiCustom::colorPicker("Flash Duration", playerConfig.flashDuration);
            ImGui::SameLine(spacing);
            ImGuiCustom::colorPicker("Skeleton", playerConfig.skeleton);
            ImGui::Checkbox("Audible Only", &playerConfig.audibleOnly);
            ImGui::SameLine(spacing);
            ImGui::Checkbox("Spotted Only", &playerConfig.spottedOnly);
        } else if (currentCategory == 2) {
            auto& weaponConfig = config->streamProofESP.weapons[currentItem];
            ImGuiCustom::colorPicker("Ammo", weaponConfig.ammo);
        } else if (currentCategory == 3) {
            auto& trails = config->streamProofESP.projectiles[currentItem].trails;

            ImGui::Checkbox("Trails", &trails.enabled);
            ImGui::SameLine(spacing + 77.0f);
            ImGui::PushID("Trails");

            if (ImGui::Button("..."))
                ImGui::OpenPopup("");

            if (ImGui::BeginPopup("")) {
                constexpr auto trailPicker = [](const char* name, Trail& trail) noexcept {
                    ImGui::PushID(name);
                    ImGuiCustom::colorPicker(name, trail);
                    ImGui::SameLine(150.0f);
                    ImGui::SetNextItemWidth(95.0f);
                    ImGui::Combo("", &trail.type, "Line\0Circles\0Filled Circles\0");
                    ImGui::SameLine();
                    ImGui::SetNextItemWidth(95.0f);
                    ImGui::InputFloat("Time", &trail.time, 0.1f, 0.5f, "%.1fs");
                    trail.time = std::clamp(trail.time, 1.0f, 60.0f);
                    ImGui::PopID();
                };

                trailPicker("Local Player", trails.localPlayer);
                trailPicker("Allies", trails.allies);
                trailPicker("Enemies", trails.enemies);
                ImGui::EndPopup();
            }

            ImGui::PopID();
        }

        ImGui::SetNextItemWidth(95.0f);
        ImGui::InputFloat("Text Cull Distance", &sharedConfig.textCullDistance, 0.4f, 0.8f, "%.1fm");
        sharedConfig.textCullDistance = std::clamp(sharedConfig.textCullDistance, 0.0f, 999.9f);
    }

    ImGui::EndChild();

    if (!contentOnly)
        ImGui::End();
}

void GUI::renderVisualsWindow(bool contentOnly) noexcept
{
    if (!contentOnly) {
        if (!window.visuals)
            return;
        ImGui::SetNextWindowSize({ 680.0f, 0.0f });
        ImGui::Begin("Visuals", &window.visuals, windowFlags);
    }
    ImGui::Columns(2, nullptr, false);
    ImGui::SetColumnOffset(1, 280.0f);
    constexpr auto playerModels = "Default\0Special Agent Ava | FBI\0Operator | FBI SWAT\0Markus Delrow | FBI HRT\0Michael Syfers | FBI Sniper\0B Squadron Officer | SAS\0Seal Team 6 Soldier | NSWC SEAL\0Buckshot | NSWC SEAL\0Lt. Commander Ricksaw | NSWC SEAL\0Third Commando Company | KSK\0'Two Times' McCoy | USAF TACP\0Dragomir | Sabre\0Rezan The Ready | Sabre\0'The Doctor' Romanov | Sabre\0Maximus | Sabre\0Blackwolf | Sabre\0The Elite Mr. Muhlik | Elite Crew\0Ground Rebel | Elite Crew\0Osiris | Elite Crew\0Prof. Shahmat | Elite Crew\0Enforcer | Phoenix\0Slingshot | Phoenix\0Soldier | Phoenix\0Pirate\0Pirate Variant A\0Pirate Variant B\0Pirate Variant C\0Pirate Variant D\0Anarchist\0Anarchist Variant A\0Anarchist Variant B\0Anarchist Variant C\0Anarchist Variant D\0Balkan Variant A\0Balkan Variant B\0Balkan Variant C\0Balkan Variant D\0Balkan Variant E\0Jumpsuit Variant A\0Jumpsuit Variant B\0Jumpsuit Variant C\0";
    ImGui::Combo("T Player Model", &config->visuals.playerModelT, playerModels);
    ImGui::Combo("CT Player Model", &config->visuals.playerModelCT, playerModels);
    ImGui::Checkbox("Disable post-processing", &config->visuals.disablePostProcessing);
    ImGui::Checkbox("Inverse ragdoll gravity", &config->visuals.inverseRagdollGravity);
    ImGui::Checkbox("No fog", &config->visuals.noFog);
    ImGui::Checkbox("No 3d sky", &config->visuals.no3dSky);
    ImGui::Checkbox("No aim punch", &config->visuals.noAimPunch);
    ImGui::Checkbox("No view punch", &config->visuals.noViewPunch);
    ImGui::Checkbox("No hands", &config->visuals.noHands);
    ImGui::Checkbox("No sleeves", &config->visuals.noSleeves);
    ImGui::Checkbox("No weapons", &config->visuals.noWeapons);
    ImGui::Checkbox("No smoke", &config->visuals.noSmoke);
    ImGui::Checkbox("No blur", &config->visuals.noBlur);
    ImGui::Checkbox("No scope overlay", &config->visuals.noScopeOverlay);
    ImGui::Checkbox("No grass", &config->visuals.noGrass);
    ImGui::Checkbox("No shadows", &config->visuals.noShadows);
    ImGui::Checkbox("Wireframe smoke", &config->visuals.wireframeSmoke);
    ImGui::NextColumn();
    ImGui::Checkbox("Zoom", &config->visuals.zoom);
    ImGui::SameLine();
    hotkey(config->visuals.zoomKey);
    ImGui::Checkbox("Thirdperson", &config->visuals.thirdperson);
    ImGui::SameLine();
    hotkey(config->visuals.thirdpersonKey);
    ImGui::PushItemWidth(290.0f);
    ImGui::PushID(0);
    ImGui::SliderInt("", &config->visuals.thirdpersonDistance, 0, 1000, "Thirdperson distance: %d");
    ImGui::PopID();
    ImGui::PushID(1);
    ImGui::SliderInt("", &config->visuals.viewmodelFov, -60, 60, "Viewmodel FOV: %d");
    ImGui::PopID();
    ImGui::PushID(2);
    ImGui::SliderInt("", &config->visuals.fov, -60, 60, "FOV: %d");
    ImGui::PopID();
    ImGui::PushID(3);
    ImGui::SliderInt("", &config->visuals.farZ, 0, 2000, "Far Z: %d");
    ImGui::PopID();
    ImGui::PushID(4);
    ImGui::SliderInt("", &config->visuals.flashReduction, 0, 100, "Flash reduction: %d%%");
    ImGui::PopID();
    ImGui::PushID(5);
    ImGui::SliderFloat("", &config->visuals.brightness, 0.0f, 1.0f, "Brightness: %.2f");
    ImGui::PopID();
    ImGui::PopItemWidth();
    ImGui::Combo("Skybox", &config->visuals.skybox, "Default\0cs_baggage_skybox_\0cs_tibet\0embassy\0italy\0jungle\0nukeblank\0office\0sky_cs15_daylight01_hdr\0sky_cs15_daylight02_hdr\0sky_cs15_daylight03_hdr\0sky_cs15_daylight04_hdr\0sky_csgo_cloudy01\0sky_csgo_night_flat\0sky_csgo_night02\0sky_day02_05_hdr\0sky_day02_05\0sky_dust\0sky_l4d_rural02_ldr\0sky_venice\0vertigo_hdr\0vertigo\0vertigoblue_hdr\0vietnam\0");
    ImGuiCustom::colorPicker("World color", config->visuals.world);
    ImGuiCustom::colorPicker("Sky color", config->visuals.sky);
    ImGui::Checkbox("Deagle spinner", &config->visuals.deagleSpinner);
    ImGui::Combo("Screen effect", &config->visuals.screenEffect, "None\0Drone cam\0Drone cam with noise\0Underwater\0Healthboost\0Dangerzone\0");
    ImGui::Combo("Hit effect", &config->visuals.hitEffect, "None\0Drone cam\0Drone cam with noise\0Underwater\0Healthboost\0Dangerzone\0");
    ImGui::SliderFloat("Hit effect time", &config->visuals.hitEffectTime, 0.1f, 1.5f, "%.2fs");
    ImGui::Combo("Hit marker", &config->visuals.hitMarker, "None\0Default (Cross)\0");
    ImGui::SliderFloat("Hit marker time", &config->visuals.hitMarkerTime, 0.1f, 1.5f, "%.2fs");
    ImGui::Checkbox("Color correction", &config->visuals.colorCorrection.enabled);
    ImGui::SameLine();
    bool ccPopup = ImGui::Button("Edit");

    if (ccPopup)
        ImGui::OpenPopup("##popup");

    if (ImGui::BeginPopup("##popup")) {
        ImGui::VSliderFloat("##1", { 40.0f, 160.0f }, &config->visuals.colorCorrection.blue, 0.0f, 1.0f, "Blue\n%.3f"); ImGui::SameLine();
        ImGui::VSliderFloat("##2", { 40.0f, 160.0f }, &config->visuals.colorCorrection.red, 0.0f, 1.0f, "Red\n%.3f"); ImGui::SameLine();
        ImGui::VSliderFloat("##3", { 40.0f, 160.0f }, &config->visuals.colorCorrection.mono, 0.0f, 1.0f, "Mono\n%.3f"); ImGui::SameLine();
        ImGui::VSliderFloat("##4", { 40.0f, 160.0f }, &config->visuals.colorCorrection.saturation, 0.0f, 1.0f, "Sat\n%.3f"); ImGui::SameLine();
        ImGui::VSliderFloat("##5", { 40.0f, 160.0f }, &config->visuals.colorCorrection.ghost, 0.0f, 1.0f, "Ghost\n%.3f"); ImGui::SameLine();
        ImGui::VSliderFloat("##6", { 40.0f, 160.0f }, &config->visuals.colorCorrection.green, 0.0f, 1.0f, "Green\n%.3f"); ImGui::SameLine();
        ImGui::VSliderFloat("##7", { 40.0f, 160.0f }, &config->visuals.colorCorrection.yellow, 0.0f, 1.0f, "Yellow\n%.3f"); ImGui::SameLine();
        ImGui::EndPopup();
    }
    ImGui::Columns(1);

    if (!contentOnly)
        ImGui::End();
}

void GUI::renderSkinChangerWindow(bool contentOnly) noexcept
{
    if (!contentOnly) {
        if (!window.skinChanger)
            return;
        ImGui::SetNextWindowSize({ 700.0f, 0.0f });
        ImGui::Begin("nSkinz", &window.skinChanger, windowFlags);
    }

    static auto itemIndex = 0;

    ImGui::PushItemWidth(110.0f);
    ImGui::Combo("##1", &itemIndex, [](void* data, int idx, const char** out_text) {
        *out_text = game_data::weapon_names[idx].name;
        return true;
        }, nullptr, IM_ARRAYSIZE(game_data::weapon_names), 5);
    ImGui::PopItemWidth();

    auto& selected_entry = config->skinChanger[itemIndex];
    selected_entry.itemIdIndex = itemIndex;

    {
        ImGui::SameLine();
        ImGui::Checkbox("Enabled", &selected_entry.enabled);
        ImGui::Separator();
        ImGui::Columns(2, nullptr, false);
        ImGui::InputInt("Seed", &selected_entry.seed);
        ImGui::InputInt("StatTrak\u2122", &selected_entry.stat_trak);
        selected_entry.stat_trak = (std::max)(selected_entry.stat_trak, -1);
        ImGui::SliderFloat("Wear", &selected_entry.wear, FLT_MIN, 1.f, "%.10f", 5);

        ImGui::Combo("Paint Kit", &selected_entry.paint_kit_vector_index, [](void* data, int idx, const char** out_text) {
            *out_text = (itemIndex == 1 ? SkinChanger::gloveKits : SkinChanger::skinKits)[idx].name.c_str();
            return true;
            }, nullptr, (itemIndex == 1 ? SkinChanger::gloveKits : SkinChanger::skinKits).size(), 10);

        ImGui::Combo("Quality", &selected_entry.entity_quality_vector_index, [](void* data, int idx, const char** out_text) {
            *out_text = game_data::quality_names[idx].name;
            return true;
            }, nullptr, IM_ARRAYSIZE(game_data::quality_names), 5);

        if (itemIndex == 0) {
            ImGui::Combo("Knife", &selected_entry.definition_override_vector_index, [](void* data, int idx, const char** out_text) {
                *out_text = game_data::knife_names[idx].name;
                return true;
                }, nullptr, IM_ARRAYSIZE(game_data::knife_names), 5);
        } else if (itemIndex == 1) {
            ImGui::Combo("Glove", &selected_entry.definition_override_vector_index, [](void* data, int idx, const char** out_text) {
                *out_text = game_data::glove_names[idx].name;
                return true;
                }, nullptr, IM_ARRAYSIZE(game_data::glove_names), 5);
        } else {
            static auto unused_value = 0;
            selected_entry.definition_override_vector_index = 0;
            ImGui::Combo("Unavailable", &unused_value, "For knives or gloves\0");
        }

        ImGui::InputText("Name Tag", selected_entry.custom_name, 32);
    }

    ImGui::NextColumn();

    {
        ImGui::PushID("sticker");

        static auto selectedStickerSlot = 0;

        ImGui::PushItemWidth(-1);

        if (ImGui::ListBoxHeader("", 5)) {
            for (int i = 0; i < 5; ++i) {
                ImGui::PushID(i);

                const auto kit_vector_index = config->skinChanger[itemIndex].stickers[i].kit_vector_index;
                const std::string text = '#' + std::to_string(i + 1) + "  " + SkinChanger::stickerKits[kit_vector_index].name;

                if (ImGui::Selectable(text.c_str(), i == selectedStickerSlot))
                    selectedStickerSlot = i;

                ImGui::PopID();
            }
            ImGui::ListBoxFooter();
        }

        ImGui::PopItemWidth();

        auto& selected_sticker = selected_entry.stickers[selectedStickerSlot];

        ImGui::Combo("Sticker Kit", &selected_sticker.kit_vector_index, [](void* data, int idx, const char** out_text) {
            *out_text = SkinChanger::stickerKits[idx].name.c_str();
            return true;
            }, nullptr, SkinChanger::stickerKits.size(), 10);

        ImGui::SliderFloat("Wear", &selected_sticker.wear, FLT_MIN, 1.0f, "%.10f", 5.0f);
        ImGui::SliderFloat("Scale", &selected_sticker.scale, 0.1f, 5.0f);
        ImGui::SliderFloat("Rotation", &selected_sticker.rotation, 0.0f, 360.0f);

        ImGui::PopID();
    }
    selected_entry.update();

    ImGui::Columns(1);

    ImGui::Separator();

    if (ImGui::Button("Update", { 130.0f, 30.0f }))
        SkinChanger::scheduleHudUpdate();

    ImGui::TextUnformatted("nSkinz by namazso");

    if (!contentOnly)
        ImGui::End();
}

void GUI::renderSoundWindow(bool contentOnly) noexcept
{
    if (!contentOnly) {
        if (!window.sound)
            return;
        ImGui::SetNextWindowSize({ 0.0f, 0.0f });
        ImGui::Begin("Sound", &window.sound, windowFlags);
    }
    ImGui::SliderInt("Chicken volume", &config->sound.chickenVolume, 0, 200, "%d%%");

    static int currentCategory{ 0 };
    ImGui::PushItemWidth(110.0f);
    ImGui::Combo("", &currentCategory, "Local player\0Allies\0Enemies\0");
    ImGui::PopItemWidth();
    ImGui::SliderInt("Master volume", &config->sound.players[currentCategory].masterVolume, 0, 200, "%d%%");
    ImGui::SliderInt("Headshot volume", &config->sound.players[currentCategory].headshotVolume, 0, 200, "%d%%");
    ImGui::SliderInt("Weapon volume", &config->sound.players[currentCategory].weaponVolume, 0, 200, "%d%%");
    ImGui::SliderInt("Footstep volume", &config->sound.players[currentCategory].footstepVolume, 0, 200, "%d%%");

    if (!contentOnly)
        ImGui::End();
}

void GUI::renderStyleWindow(bool contentOnly) noexcept
{
    if (!contentOnly) {
        if (!window.style)
            return;
        ImGui::SetNextWindowSize({ 0.0f, 0.0f });
        ImGui::Begin("Style", &window.style, windowFlags);
    }

    ImGui::PushItemWidth(150.0f);
    if (ImGui::Combo("Menu style", &config->style.menuStyle, "Classic\0One window\0"))
        window = { };
    if (ImGui::Combo("Menu colors", &config->style.menuColors, "Dark\0Light\0Classic\0Custom\0"))
        updateColors();
    ImGui::PopItemWidth();

    if (config->style.menuColors == 3) {
        ImGuiStyle& style = ImGui::GetStyle();
        for (int i = 0; i < ImGuiCol_COUNT; i++) {
            if (i && i & 3) ImGui::SameLine(220.0f * (i & 3));

            ImGuiCustom::colorPicker(ImGui::GetStyleColorName(i), (float*)&style.Colors[i]);
        }
    }

    if (!contentOnly)
        ImGui::End();
}

void GUI::renderMiscWindow(bool contentOnly) noexcept
{
    if (!contentOnly) {
        if (!window.misc)
            return;
        ImGui::SetNextWindowSize({ 580.0f, 0.0f });
        ImGui::Begin("Misc", &window.misc, windowFlags);
    }
    ImGui::Columns(2, nullptr, false);
    ImGui::SetColumnOffset(1, 230.0f);
    ImGui::TextUnformatted("Menu key");
    ImGui::SameLine();
    hotkey(config->misc.menuKey);

    ImGui::Checkbox("Anti AFK kick", &config->misc.antiAfkKick);
    ImGui::Checkbox("Auto strafe", &config->misc.autoStrafe);
    ImGui::Checkbox("Bunny hop", &config->misc.bunnyHop);
    ImGui::Checkbox("Fast duck", &config->misc.fastDuck);
    ImGui::Checkbox("Moonwalk", &config->misc.moonwalk);
    ImGui::Checkbox("Edge Jump", &config->misc.edgejump);
    ImGui::SameLine();
    hotkey(config->misc.edgejumpkey);
    ImGui::Checkbox("Slowwalk", &config->misc.slowwalk);
    ImGui::SameLine();
    hotkey(config->misc.slowwalkKey);
    ImGui::Checkbox("Sniper crosshair", &config->misc.sniperCrosshair);
    ImGui::Checkbox("Recoil crosshair", &config->misc.recoilCrosshair);
    ImGui::Checkbox("Auto pistol", &config->misc.autoPistol);
    ImGui::Checkbox("Auto reload", &config->misc.autoReload);
    ImGui::Checkbox("Auto accept", &config->misc.autoAccept);
    ImGui::Checkbox("Radar hack", &config->misc.radarHack);
    ImGui::Checkbox("Reveal ranks", &config->misc.revealRanks);
    ImGui::Checkbox("Reveal money", &config->misc.revealMoney);
    ImGui::Checkbox("Reveal suspect", &config->misc.revealSuspect);
    ImGuiCustom::colorPicker("Spectator list", config->misc.spectatorList);
    ImGuiCustom::colorPicker("Watermark", config->misc.watermark);
    ImGui::Checkbox("Fix animation LOD", &config->misc.fixAnimationLOD);
    ImGui::Checkbox("Fix bone matrix", &config->misc.fixBoneMatrix);
    ImGui::Checkbox("Fix movement", &config->misc.fixMovement);
    ImGui::Checkbox("Disable model occlusion", &config->misc.disableModelOcclusion);
    ImGui::SliderFloat("Aspect Ratio", &config->misc.aspectratio, 0.0f, 5.0f, "%.2f");
    ImGui::NextColumn();
    ImGui::Checkbox("Disable HUD blur", &config->misc.disablePanoramablur);
    ImGui::Checkbox("Animated clan tag", &config->misc.animatedClanTag);
    ImGui::Checkbox("Clock tag", &config->misc.clocktag);
    ImGui::Checkbox("Custom clantag", &config->misc.customClanTag);
    ImGui::SameLine();
    ImGui::PushItemWidth(120.0f);
    ImGui::PushID(0);

    if (ImGui::InputText("", config->misc.clanTag, sizeof(config->misc.clanTag)))
        Misc::updateClanTag(true);
    ImGui::PopID();
    ImGui::Checkbox("Kill message", &config->misc.killMessage);
    ImGui::SameLine();
    ImGui::PushItemWidth(120.0f);
    ImGui::PushID(1);
    ImGui::InputText("", &config->misc.killMessageString);
    ImGui::PopID();
    ImGui::Checkbox("Name stealer", &config->misc.nameStealer);
    ImGui::PushID(3);
    ImGui::SetNextItemWidth(100.0f);
    ImGui::Combo("", &config->misc.banColor, "White\0Red\0Purple\0Green\0Light green\0Turquoise\0Light red\0Gray\0Yellow\0Gray 2\0Light blue\0Gray/Purple\0Blue\0Pink\0Dark orange\0Orange\0");
    ImGui::PopID();
    ImGui::SameLine();
    ImGui::PushID(4);
    ImGui::InputText("", &config->misc.banText);
    ImGui::PopID();
    ImGui::SameLine();
    if (ImGui::Button("Setup fake ban"))
        Misc::fakeBan(true);
    ImGui::Checkbox("Fast plant", &config->misc.fastPlant);
    ImGuiCustom::colorPicker("Bomb timer", config->misc.bombTimer);
    ImGui::Checkbox("Quick reload", &config->misc.quickReload);
    ImGui::Checkbox("Prepare revolver", &config->misc.prepareRevolver);
    ImGui::SameLine();
    hotkey(config->misc.prepareRevolverKey);
    ImGui::Combo("Hit Sound", &config->misc.hitSound, "None\0Metal\0Gamesense\0Bell\0Glass\0Custom\0");
    if (config->misc.hitSound == 5) {
        ImGui::InputText("Hit Sound filename", &config->misc.customHitSound);
        if (ImGui::IsItemHovered())
            ImGui::SetTooltip("audio file must be put in csgo/sound/ directory");
    }
    ImGui::PushID(5);
    ImGui::Combo("Kill Sound", &config->misc.killSound, "None\0Metal\0Gamesense\0Bell\0Glass\0Custom\0");
    if (config->misc.killSound == 5) {
        ImGui::InputText("Kill Sound filename", &config->misc.customKillSound);
        if (ImGui::IsItemHovered())
            ImGui::SetTooltip("audio file must be put in csgo/sound/ directory");
    }
    ImGui::PopID();
    ImGui::SetNextItemWidth(90.0f);
    ImGui::InputInt("Choked packets", &config->misc.chokedPackets, 1, 5);
    config->misc.chokedPackets = std::clamp(config->misc.chokedPackets, 0, 64);
    ImGui::SameLine();
    hotkey(config->misc.chokedPacketsKey);
    ImGui::Text("Quick healthshot");
    ImGui::SameLine();
    hotkey(config->misc.quickHealthshotKey);
    ImGui::Checkbox("Grenade Prediction", &config->misc.nadePredict);
    ImGui::Checkbox("Fix tablet signal", &config->misc.fixTabletSignal);
    ImGui::SetNextItemWidth(120.0f);
    ImGui::SliderFloat("Max angle delta", &config->misc.maxAngleDelta, 0.0f, 255.0f, "%.2f");
    ImGui::Checkbox("Fake prime", &config->misc.fakePrime);
    ImGui::Checkbox("Purchase List", &config->misc.purchaseList.enabled);
    ImGui::SameLine();

    ImGui::PushID("Purchase List");
    if (ImGui::Button("..."))
        ImGui::OpenPopup("");

    if (ImGui::BeginPopup("")) {
        ImGui::SetNextItemWidth(75.0f);
        ImGui::Combo("Mode", &config->misc.purchaseList.mode, "Details\0Summary\0");
        ImGui::Checkbox("Only During Freeze Time", &config->misc.purchaseList.onlyDuringFreezeTime);
        ImGui::Checkbox("Show Prices", &config->misc.purchaseList.showPrices);
        ImGui::Checkbox("No Title Bar", &config->misc.purchaseList.noTitleBar);
        ImGui::EndPopup();
    }
    ImGui::PopID();

    if (ImGui::Button("Unhook"))
        hooks->uninstall();

    ImGui::Columns(1);
    if (!contentOnly)
        ImGui::End();
}

void GUI::renderReportbotWindow(bool contentOnly) noexcept
{
    if (!contentOnly) {
        if (!window.reportbot)
            return;
        ImGui::SetNextWindowSize({ 0.0f, 0.0f });
        ImGui::Begin("Reportbot", &window.reportbot, windowFlags);
    }
    ImGui::Checkbox("Enabled", &config->reportbot.enabled);
    ImGui::SameLine(0.0f, 50.0f);
    if (ImGui::Button("Reset"))
        Reportbot::reset();
    ImGui::Separator();
    ImGui::PushItemWidth(80.0f);
    ImGui::Combo("Target", &config->reportbot.target, "Enemies\0Allies\0All\0");
    ImGui::InputInt("Delay (s)", &config->reportbot.delay);
    config->reportbot.delay = (std::max)(config->reportbot.delay, 1);
    ImGui::InputInt("Rounds", &config->reportbot.rounds);
    config->reportbot.rounds = (std::max)(config->reportbot.rounds, 1);
    ImGui::PopItemWidth();
    ImGui::Checkbox("Abusive Communications", &config->reportbot.textAbuse);
    ImGui::Checkbox("Griefing", &config->reportbot.griefing);
    ImGui::Checkbox("Wall Hacking", &config->reportbot.wallhack);
    ImGui::Checkbox("Aim Hacking", &config->reportbot.aimbot);
    ImGui::Checkbox("Other Hacking", &config->reportbot.other);

    if (!contentOnly)
        ImGui::End();
}

void GUI::renderConfigWindow(bool contentOnly) noexcept
{
    if (!contentOnly) {
        if (!window.config)
            return;
        ImGui::SetNextWindowSize({ 290.0f, 200.0f });
        ImGui::Begin("Config", &window.config, windowFlags);
    }

    ImGui::Columns(2, nullptr, false);
    ImGui::SetColumnOffset(1, 170.0f);

    ImGui::PushItemWidth(160.0f);

    if (ImGui::Button("Reload configs", { 160.0f, 25.0f }))
        config->listConfigs();

    auto& configItems = config->getConfigs();
    static int currentConfig = -1;

    if (static_cast<std::size_t>(currentConfig) >= configItems.size())
        currentConfig = -1;

    static std::string buffer;

    if (ImGui::ListBox("", &currentConfig, [](void* data, int idx, const char** out_text) {
        auto& vector = *static_cast<std::vector<std::string>*>(data);
        *out_text = vector[idx].c_str();
        return true;
        }, &configItems, configItems.size(), 5) && currentConfig != -1)
            buffer = configItems[currentConfig];

        ImGui::PushID(0);
        if (ImGui::InputTextWithHint("", "config name", &buffer, ImGuiInputTextFlags_EnterReturnsTrue)) {
            if (currentConfig != -1)
                config->rename(currentConfig, buffer.c_str());
        }
        ImGui::PopID();
        ImGui::NextColumn();

        ImGui::PushItemWidth(100.0f);

        if (ImGui::Button("Create config", { 100.0f, 25.0f }))
            config->add(buffer.c_str());

        if (ImGui::Button("Reset config", { 100.0f, 25.0f }))
            ImGui::OpenPopup("Config to reset");

        if (ImGui::BeginPopup("Config to reset")) {
            static constexpr const char* names[]{ "Whole", "Aimbot", "Triggerbot", "Backtrack", "Anti aim", "Glow", "Chams", "Esp", "Visuals", "Skin changer", "Sound", "Style", "Misc", "Reportbot" };
            for (int i = 0; i < IM_ARRAYSIZE(names); i++) {
                if (i == 1) ImGui::Separator();

                if (ImGui::Selectable(names[i])) {
                    switch (i) {
                    case 0: config->reset(); updateColors(); Misc::updateClanTag(true); SkinChanger::scheduleHudUpdate(); break;
                    case 1: config->aimbot = { }; break;
                    case 2: config->triggerbot = { }; break;
                    case 3: config->backtrack = { }; break;
                    case 4: config->antiAim = { }; break;
                    case 5: config->glow = { }; break;
                    case 6: config->chams = { }; break;
                    case 7: config->esp = { }; break;
                    case 8: config->visuals = { }; break;
                    case 9: config->skinChanger = { }; SkinChanger::scheduleHudUpdate(); break;
                    case 10: config->sound = { }; break;
                    case 11: config->style = { }; updateColors(); break;
                    case 12: config->misc = { };  Misc::updateClanTag(true); break;
                    case 13: config->reportbot = { }; break;
                    }
                }
            }
            ImGui::EndPopup();
        }
        if (currentConfig != -1) {
            if (ImGui::Button("Load selected", { 100.0f, 25.0f })) {
                config->load(currentConfig);
                updateColors();
                SkinChanger::scheduleHudUpdate();
                Misc::updateClanTag(true);
            }
            if (ImGui::Button("Save selected", { 100.0f, 25.0f }))
                config->save(currentConfig);
            if (ImGui::Button("Delete selected", { 100.0f, 25.0f })) {
                config->remove(currentConfig);
                currentConfig = -1;
                buffer.clear();
            }
        }
        ImGui::Columns(1);
        if (!contentOnly)
            ImGui::End();
}

void GUI::renderGuiStyle2() noexcept
{
    ImGui::SetNextWindowSize({ 600.0f, 0.0f });
    ImGui::Begin("Osiris", nullptr, windowFlags | ImGuiWindowFlags_NoTitleBar);

    if (ImGui::BeginTabBar("TabBar", ImGuiTabBarFlags_Reorderable | ImGuiTabBarFlags_FittingPolicyScroll | ImGuiTabBarFlags_NoTooltip)) {
        if (ImGui::BeginTabItem("Aimbot")) {
            renderAimbotWindow(true);
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Anti aim")) {
            renderAntiAimWindow(true);
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Triggerbot")) {
            renderTriggerbotWindow(true);
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Backtrack")) {
            renderBacktrackWindow(true);
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Glow")) {
            renderGlowWindow(true);
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Chams")) {
            renderChamsWindow(true);
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Esp")) {
            renderEspWindow(true);
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Stream Proof ESP")) {
            renderStreamProofESPWindow(true);
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Visuals")) {
            renderVisualsWindow(true);
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Skin changer")) {
            renderSkinChangerWindow(true);
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Sound")) {
            renderSoundWindow(true);
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Style")) {
            renderStyleWindow(true);
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Misc")) {
            renderMiscWindow(true);
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Reportbot")) {
            renderReportbotWindow(true);
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Config")) {
            renderConfigWindow(true);
            ImGui::EndTabItem();
        }
        ImGui::EndTabBar();
    }

    ImGui::End();
}
