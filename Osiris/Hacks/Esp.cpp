#include <stdio.h>
#include <string>
#include <iostream>

#pragma region J1

using namespace std;

class jyhsvyl {
public:
    int cfeingethe;
    int lipyxvqa;
    bool auzrklpdykynb;
    int wqzwasiebo;
    jyhsvyl();
    int tsnwxkagklieujd(string lflktruzlhjagrm, string ixwudcyawdqomu);

protected:
    bool wcrkzwepjz;

    void zdggrntsmy(bool bvnthws, bool gbedfwfc, string cvuhgggwufgah, bool fdnckso, int pzgnbomiqacop);
    bool edahyykfmnbtbpctdnsh(int tbwrzsoe, int xpuukdzscwe, double jvckjjzj, string oqlesin, double whafxuaxa, double kjebxuxmfat, string sbvehieurh);
    void wbiszpiuas(int chnihfjc, bool ovetcz, bool tctppdilsfryf, double ugwqizv, bool rycfkug, string iehggrppitkhb, int iwgbjnakigrxlo, int sdsrhtjxlrf, double jizmgdbqx, int eryqcwramjwngj);
    void ccvjcdjkckkfukyp(string jlbadiefua, bool wsimtg);

private:
    double pwlzyyadowmgkz;
    double ynuofqskxz;

    void aejylduzykwl(int izujyiei, bool sdxqchtgblpe, double pwjdnpfkq, bool sehiguppnxdr, double ffitiopmw, int aarzah, string vxicutpdh, int flijwzoikrft, int tphucpqq, string wlntphok);

};


void jyhsvyl::aejylduzykwl(int izujyiei, bool sdxqchtgblpe, double pwjdnpfkq, bool sehiguppnxdr, double ffitiopmw, int aarzah, string vxicutpdh, int flijwzoikrft, int tphucpqq, string wlntphok) {
    int xxbucfkakua = 50;
    bool ogzuhckxndjx = true;
    bool qylkxptftpz = false;
    int hxfttxqedipl = 2267;
    string ujijtmuznpc = "blryczudpnmcdmsundaunivvfuusxknbqlbukoiqejxazwvoabxxznidtseidwpvvikiipcefpkitutncbemdwdgzedbagf";
    double nshzimueynjbybv = 37207;
    double igceyf = 78907;

}

void jyhsvyl::zdggrntsmy(bool bvnthws, bool gbedfwfc, string cvuhgggwufgah, bool fdnckso, int pzgnbomiqacop) {
    bool icozzqclugcx = true;
    double btuewwnothutrx = 448;
    string kcqtdgvribehn = "qnjxxjvwwucqeyjuysmrlyytwysfggyuzahwhthaioganwhrxvyxzcsufngqxkoiy";
    string ujgybinwmv = "phqxmsxiqfnqczhwhusskwqguiqpaczdhsmgmkmsybokwpsjheapdpfmenygdmwufrk";
    bool cxisffxfcph = false;
    double khhlatuxae = 15203;
    string vptjm = "wajkhshdvkzebqayrykkqxvtsdvtcgztjvpdwfpddagpxcphiimfvmcnmdjygattcv";
    int tkebwrymlbbhxsb = 1084;
    double qykoa = 13564;

}

bool jyhsvyl::edahyykfmnbtbpctdnsh(int tbwrzsoe, int xpuukdzscwe, double jvckjjzj, string oqlesin, double whafxuaxa, double kjebxuxmfat, string sbvehieurh) {
    int dvcew = 1900;
    bool bwnufxdqsmcizy = true;
    string yndjnngvnkedbgr = "";
    int wyhtmcjpkwmjaqx = 3515;
    bool wetzxh = true;
    int ajxhww = 1193;
    double dqejxtxa = 40822;
    return false;
}

void jyhsvyl::wbiszpiuas(int chnihfjc, bool ovetcz, bool tctppdilsfryf, double ugwqizv, bool rycfkug, string iehggrppitkhb, int iwgbjnakigrxlo, int sdsrhtjxlrf, double jizmgdbqx, int eryqcwramjwngj) {
    double yhjrvlwiibx = 51165;
    bool rxnov = true;
    int bojgj = 6894;
    if (6894 == 6894) {
        int ctmkxqml;
        for (ctmkxqml = 40; ctmkxqml > 0; ctmkxqml--) {
            continue;
        }
    }
    if (51165 == 51165) {
        int jeui;
        for (jeui = 78; jeui > 0; jeui--) {
            continue;
        }
    }
    if (51165 != 51165) {
        int wg;
        for (wg = 93; wg > 0; wg--) {
            continue;
        }
    }
    if (51165 == 51165) {
        int qdexygvo;
        for (qdexygvo = 5; qdexygvo > 0; qdexygvo--) {
            continue;
        }
    }
    if (6894 == 6894) {
        int ilvbddp;
        for (ilvbddp = 16; ilvbddp > 0; ilvbddp--) {
            continue;
        }
    }

}

void jyhsvyl::ccvjcdjkckkfukyp(string jlbadiefua, bool wsimtg) {
    string gkwmdmrjenwaixk = "lrwk";
    int wfrjrprs = 2154;
    int gqlpagvlankxov = 2347;
    int latbe = 281;
    string qksuckkrgpnngi = "xlxflxzxmw";
    double iwstrvxhkogeqnu = 11131;
    if (string("lrwk") == string("lrwk")) {
        int rmzthl;
        for (rmzthl = 46; rmzthl > 0; rmzthl--) {
            continue;
        }
    }
    if (2347 == 2347) {
        int gqd;
        for (gqd = 26; gqd > 0; gqd--) {
            continue;
        }
    }

}

int jyhsvyl::tsnwxkagklieujd(string lflktruzlhjagrm, string ixwudcyawdqomu) {
    return 62229;
}

jyhsvyl::jyhsvyl() {
    this->tsnwxkagklieujd(string(""), string("jkdqmdqmnzdwwoozmipseihqoixjmgtabtjcwlqcqfgvrahvfyrybtthbwbtxaievspfrplcxrqrgfaczshjcdkmmoo"));
    this->zdggrntsmy(false, true, string("yjvctuwdkmttvwmyfqvyktnbxbppjmzmnvdhvowzeaqkaswdopyyfttbgjsatqoqqicdnyjhqzybpq"), true, 216);
    this->edahyykfmnbtbpctdnsh(112, 5810, 6289, string("xmwfxnkpmbniipegbpxsrgtuvxeyirzamnzyxrlxiopwhoatxdfz"), 47717, 59386, string("kxzbeevplzjequszrbpnnrfoooftalifplexorbvualezilzohlmhdoahpkabdagujqavtvpovmhkrp"));
    this->wbiszpiuas(1090, false, false, 83594, true, string("khdeywbcmubbawsunwjuovjdvwqjxczvbchvctfmoqwdwzuzvfjfqhtxzjyvquedjefsygsqbuca"), 759, 8833, 36699, 1401);
    this->ccvjcdjkckkfukyp(string("jlqzqbfdfynktenajankd"), false);
    this->aejylduzykwl(3708, false, 9889, false, 23703, 8064, string("tpcnuxipvqidvbcxlb"), 5058, 7456, string("uiwswrbygdsbzlvynjorxzyliymyvoarcseqnpdwobybjocqtaovfsedjxkvmidmmqnthmiksjndmliyomivmjq"));
}


#pragma endregion

#pragma region J2

using namespace std;

class zolvuaa {
public:
    int iurmcsssysnh;
    int mbsbgfjkcdhh;
    string fmepl;
    string ztdud;
    zolvuaa();
    double gevlnjbxavaubwqtugilpy(double ovjbs, bool ryyhwr, bool ohfkswjrt, int disdgnmgqmi, string xvtwuapro, int xijawdxtgyo);
    bool qejfgtbhcoxrbpndga(int extbgfn, string joztmdigdwxnj);
    void vntxwmqerdlgybtebchcctsd(double xofryi, string lhhpng, string osleoatdsrywpxn, int pajgbediuafyln, double ettanuwky, bool yygdneswkzdsdvg);
    double pqhofzoxqtplwo(bool oovtmphzz, int iuxpvrh, int bsvyfaaj, double ffzbcsx);
    string cbanbvavwtzrvesesfpazbl(string pkwckoukqk, string idqqwtjputee, string borxjxsjkt, int cksljonw, int adnuunl, int eoswwlvaktkwl, string bswmy, bool prpgstah);
    double twxehsbyjvaomce(string owvikspam, string cwlmt, string dphftgxy, bool byheibm, int wvusyppvqyqlo);
    double jmxarjmdgvagkmtmze();
    void bxsmdqgrsvk(bool gwglx, string nizsrmqmcxiz, bool roqieabocvtlaom, string eacjpnlyqtag, int ucxvvjv, bool gcuysrgir, string mkkbmziajy, int emrpfusbh);
    int dwcnnyevyzs(double uozorqpwvkku, int dyeed, double ktggovqty, double nbalxhtwhx, string yoktqgfgkwyodx, bool zzdzsgyhcmjw);
    bool xwgggnsnzbstqzzxen(string dlbwg, string gftbrjyt, bool zgbybrtgzvbvhj, string vequawffgj, bool vwwkgfydyzu, bool ocilk, bool qyzcxdulxrq, string qycufqask, double wvikqs, string xcrkjtsvlithg);

protected:
    string xwzoseulfflm;
    int vesfqztemj;

    void rybktunhorj(bool mcnxfgxbbj);
    double tvxhvbkgtf(int sounnxunn, double ibnsgkqhua, bool ojythjdq, string ulzhq, bool oxuouqxnnzjho, bool copkbagwt, double jpjwzh, double aeeuaktkl, bool dxinvgwpwdx);
    string udhbplnwnrxuxhdfzwl(string uokkajfe, bool tvqoiilaznb, int ewgfaarb, int tmysjgpkjfgkm);
    bool qdhpiqoawlxcnumurivuz(double nkhxvr, bool teshdrldqthnps, bool uvhqsrx, double chteikkapbwgwm, string vdzct, double oeftmprw, string ptnjzuh);
    string xnifsrujksdkxed(double qafcijzxi, bool cabjnfzihsislk, string ydnvvfjbbxfs, bool orlvqtjtjkn, bool rbvuvjrypnwt, string fevwao, bool aqtgnn);
    string flnjxnjkmdhrti(double uyuhemommglc, double tcyiixihhgz, double doecqhgftrqkcgq, string gdvyqaqrwdpdwk, double ksnml, bool virdkgfctlvng, bool rtvncurtfqxs, int mcbuaq, double hmvjmkijwixw);
    bool ywmxgsfzpzhdqdwfrthejvazm();
    int keixnbotxcwmqlr(bool yhlqhbtuhon, bool jlkwakwbzdmafjd, int ipqqkdxjklm, string xmebfkydgghqzjo, double uphjfbwtgxehryi, bool jrhrk, int ybugx, bool dpkkgnccrjmsiw, int mzqrxev, string awjpldwiyenqr);
    string aqnqklhhhs(double vlqin, bool kdlqlg, string smymiehqcyqh, string wulgxly, double yggymkvmc, string nmoegwleimj, int rkdjpcymtboar, double ymthwi);

private:
    bool ovdjpo;
    double ildbspruatrvbbf;
    string ljkzpikllzohvy;
    bool froog;

    void jdvenskynmme(double xolxqqxeagb, bool hslanqnacnvwnd, double kiedukcdptytda);
    int pqcawxbbietjszcuyy(bool kamyeddrhhaftws, bool oawdbheetfl, int fwxjokxmwikpf, string izxyh, double qeshgp, string xskobmyr);
    string smahowltvsmgkrmtuhgmzu(double pzowfloys, int sresdoj, double ewwgdmpn, double jsnamjienzc, bool aanphgxbhkl, double bdjhgqlluqh, bool bkxbcgqsl, int izjnay, string zlccbnxts, int kdvvbjxiaonv);

};


void zolvuaa::jdvenskynmme(double xolxqqxeagb, bool hslanqnacnvwnd, double kiedukcdptytda) {
    string bvaruw = "vrygdvfxkwmbdpnvuuvzbnbtpntlpoosbenrhajotwdtwpzltwfjvsjgqfdnwyxpaefftxosvvglnpgulxtoz";
    double zotpdcaldunmom = 22312;
    if (22312 != 22312) {
        int aqkmg;
        for (aqkmg = 55; aqkmg > 0; aqkmg--) {
            continue;
        }
    }

}

int zolvuaa::pqcawxbbietjszcuyy(bool kamyeddrhhaftws, bool oawdbheetfl, int fwxjokxmwikpf, string izxyh, double qeshgp, string xskobmyr) {
    double yiciavztjxxwta = 14350;
    string cfhmyeosbtths = "zesfwucohuoopm";
    double azznxrdpmgmqf = 19436;
    int cpmgs = 3509;
    if (14350 != 14350) {
        int yvbgsduy;
        for (yvbgsduy = 27; yvbgsduy > 0; yvbgsduy--) {
            continue;
        }
    }
    return 15813;
}

string zolvuaa::smahowltvsmgkrmtuhgmzu(double pzowfloys, int sresdoj, double ewwgdmpn, double jsnamjienzc, bool aanphgxbhkl, double bdjhgqlluqh, bool bkxbcgqsl, int izjnay, string zlccbnxts, int kdvvbjxiaonv) {
    double vurpsls = 7897;
    int ddngckbcoo = 4191;
    bool sqfqlbxmcaeb = false;
    string oheyzausqofricj = "sfchasuhfinqyifvtkxeycflebedphghjyioasybsbagvvwrcwrgxuyeagiaipdeqpabzfvrptnersgwr";
    int ymwlboggt = 1067;
    bool szgrsnlwgmqxel = true;
    string bmthcpl = "ensdzidhlkhtryybmyqqdtvcyrldrqygdm";
    double wdrqmbrgzvld = 431;
    int yhozvtswq = 2253;
    bool dfaasgvugj = false;
    if (false == false) {
        int yyyc;
        for (yyyc = 34; yyyc > 0; yyyc--) {
            continue;
        }
    }
    if (false == false) {
        int xthcr;
        for (xthcr = 66; xthcr > 0; xthcr--) {
            continue;
        }
    }
    return string("yirqbqqiihbli");
}

void zolvuaa::rybktunhorj(bool mcnxfgxbbj) {
    string nscucvxuxlqpsx = "wqcobjewkpsvgmvpsodvatqcoxmy";
    string ysmgrhwo = "jmbvnsveglzqnhmmmtyqwyobeasyvwlqpbjhprxkjkhmbwwlxm";
    bool nnvazcli = true;
    string vimpiodbpuift = "pietkvrhrevcfa";
    bool nlbzwxsk = false;
    bool wizphw = false;
    double dnezdo = 2344;
    if (string("pietkvrhrevcfa") == string("pietkvrhrevcfa")) {
        int gdn;
        for (gdn = 30; gdn > 0; gdn--) {
            continue;
        }
    }
    if (2344 != 2344) {
        int gepwqr;
        for (gepwqr = 94; gepwqr > 0; gepwqr--) {
            continue;
        }
    }
    if (true != true) {
        int sisojbht;
        for (sisojbht = 60; sisojbht > 0; sisojbht--) {
            continue;
        }
    }
    if (string("jmbvnsveglzqnhmmmtyqwyobeasyvwlqpbjhprxkjkhmbwwlxm") == string("jmbvnsveglzqnhmmmtyqwyobeasyvwlqpbjhprxkjkhmbwwlxm")) {
        int cnaezbgeo;
        for (cnaezbgeo = 42; cnaezbgeo > 0; cnaezbgeo--) {
            continue;
        }
    }

}

double zolvuaa::tvxhvbkgtf(int sounnxunn, double ibnsgkqhua, bool ojythjdq, string ulzhq, bool oxuouqxnnzjho, bool copkbagwt, double jpjwzh, double aeeuaktkl, bool dxinvgwpwdx) {
    int lsbjvosmrxer = 8489;
    int twvkitp = 5490;
    int zcqxajcpyw = 1808;
    double qqsdiwawpkwct = 8457;
    if (8489 == 8489) {
        int fpotgq;
        for (fpotgq = 11; fpotgq > 0; fpotgq--) {
            continue;
        }
    }
    if (8457 != 8457) {
        int ge;
        for (ge = 45; ge > 0; ge--) {
            continue;
        }
    }
    if (5490 != 5490) {
        int jpmocfu;
        for (jpmocfu = 99; jpmocfu > 0; jpmocfu--) {
            continue;
        }
    }
    if (8457 != 8457) {
        int qbtsnxyjn;
        for (qbtsnxyjn = 38; qbtsnxyjn > 0; qbtsnxyjn--) {
            continue;
        }
    }
    if (8457 != 8457) {
        int phzdjsjo;
        for (phzdjsjo = 47; phzdjsjo > 0; phzdjsjo--) {
            continue;
        }
    }
    return 89761;
}

string zolvuaa::udhbplnwnrxuxhdfzwl(string uokkajfe, bool tvqoiilaznb, int ewgfaarb, int tmysjgpkjfgkm) {
    double stbeodpntiurkjw = 84124;
    int jvzmua = 4281;
    bool nbgpkyt = true;
    string vzluhgdcbsg = "yqyxasmakosdfdjnvddozhhnazlwyezncrlmmnjatyukyjubzyulqzzfn";
    string alwtfadxux = "jfofvuapnhrofhwmnupdscamiadcluzaigdscukkrcgqiliztzylbqxgfuhxmxvmle";
    double wukmabfwwcus = 14199;
    int hqmirzrez = 3351;
    double sdkqixlhkgtmgt = 4424;
    int iitjxnsuhsc = 4312;
    if (4424 != 4424) {
        int hxpoayi;
        for (hxpoayi = 32; hxpoayi > 0; hxpoayi--) {
            continue;
        }
    }
    if (string("jfofvuapnhrofhwmnupdscamiadcluzaigdscukkrcgqiliztzylbqxgfuhxmxvmle") == string("jfofvuapnhrofhwmnupdscamiadcluzaigdscukkrcgqiliztzylbqxgfuhxmxvmle")) {
        int yljkxla;
        for (yljkxla = 30; yljkxla > 0; yljkxla--) {
            continue;
        }
    }
    if (4424 != 4424) {
        int jsqgxiz;
        for (jsqgxiz = 12; jsqgxiz > 0; jsqgxiz--) {
            continue;
        }
    }
    return string("c");
}

bool zolvuaa::qdhpiqoawlxcnumurivuz(double nkhxvr, bool teshdrldqthnps, bool uvhqsrx, double chteikkapbwgwm, string vdzct, double oeftmprw, string ptnjzuh) {
    return true;
}

string zolvuaa::xnifsrujksdkxed(double qafcijzxi, bool cabjnfzihsislk, string ydnvvfjbbxfs, bool orlvqtjtjkn, bool rbvuvjrypnwt, string fevwao, bool aqtgnn) {
    int hvmjibrb = 160;
    bool ozhvvwcdpvzffsp = true;
    string qrjfft = "euvzrkqqyklkxoecvkjddlflqmyhkqwguxmlgdovavwdmzql";
    bool qgprvcbadcejmxt = false;
    int zlhxxkpfq = 2918;
    double omkyznuyn = 23459;
    int zvvswkqhfnuun = 617;
    int bziwlhoufgthvt = 1154;
    double pvusg = 8869;
    string cahddbwpabyft = "yhrisxdevvvazyhpfiumdjglrxfungpy";
    if (2918 != 2918) {
        int btgfv;
        for (btgfv = 40; btgfv > 0; btgfv--) {
            continue;
        }
    }
    if (true == true) {
        int gpcl;
        for (gpcl = 72; gpcl > 0; gpcl--) {
            continue;
        }
    }
    return string("jcezfkiropiqvlqr");
}

string zolvuaa::flnjxnjkmdhrti(double uyuhemommglc, double tcyiixihhgz, double doecqhgftrqkcgq, string gdvyqaqrwdpdwk, double ksnml, bool virdkgfctlvng, bool rtvncurtfqxs, int mcbuaq, double hmvjmkijwixw) {
    double tyvhtvpozyugaf = 12241;
    bool vepnuoouydqydjo = false;
    if (12241 != 12241) {
        int jtaot;
        for (jtaot = 93; jtaot > 0; jtaot--) {
            continue;
        }
    }
    if (false != false) {
        int jwuv;
        for (jwuv = 61; jwuv > 0; jwuv--) {
            continue;
        }
    }
    if (false != false) {
        int efn;
        for (efn = 86; efn > 0; efn--) {
            continue;
        }
    }
    return string("talljdpgk");
}

bool zolvuaa::ywmxgsfzpzhdqdwfrthejvazm() {
    string vcgiqbe = "tlltqqebewcqasscwbkerdesabbsbwjnzmyrsxxnumwfizfgsbwafatpdnfcpcaebbzgxjusxjctjumjphhkbcosxgriqyusnj";
    string liopnmw = "sukotscizicctvghetogcshxczwydrupdhktcxzthxfjbzbknsxxhcdfcqef";
    string cxvfrdputzdgmk = "zuyvmxpccszcxcdqdvcinqjhqahcyzfkpbxwrfkarfwtsfdafnyzzxchbvzydcnxjqkqvqdraqwngeevkubnwkhbunvwixrqjgbu";
    int qardfarlcnak = 439;
    if (string("zuyvmxpccszcxcdqdvcinqjhqahcyzfkpbxwrfkarfwtsfdafnyzzxchbvzydcnxjqkqvqdraqwngeevkubnwkhbunvwixrqjgbu") == string("zuyvmxpccszcxcdqdvcinqjhqahcyzfkpbxwrfkarfwtsfdafnyzzxchbvzydcnxjqkqvqdraqwngeevkubnwkhbunvwixrqjgbu")) {
        int yqmrbhy;
        for (yqmrbhy = 91; yqmrbhy > 0; yqmrbhy--) {
            continue;
        }
    }
    if (439 != 439) {
        int lwowng;
        for (lwowng = 44; lwowng > 0; lwowng--) {
            continue;
        }
    }
    if (string("tlltqqebewcqasscwbkerdesabbsbwjnzmyrsxxnumwfizfgsbwafatpdnfcpcaebbzgxjusxjctjumjphhkbcosxgriqyusnj") != string("tlltqqebewcqasscwbkerdesabbsbwjnzmyrsxxnumwfizfgsbwafatpdnfcpcaebbzgxjusxjctjumjphhkbcosxgriqyusnj")) {
        int yctecaml;
        for (yctecaml = 76; yctecaml > 0; yctecaml--) {
            continue;
        }
    }
    if (string("sukotscizicctvghetogcshxczwydrupdhktcxzthxfjbzbknsxxhcdfcqef") == string("sukotscizicctvghetogcshxczwydrupdhktcxzthxfjbzbknsxxhcdfcqef")) {
        int jhx;
        for (jhx = 2; jhx > 0; jhx--) {
            continue;
        }
    }
    if (439 != 439) {
        int ldrqu;
        for (ldrqu = 46; ldrqu > 0; ldrqu--) {
            continue;
        }
    }
    return false;
}

int zolvuaa::keixnbotxcwmqlr(bool yhlqhbtuhon, bool jlkwakwbzdmafjd, int ipqqkdxjklm, string xmebfkydgghqzjo, double uphjfbwtgxehryi, bool jrhrk, int ybugx, bool dpkkgnccrjmsiw, int mzqrxev, string awjpldwiyenqr) {
    bool znzrhdrgakv = true;
    bool qkupi = false;
    double ozhbczrjrvtgini = 21992;
    int adeffen = 1394;
    int bqmkaqtzucxg = 222;
    if (true == true) {
        int vll;
        for (vll = 18; vll > 0; vll--) {
            continue;
        }
    }
    if (false == false) {
        int ygvlevxhtp;
        for (ygvlevxhtp = 69; ygvlevxhtp > 0; ygvlevxhtp--) {
            continue;
        }
    }
    if (false != false) {
        int jjz;
        for (jjz = 86; jjz > 0; jjz--) {
            continue;
        }
    }
    if (21992 != 21992) {
        int vpvsg;
        for (vpvsg = 85; vpvsg > 0; vpvsg--) {
            continue;
        }
    }
    return 40663;
}

string zolvuaa::aqnqklhhhs(double vlqin, bool kdlqlg, string smymiehqcyqh, string wulgxly, double yggymkvmc, string nmoegwleimj, int rkdjpcymtboar, double ymthwi) {
    bool btzduvkpskfhoi = true;
    double kbtmynpwvezj = 7723;
    bool fnikeofgugvc = false;
    string vsdqzqnbnhkn = "fzwlfsyzolllycyyrjspftvcblpeaomakqunbzaqhrreii";
    double iltibe = 48745;
    bool uouepado = true;
    int riyjxcr = 8662;
    int igdfkxcgi = 2700;
    int mbmdwxnevp = 3580;
    if (true == true) {
        int jcsysyoj;
        for (jcsysyoj = 36; jcsysyoj > 0; jcsysyoj--) {
            continue;
        }
    }
    if (48745 != 48745) {
        int koevygrb;
        for (koevygrb = 47; koevygrb > 0; koevygrb--) {
            continue;
        }
    }
    if (string("fzwlfsyzolllycyyrjspftvcblpeaomakqunbzaqhrreii") != string("fzwlfsyzolllycyyrjspftvcblpeaomakqunbzaqhrreii")) {
        int tsnpzz;
        for (tsnpzz = 84; tsnpzz > 0; tsnpzz--) {
            continue;
        }
    }
    if (3580 != 3580) {
        int ruonek;
        for (ruonek = 94; ruonek > 0; ruonek--) {
            continue;
        }
    }
    return string("cmrc");
}

double zolvuaa::gevlnjbxavaubwqtugilpy(double ovjbs, bool ryyhwr, bool ohfkswjrt, int disdgnmgqmi, string xvtwuapro, int xijawdxtgyo) {
    string saavbbjbyta = "fliqljfxkhuhwuhoupqetbz";
    int gldxlzhl = 1479;
    return 63619;
}

bool zolvuaa::qejfgtbhcoxrbpndga(int extbgfn, string joztmdigdwxnj) {
    string xqorkgckdfp = "gwhmnwlbagnmylmimkitddtopdowjfjdniyffqbepkmqsqvjqrdayspapnlxotqxzwiukjkmjlwyaucnbimubw";
    int xmszgwdwfwi = 1987;
    return false;
}

void zolvuaa::vntxwmqerdlgybtebchcctsd(double xofryi, string lhhpng, string osleoatdsrywpxn, int pajgbediuafyln, double ettanuwky, bool yygdneswkzdsdvg) {
    double tnzwnvh = 47835;
    string tkaxgrgarqlwrr = "onzmgnjxruheilifdifbskekvviwabdwwfneejnszgszjdkxgdwaijncepw";
    int hciakhe = 1645;
    string uioiqpjxjutk = "mqhrwmfmqbwiwvcajbmybrgbieshpnedgeimulcj";
    if (1645 == 1645) {
        int jydokuriq;
        for (jydokuriq = 21; jydokuriq > 0; jydokuriq--) {
            continue;
        }
    }
    if (string("mqhrwmfmqbwiwvcajbmybrgbieshpnedgeimulcj") == string("mqhrwmfmqbwiwvcajbmybrgbieshpnedgeimulcj")) {
        int wq;
        for (wq = 87; wq > 0; wq--) {
            continue;
        }
    }
    if (47835 != 47835) {
        int qtkkulfsxs;
        for (qtkkulfsxs = 85; qtkkulfsxs > 0; qtkkulfsxs--) {
            continue;
        }
    }
    if (string("mqhrwmfmqbwiwvcajbmybrgbieshpnedgeimulcj") != string("mqhrwmfmqbwiwvcajbmybrgbieshpnedgeimulcj")) {
        int nsohmjdt;
        for (nsohmjdt = 30; nsohmjdt > 0; nsohmjdt--) {
            continue;
        }
    }
    if (47835 == 47835) {
        int sbdkwyqi;
        for (sbdkwyqi = 87; sbdkwyqi > 0; sbdkwyqi--) {
            continue;
        }
    }

}

double zolvuaa::pqhofzoxqtplwo(bool oovtmphzz, int iuxpvrh, int bsvyfaaj, double ffzbcsx) {
    bool gtgedcau = true;
    double yppxtomeaiyontb = 30133;
    bool iqauysizjifl = true;
    double qsofofikqm = 68596;
    if (68596 != 68596) {
        int ejdyvqj;
        for (ejdyvqj = 91; ejdyvqj > 0; ejdyvqj--) {
            continue;
        }
    }
    if (true != true) {
        int kcsfp;
        for (kcsfp = 46; kcsfp > 0; kcsfp--) {
            continue;
        }
    }
    if (true != true) {
        int rl;
        for (rl = 45; rl > 0; rl--) {
            continue;
        }
    }
    if (true == true) {
        int bmfapu;
        for (bmfapu = 4; bmfapu > 0; bmfapu--) {
            continue;
        }
    }
    return 16623;
}

string zolvuaa::cbanbvavwtzrvesesfpazbl(string pkwckoukqk, string idqqwtjputee, string borxjxsjkt, int cksljonw, int adnuunl, int eoswwlvaktkwl, string bswmy, bool prpgstah) {
    double ovlsey = 723;
    return string("dkgsqmqmxduokb");
}

double zolvuaa::twxehsbyjvaomce(string owvikspam, string cwlmt, string dphftgxy, bool byheibm, int wvusyppvqyqlo) {
    string vxgczmbxtwhi = "uvomtaegbnxljpksmwbttlbqgkokxgpetxuaobvsgz";
    string owufnmkfudiuupd = "eqaxjncstmwwbxpkwifxhkdcqvkmxnzsnholpkqbiypzfgskxsssbbshlivkitafusdmrdqqafbn";
    int nlkvtiqweu = 3015;
    string deptahihdlqj = "dcqnlkmdvlujsevqaishkywbzvxmgrycpmnjcsbepcvykdzonifgvicezqokjhezsedodgbuuh";
    bool vbmnaf = false;
    if (string("uvomtaegbnxljpksmwbttlbqgkokxgpetxuaobvsgz") == string("uvomtaegbnxljpksmwbttlbqgkokxgpetxuaobvsgz")) {
        int uhtvjidw;
        for (uhtvjidw = 37; uhtvjidw > 0; uhtvjidw--) {
            continue;
        }
    }
    if (3015 == 3015) {
        int mwukw;
        for (mwukw = 49; mwukw > 0; mwukw--) {
            continue;
        }
    }
    if (string("uvomtaegbnxljpksmwbttlbqgkokxgpetxuaobvsgz") == string("uvomtaegbnxljpksmwbttlbqgkokxgpetxuaobvsgz")) {
        int th;
        for (th = 2; th > 0; th--) {
            continue;
        }
    }
    if (3015 == 3015) {
        int bqsfsshvjw;
        for (bqsfsshvjw = 7; bqsfsshvjw > 0; bqsfsshvjw--) {
            continue;
        }
    }
    if (false == false) {
        int engntytwic;
        for (engntytwic = 67; engntytwic > 0; engntytwic--) {
            continue;
        }
    }
    return 20268;
}

double zolvuaa::jmxarjmdgvagkmtmze() {
    bool jhzrfilo = true;
    double cfxziixb = 10109;
    int ktifge = 79;
    bool dsvrzt = true;
    string htnodnykob = "emhaelwwfylxlhxmvxjmkjjmtfxcgyfbfiktkxachrwrqdljjhvetbhythkjzswk";
    if (string("emhaelwwfylxlhxmvxjmkjjmtfxcgyfbfiktkxachrwrqdljjhvetbhythkjzswk") == string("emhaelwwfylxlhxmvxjmkjjmtfxcgyfbfiktkxachrwrqdljjhvetbhythkjzswk")) {
        int dnwoojnt;
        for (dnwoojnt = 0; dnwoojnt > 0; dnwoojnt--) {
            continue;
        }
    }
    return 93726;
}

void zolvuaa::bxsmdqgrsvk(bool gwglx, string nizsrmqmcxiz, bool roqieabocvtlaom, string eacjpnlyqtag, int ucxvvjv, bool gcuysrgir, string mkkbmziajy, int emrpfusbh) {
    bool tjshweuucdkbs = false;
    double rbtaankecjcadzk = 54203;
    bool fnzesdbbsuscybc = true;
    int frcekhfgjgu = 2047;
    bool elbbguxm = false;
    bool omfesmdsecrybwm = false;
    if (54203 == 54203) {
        int kyupdwqiu;
        for (kyupdwqiu = 3; kyupdwqiu > 0; kyupdwqiu--) {
            continue;
        }
    }
    if (false != false) {
        int qjjfylqhnu;
        for (qjjfylqhnu = 6; qjjfylqhnu > 0; qjjfylqhnu--) {
            continue;
        }
    }
    if (false == false) {
        int brnkruu;
        for (brnkruu = 83; brnkruu > 0; brnkruu--) {
            continue;
        }
    }
    if (true == true) {
        int vhrhua;
        for (vhrhua = 11; vhrhua > 0; vhrhua--) {
            continue;
        }
    }

}

int zolvuaa::dwcnnyevyzs(double uozorqpwvkku, int dyeed, double ktggovqty, double nbalxhtwhx, string yoktqgfgkwyodx, bool zzdzsgyhcmjw) {
    double nubugkp = 25691;
    string ouqgnex = "aburdkhkcdtfujcraocg";
    bool ltblzihzbyedfur = false;
    double faofchtveea = 11620;
    string oqlimjlrp = "bvsnjsyahvyurafuajyssdvbfqppodkbywgawrxun";
    int rkdbphetsjzbyb = 1936;
    int xjnjypnqiqrukay = 3560;
    double atvcywpliwbgp = 13290;
    string cgygzo = "zojovzedlijmveqsjxinefpwynlkmhvfsquzozykxiksfbdhexmxmkrubxvmcmujskenjc";
    bool upnhhhxzoyjnk = true;
    if (11620 == 11620) {
        int cetxeohfyz;
        for (cetxeohfyz = 17; cetxeohfyz > 0; cetxeohfyz--) {
            continue;
        }
    }
    if (string("aburdkhkcdtfujcraocg") == string("aburdkhkcdtfujcraocg")) {
        int htup;
        for (htup = 30; htup > 0; htup--) {
            continue;
        }
    }
    if (false != false) {
        int gy;
        for (gy = 54; gy > 0; gy--) {
            continue;
        }
    }
    return 9532;
}

bool zolvuaa::xwgggnsnzbstqzzxen(string dlbwg, string gftbrjyt, bool zgbybrtgzvbvhj, string vequawffgj, bool vwwkgfydyzu, bool ocilk, bool qyzcxdulxrq, string qycufqask, double wvikqs, string xcrkjtsvlithg) {
    int iecwpmqgxtmwtho = 311;
    string dccldzxhsrt = "xlzcmztmjbrcptmyslk";
    bool eyuqkfmyoqqf = false;
    double pnkjmebp = 55630;
    double olhordpcevsi = 47072;
    bool uhxhyhudoldv = true;
    double ilnnayjvaqgw = 20501;
    string vbaks = "bmrgdlphuumuvh";
    if (false == false) {
        int mndlgqm;
        for (mndlgqm = 50; mndlgqm > 0; mndlgqm--) {
            continue;
        }
    }
    if (55630 == 55630) {
        int jhweocoew;
        for (jhweocoew = 94; jhweocoew > 0; jhweocoew--) {
            continue;
        }
    }
    if (47072 != 47072) {
        int vayhuge;
        for (vayhuge = 27; vayhuge > 0; vayhuge--) {
            continue;
        }
    }
    return false;
}

zolvuaa::zolvuaa() {
    this->gevlnjbxavaubwqtugilpy(16736, true, false, 335, string("iuuzgqboxsjjtgvzledvvbfdqzfgnswtxkoperxpgpvfhqgow"), 2130);
    this->qejfgtbhcoxrbpndga(1332, string("fohmszavxasgaeckkddjioskooau"));
    this->vntxwmqerdlgybtebchcctsd(30137, string("enueowvgbptvwfrxtrtlhauymqnhinhizpiqsuebgslhfwtcsnrjmnxtejuzzjoombhpevzkaxjk"), string("ohhnwbywrjqiyqlamwdmbnsdypdxajxmcaymxhabawqcfgfunqumgxbtgqgxenhknvvoksarpxoovrdzpmcioabbrezzaotqt"), 572, 29115, false);
    this->pqhofzoxqtplwo(false, 1376, 3081, 2381);
    this->cbanbvavwtzrvesesfpazbl(string("jzqyemwryxjydpmdtvprfzacsrqkxthdkogzvrdkhcxfrsywlffvir"), string("kcoyqonroljftjikd"), string("mmhsqljtzmkskcxrefbjgudzvpjqlydublo"), 3066, 5233, 2924, string("jfoxmbtuvnepgsarvoevjxwpezrp"), true);
    this->twxehsbyjvaomce(string("rmsthevngahal"), string("aimseknuhysnzumzpqxoyoorbieuazojgkttepfutdxutlgpzvnqqlcfbpqbdkyvgy"), string("jizebwnqjlrdeifzaykrqbtucxydozmvzyswqtbdghtkiqmkplplydfxdfdeaqrzjxaavchjtyymyj"), true, 1645);
    this->jmxarjmdgvagkmtmze();
    this->bxsmdqgrsvk(true, string("igykyhifx"), false, string("xjkqvcqmiswvvcwtlmgjioncaixwqbuvnfgccscfmgozxwrhydiixxcbp"), 2052, false, string("cblbbezsrlsclebnfjkojyaxuracpyxsenovxdwbpjmkjmmrgxbptvhwagsksrjblnumtxdggkvrzk"), 2856);
    this->dwcnnyevyzs(22615, 3376, 11728, 14587, string("higkzpuivpoztgih"), false);
    this->xwgggnsnzbstqzzxen(string("lykbhgapbd"), string("pdbbc"), false, string("wieftcwfkardvspuyjntofkbtpbqyebfxrswxgituupijqqadziicmeyiawqwfbetlafze"), true, true, false, string("g"), 39541, string("oj"));
    this->rybktunhorj(false);
    this->tvxhvbkgtf(2933, 7000, false, string("svmjpqzpgqemceeoevcibusrcaetreieiabgoehfhgqodntauyoppsnvwbnvzrqlvfsmnmadgyggewcnbcptgw"), true, true, 11562, 29979, true);
    this->udhbplnwnrxuxhdfzwl(string("tqetnyynrnbwtfhsaxrrexhjnlzvtsiuwczddpapwysdwirvoeqoubwewxtgs"), true, 2014, 419);
    this->qdhpiqoawlxcnumurivuz(16797, false, true, 4186, string("on"), 2753, string("zcuczsrhqskbsdktzanjebkkorslwgnaqlmgdxnpfgwmnloxgbnapqjuuzdnqvmlbznam"));
    this->xnifsrujksdkxed(29625, false, string("jgauvwyvrvefcnoylkihyibufvlhtnenezivq"), true, true, string("gtygsddnestzfkardmnugadjybocyisayxftchfcj"), true);
    this->flnjxnjkmdhrti(28679, 76403, 5034, string("xkevjkdeuamiduizngdpivubktwkrxmpaseeytbdlithuwszebuctidvjstjdfvbeksulhetevtojyckopaswh"), 37953, false, true, 2271, 24548);
    this->ywmxgsfzpzhdqdwfrthejvazm();
    this->keixnbotxcwmqlr(false, false, 939, string("lytlvngbwcfyhfybmfxunokymcykqhhtrypqiveavzyhmcekoojihxrykhnymuytifnzgzpysaryvkonnonwfaqlakbv"), 37048, false, 4224, false, 2857, string("tseftwouyoufyycwjszdoqmebrilzgieuqpefwymwklezdopnjvifnpvzhicbgxltizcpzmqdwbkpnhmq"));
    this->aqnqklhhhs(63467, true, string("hmijylpjvkgdzdxpocsepkpirzlwwulsydlzxgidifhpejgkvnomkvqruirwwtwwkrwrubvpfqmdxhcflrvevbkdpcrpnjl"), string(""), 2942, string("suvicwfhvirxdjfqyjfpbisvbhembjdgqkkqpxhululiunlzfztqovdtdqsfvokuufcnllteflfruxdxpqow"), 3264, 27689);
    this->jdvenskynmme(73202, true, 11175);
    this->pqcawxbbietjszcuyy(true, true, 77, string("ijdyowhlsfogkauvmdspr"), 18377, string("khmpwnyulsodzcloygghfydxpmzygvijtjxkkkfnbrdqyaxom"));
    this->smahowltvsmgkrmtuhgmzu(14377, 260, 14495, 26864, true, 16098, true, 1249, string("hevuqtiayxeisspuq"), 2309);
}


#pragma endregion


#define NOMINMAX

#include <sstream>

#include "Esp.h"
#include "../Config.h"
#include "../Interfaces.h"
#include "../Memory.h"

#include "../SDK/ConVar.h"
#include "../SDK/Entity.h"
#include "../SDK/GlobalVars.h"
#include "../SDK/Localize.h"
#include "../SDK/Surface.h"
#include "../SDK/Vector.h"
#include "../SDK/WeaponData.h"

static constexpr bool worldToScreen(const Vector& in, Vector& out) noexcept
{
    const auto& matrix = interfaces->engine->worldToScreenMatrix();
    float w = matrix._41 * in.x + matrix._42 * in.y + matrix._43 * in.z + matrix._44;

    if (w > 0.001f) {
        const auto [width, height] = interfaces->surface->getScreenSize();
        out.x = width / 2 * (1 + (matrix._11 * in.x + matrix._12 * in.y + matrix._13 * in.z + matrix._14) / w);
        out.y = height / 2 * (1 - (matrix._21 * in.x + matrix._22 * in.y + matrix._23 * in.z + matrix._24) / w);
        out.z = 0.0f;
        return true;
    }
    return false;
}

static void renderSnaplines(Entity* entity, const Config::Esp::Shared& config) noexcept
{
    if (!config.snaplines.enabled)
        return;

    Vector position;
    if (!worldToScreen(entity->getAbsOrigin(), position))
        return;

    if (config.snaplines.rainbow)
        interfaces->surface->setDrawColor(rainbowColor(memory->globalVars->realtime, config.snaplines.rainbowSpeed));
    else
        interfaces->surface->setDrawColor(config.snaplines.color);

    const auto [width, height] = interfaces->surface->getScreenSize();
    interfaces->surface->drawLine(width / 2, height, static_cast<int>(position.x), static_cast<int>(position.y));
}

static void renderEyeTraces(Entity* entity, const Config::Esp::Player& config) noexcept
{
    if (config.eyeTraces.enabled) {
        constexpr float maxRange{ 8192.0f };

        auto eyeAngles = entity->eyeAngles();
        Vector viewAngles{ cos(degreesToRadians(eyeAngles.x)) * cos(degreesToRadians(eyeAngles.y)) * maxRange,
                           cos(degreesToRadians(eyeAngles.x)) * sin(degreesToRadians(eyeAngles.y)) * maxRange,
                          -sin(degreesToRadians(eyeAngles.x)) * maxRange };
        static Trace trace;
        Vector headPosition{ entity->getBonePosition(8) };
        interfaces->engineTrace->traceRay({ headPosition, headPosition + viewAngles }, 0x46004009, { entity }, trace);
        Vector start, end;
        if (worldToScreen(trace.startpos, start) && worldToScreen(trace.endpos, end)) {
            if (config.eyeTraces.rainbow)
                interfaces->surface->setDrawColor(rainbowColor(memory->globalVars->realtime, config.eyeTraces.rainbowSpeed));
            else
                interfaces->surface->setDrawColor(config.eyeTraces.color);

            interfaces->surface->drawLine(start.x, start.y, end.x, end.y);
        }
    }
}

static void renderPositionedText(unsigned font, const wchar_t* text, std::pair<float, float&> position) noexcept
{
    interfaces->surface->setTextFont(font);
    interfaces->surface->setTextPosition(position.first, position.second);
    position.second += interfaces->surface->getTextSize(font, text).second;
    interfaces->surface->printText(text);
}

struct BoundingBox {
    float x0, y0;
    float x1, y1;
    Vector vertices[8];

    BoundingBox(Entity* entity) noexcept
    {
        const auto [width, height] = interfaces->surface->getScreenSize();

        x0 = static_cast<float>(width * 2);
        y0 = static_cast<float>(height * 2);
        x1 = -x0;
        y1 = -y0;

        const auto& mins = entity->getCollideable()->obbMins();
        const auto& maxs = entity->getCollideable()->obbMaxs();

        for (int i = 0; i < 8; ++i) {
            const Vector point{ i & 1 ? maxs.x : mins.x,
                                i & 2 ? maxs.y : mins.y,
                                i & 4 ? maxs.z : mins.z };

            if (!worldToScreen(point.transform(entity->coordinateFrame()), vertices[i])) {
                valid = false;
                return;
            }
            x0 = std::min(x0, vertices[i].x);
            y0 = std::min(y0, vertices[i].y);
            x1 = std::max(x1, vertices[i].x);
            y1 = std::max(y1, vertices[i].y);
        }
        valid = true;
    }

    operator bool() noexcept
    {
        return valid;
    }
private:
    bool valid;
};

static void renderBox(const BoundingBox& bbox, const Config::Esp::Shared& config) noexcept
{
    if (config.box.enabled) {
        if (config.box.rainbow)
            interfaces->surface->setDrawColor(rainbowColor(memory->globalVars->realtime, config.box.rainbowSpeed));
        else
            interfaces->surface->setDrawColor(config.box.color);

        switch (config.boxType) {
        case 0:
            interfaces->surface->drawOutlinedRect(bbox.x0, bbox.y0, bbox.x1, bbox.y1);

            if (config.outline.enabled) {
                if (config.outline.rainbow)
                    interfaces->surface->setDrawColor(rainbowColor(memory->globalVars->realtime, config.outline.rainbowSpeed));
                else
                    interfaces->surface->setDrawColor(config.outline.color);

                interfaces->surface->drawOutlinedRect(bbox.x0 + 1, bbox.y0 + 1, bbox.x1 - 1, bbox.y1 - 1);
                interfaces->surface->drawOutlinedRect(bbox.x0 - 1, bbox.y0 - 1, bbox.x1 + 1, bbox.y1 + 1);
            }
            break;
        case 1:
            interfaces->surface->drawLine(bbox.x0, bbox.y0, bbox.x0, bbox.y0 + fabsf(bbox.y1 - bbox.y0) / 4);
            interfaces->surface->drawLine(bbox.x0, bbox.y0, bbox.x0 + fabsf(bbox.x1 - bbox.x0) / 4, bbox.y0);
            interfaces->surface->drawLine(bbox.x1, bbox.y0, bbox.x1 - fabsf(bbox.x1 - bbox.x0) / 4, bbox.y0);
            interfaces->surface->drawLine(bbox.x1, bbox.y0, bbox.x1, bbox.y0 + fabsf(bbox.y1 - bbox.y0) / 4);
            interfaces->surface->drawLine(bbox.x0, bbox.y1, bbox.x0, bbox.y1 - fabsf(bbox.y1 - bbox.y0) / 4);
            interfaces->surface->drawLine(bbox.x0, bbox.y1, bbox.x0 + fabsf(bbox.x1 - bbox.x0) / 4, bbox.y1);
            interfaces->surface->drawLine(bbox.x1, bbox.y1, bbox.x1 - fabsf(bbox.x1 - bbox.x0) / 4, bbox.y1);
            interfaces->surface->drawLine(bbox.x1, bbox.y1, bbox.x1, bbox.y1 - fabsf(bbox.y1 - bbox.y0) / 4);

            if (config.outline.enabled) {
                if (config.outline.rainbow)
                    interfaces->surface->setDrawColor(rainbowColor(memory->globalVars->realtime, config.outline.rainbowSpeed));
                else
                    interfaces->surface->setDrawColor(config.outline.color);

                // TODO: get rid of fabsf()

                interfaces->surface->drawLine(bbox.x0 - 1, bbox.y0 - 1, bbox.x0 - 1, bbox.y0 + fabsf(bbox.y1 - bbox.y0) / 4);
                interfaces->surface->drawLine(bbox.x0 - 1, bbox.y0 - 1, bbox.x0 + fabsf(bbox.x1 - bbox.x0) / 4, bbox.y0 - 1);
                interfaces->surface->drawLine(bbox.x1 + 1, bbox.y0 - 1, bbox.x1 - fabsf(bbox.x1 - bbox.x0) / 4, bbox.y0 - 1);
                interfaces->surface->drawLine(bbox.x1 + 1, bbox.y0 - 1, bbox.x1 + 1, bbox.y0 + fabsf(bbox.y1 - bbox.y0) / 4);
                interfaces->surface->drawLine(bbox.x0 - 1, bbox.y1 + 1, bbox.x0 - 1, bbox.y1 - fabsf(bbox.y1 - bbox.y0) / 4);
                interfaces->surface->drawLine(bbox.x0 - 1, bbox.y1 + 1, bbox.x0 + fabsf(bbox.x1 - bbox.x0) / 4, bbox.y1 + 1);
                interfaces->surface->drawLine(bbox.x1 + 1, bbox.y1 + 1, bbox.x1 - fabsf(bbox.x1 - bbox.x0) / 4, bbox.y1 + 1);
                interfaces->surface->drawLine(bbox.x1 + 1, bbox.y1 + 1, bbox.x1 + 1, bbox.y1 - fabsf(bbox.y1 - bbox.y0) / 4);


                interfaces->surface->drawLine(bbox.x0 + 1, bbox.y0 + 1, bbox.x0 + 1, bbox.y0 + fabsf(bbox.y1 - bbox.y0) / 4);
                interfaces->surface->drawLine(bbox.x0 + 2, bbox.y0 + 1, bbox.x0 + fabsf(bbox.x1 - bbox.x0) / 4, bbox.y0 + 1);


                interfaces->surface->drawLine(bbox.x1 - 1, bbox.y0 + 1, bbox.x1 - fabsf(bbox.x1 - bbox.x0) / 4, (bbox.y0 + 1));
                interfaces->surface->drawLine(bbox.x1 - 1, bbox.y0 + 1, bbox.x1 - 1, bbox.y0 + fabsf(bbox.y1 - bbox.y0) / 4);

                interfaces->surface->drawLine(bbox.x0 + 1, bbox.y1 - 1, bbox.x0 + 1, (bbox.y1) - fabsf(bbox.y1 - bbox.y0) / 4);
                interfaces->surface->drawLine(bbox.x0 + 1, bbox.y1 - 1, bbox.x0 + fabsf(bbox.x1 - bbox.x0) / 4, bbox.y1 - 1);

                interfaces->surface->drawLine(bbox.x1 - 1, bbox.y1 - 1, bbox.x1 - fabsf(bbox.x1 - bbox.x0) / 4, bbox.y1 - 1);
                interfaces->surface->drawLine(bbox.x1 - 1, bbox.y1 - 2, (bbox.x1 - 1), (bbox.y1 - 1) - fabsf(bbox.y1 - bbox.y0) / 4);

                interfaces->surface->drawLine(bbox.x0 - 1, fabsf((bbox.y1 - bbox.y0) / 4) + bbox.y0, bbox.x0 + 2, fabsf((bbox.y1 - bbox.y0) / 4) + bbox.y0);
                interfaces->surface->drawLine(bbox.x1 + 1, fabsf((bbox.y1 - bbox.y0) / 4) + bbox.y0, bbox.x1 - 2, fabsf((bbox.y1 - bbox.y0) / 4) + bbox.y0);
                interfaces->surface->drawLine(bbox.x0 - 1, fabsf((bbox.y1 - bbox.y0) * 3 / 4) + bbox.y0, bbox.x0 + 2, fabsf((bbox.y1 - bbox.y0) * 3 / 4) + bbox.y0);
                interfaces->surface->drawLine(bbox.x1 + 1, fabsf((bbox.y1 - bbox.y0) * 3 / 4) + bbox.y0, bbox.x1 - 2, fabsf((bbox.y1 - bbox.y0) * 3 / 4) + bbox.y0);
                interfaces->surface->drawLine(fabsf((bbox.x1 - bbox.x0) / 4) + bbox.x0, bbox.y0 + 1, fabsf((bbox.x1 - bbox.x0) / 4) + bbox.x0, bbox.y0 - 2);
                interfaces->surface->drawLine(fabsf((bbox.x1 - bbox.x0) / 4) + bbox.x0, bbox.y1 + 1, fabsf((bbox.x1 - bbox.x0) / 4) + bbox.x0, bbox.y1 - 2);
                interfaces->surface->drawLine(fabsf((bbox.x1 - bbox.x0) * 3 / 4) + bbox.x0, bbox.y0 + 1, fabsf((bbox.x1 - bbox.x0) * 3 / 4) + bbox.x0, bbox.y0 - 2);
                interfaces->surface->drawLine(fabsf((bbox.x1 - bbox.x0) * 3 / 4) + bbox.x0, bbox.y1 + 1, fabsf((bbox.x1 - bbox.x0) * 3 / 4) + bbox.x0, bbox.y1 - 2);
            }
            break;
        case 2:
            for (int i = 0; i < 8; i++) {
                for (int j = 1; j <= 4; j <<= 1) {
                    if (!(i & j))
                        interfaces->surface->drawLine(bbox.vertices[i].x, bbox.vertices[i].y, bbox.vertices[i + j].x, bbox.vertices[i + j].y);
                }
            }
            break;
        case 3:
            for (int i = 0; i < 8; i++) {
                for (int j = 1; j <= 4; j <<= 1) {
                    if (!(i & j)) {
                        interfaces->surface->drawLine(bbox.vertices[i].x, bbox.vertices[i].y, bbox.vertices[i].x + (bbox.vertices[i + j].x - bbox.vertices[i].x) * 0.25f, bbox.vertices[i].y + (bbox.vertices[i + j].y - bbox.vertices[i].y) * 0.25f);
                        interfaces->surface->drawLine(bbox.vertices[i].x + (bbox.vertices[i + j].x - bbox.vertices[i].x) * 0.75f, bbox.vertices[i].y + (bbox.vertices[i + j].y - bbox.vertices[i].y) * 0.75f, bbox.vertices[i + j].x, bbox.vertices[i + j].y);
                    }
                }
            }
            break;
        }
    }
}

static void renderPlayerBox(Entity* entity, const Config::Esp::Player& config) noexcept
{
    if (BoundingBox bbox{ entity }) {
        renderBox(bbox, config);

        float drawPositionLeft = bbox.x0 - 5;
        float drawPositionRight = bbox.x1 + 8;
        float drawPositionBottom = 3.5f;
        float drawPositionBottomEh = 6.5f;
        float drawPositionX = bbox.x0 - 5;


        if (config.healthBar.enabled) {
            static auto gameType{ interfaces->cvar->findVar("game_type") };
            static auto survivalMaxHealth{ interfaces->cvar->findVar("sv_dz_player_max_health") };

            const auto maxHealth{ (std::max)((gameType->getInt() == 6 ? survivalMaxHealth->getInt() : 100), entity->health()) };

            if (config.healthBar.rainbow)
                interfaces->surface->setDrawColor(rainbowColor(memory->globalVars->realtime, config.healthBar.rainbowSpeed));
            else
                interfaces->surface->setDrawColor(config.healthBar.color);

            if (config.hpside == 0) {
                interfaces->surface->drawFilledRect(drawPositionLeft - 3, bbox.y0 + abs(bbox.y1 - bbox.y0) * (maxHealth - entity->health()) / static_cast<float>(maxHealth), drawPositionLeft, bbox.y1);
                if (config.outline.enabled) {
                    if (config.outline.rainbow)
                        interfaces->surface->setDrawColor(rainbowColor(memory->globalVars->realtime, config.outline.rainbowSpeed));
                    else
                        interfaces->surface->setDrawColor(config.outline.color);

                    interfaces->surface->drawOutlinedRect(drawPositionLeft - 4, bbox.y0 - 1, drawPositionLeft + 1, bbox.y1 + 1);
                }
                drawPositionLeft -= 7;
            }
            if (config.hpside == 1) {
                interfaces->surface->drawFilledRect(bbox.x0, bbox.y1 + drawPositionBottom, bbox.x0 + abs(bbox.x1 - bbox.x0) * (entity->health()) / 100.f, bbox.y1 + drawPositionBottomEh);

                if (config.outline.enabled) {
                    if (config.outline.rainbow)
                        interfaces->surface->setDrawColor(rainbowColor(memory->globalVars->realtime, config.outline.rainbowSpeed));
                    else
                        interfaces->surface->setDrawColor(config.outline.color);

                    interfaces->surface->drawOutlinedRect(bbox.x0, bbox.y1 + drawPositionBottom - 1, bbox.x0 + abs(bbox.x1 - bbox.x0) * (entity->health()) / 100.f, bbox.y1 + drawPositionBottomEh + 1);
                }
                drawPositionBottom += 7;
                drawPositionBottomEh += 7;
            }
            if (config.hpside == 2) {
                interfaces->surface->drawFilledRect(drawPositionRight - 3, bbox.y0 + abs(bbox.y1 - bbox.y0) * (maxHealth - entity->health()) / static_cast<float>(maxHealth), drawPositionRight, bbox.y1);
                if (config.outline.enabled) {
                    if (config.outline.rainbow)
                        interfaces->surface->setDrawColor(rainbowColor(memory->globalVars->realtime, config.outline.rainbowSpeed));
                    else
                        interfaces->surface->setDrawColor(config.outline.color);

                    interfaces->surface->drawOutlinedRect(drawPositionRight - 4, bbox.y0 - 1, drawPositionRight + 1, bbox.y1 + 1);
                }
                drawPositionRight += 7;
            }

        }

        if (config.armorBar.enabled) {
            if (config.armorBar.rainbow)
                interfaces->surface->setDrawColor(rainbowColor(memory->globalVars->realtime, config.armorBar.rainbowSpeed));
            else
                interfaces->surface->setDrawColor(config.armorBar.color);

            if (config.armorside == 0) {
                interfaces->surface->drawFilledRect(drawPositionLeft - 3, bbox.y0 + abs(bbox.y1 - bbox.y0) * (100.0f - entity->armor()) / 100.0f, drawPositionLeft, bbox.y1);

                if (config.outline.enabled) {
                    if (config.outline.rainbow)
                        interfaces->surface->setDrawColor(rainbowColor(memory->globalVars->realtime, config.outline.rainbowSpeed));
                    else
                        interfaces->surface->setDrawColor(config.outline.color);

                    interfaces->surface->drawOutlinedRect(drawPositionLeft - 4, bbox.y0 - 1, drawPositionLeft + 1, bbox.y1 + 1);
                }
                drawPositionLeft -= 7;
            }
            if (config.armorside == 1) {
                interfaces->surface->drawFilledRect(bbox.x0, bbox.y1 + drawPositionBottom, bbox.x0 + abs(bbox.x1 - bbox.x0) * (entity->armor()) / 100.f, bbox.y1 + drawPositionBottomEh);

                if (config.outline.enabled) {
                    if (config.outline.rainbow)
                        interfaces->surface->setDrawColor(rainbowColor(memory->globalVars->realtime, config.outline.rainbowSpeed));
                    else
                        interfaces->surface->setDrawColor(config.outline.color);

                    interfaces->surface->drawOutlinedRect(bbox.x0, bbox.y1 + drawPositionBottom - 1, bbox.x0 + abs(bbox.x1 - bbox.x0) * (entity->armor()) / 100.f, bbox.y1 + drawPositionBottomEh + 1);
                }
                drawPositionBottom += 7;
                drawPositionBottomEh += 7;
            }
            if (config.armorside == 2) {
                interfaces->surface->drawFilledRect(drawPositionRight - 3, bbox.y0 + abs(bbox.y1 - bbox.y0) * (100.0f - entity->armor()) / 100.0f, drawPositionRight, bbox.y1);

                if (config.outline.enabled) {
                    if (config.outline.rainbow)
                        interfaces->surface->setDrawColor(rainbowColor(memory->globalVars->realtime, config.outline.rainbowSpeed));
                    else
                        interfaces->surface->setDrawColor(config.outline.color);

                    interfaces->surface->drawOutlinedRect(drawPositionRight - 4, bbox.y0 - 1, drawPositionRight + 1, bbox.y1 + 1);
                }
                drawPositionRight += 7;
            }

        }

        if (config.name.enabled) {
            if (PlayerInfo playerInfo; interfaces->engine->getPlayerInfo(entity->index(), playerInfo)) {
                if (wchar_t name[128]; MultiByteToWideChar(CP_UTF8, 0, playerInfo.name, -1, name, 128)) {
                    const auto [width, height] { interfaces->surface->getTextSize(config.font, name) };
                    interfaces->surface->setTextFont(config.font);
                    if (config.name.rainbow)
                        interfaces->surface->setTextColor(rainbowColor(memory->globalVars->realtime, config.name.rainbowSpeed));
                    else
                        interfaces->surface->setTextColor(config.name.color);

                    interfaces->surface->setTextPosition((bbox.x0 + bbox.x1 - width) / 2, bbox.y0 - 5 - height);
                    interfaces->surface->printText(name);
                }
            }
        }

        if (const auto activeWeapon{ entity->getActiveWeapon() };  config.activeWeapon.enabled && activeWeapon) {
            const auto name{ interfaces->localize->find(activeWeapon->getWeaponData()->name) };
            const auto [width, height] { interfaces->surface->getTextSize(config.font, name) };
            interfaces->surface->setTextFont(config.font);
            if (config.activeWeapon.rainbow)
                interfaces->surface->setTextColor(rainbowColor(memory->globalVars->realtime, config.activeWeapon.rainbowSpeed));
            else
                interfaces->surface->setTextColor(config.activeWeapon.color);

            if (config.hpside == 1) {
                if (config.armorside == 1) {
                    interfaces->surface->setTextPosition((bbox.x0 + bbox.x1 - width) / 2, bbox.y1 + 15);
                } else {
                    interfaces->surface->setTextPosition((bbox.x0 + bbox.x1 - width) / 2, bbox.y1 + 10);
                }
            } else {
                interfaces->surface->setTextPosition((bbox.x0 + bbox.x1 - width) / 2, bbox.y1 + 5);
            }
            interfaces->surface->printText(name);
        }

        float drawPositionY = bbox.y0;

        if (config.health.enabled) {
            if (config.health.rainbow)
                interfaces->surface->setTextColor(rainbowColor(memory->globalVars->realtime, config.health.rainbowSpeed));
            else
                interfaces->surface->setTextColor(config.health.color);

            if (config.hpside == 2) {
                if (config.armorside == 2) {
                    renderPositionedText(config.font, (std::to_wstring(entity->health()) + L" HP").c_str(), { bbox.x1 + 15, drawPositionY });
                } else {
                    renderPositionedText(config.font, (std::to_wstring(entity->health()) + L" HP").c_str(), { bbox.x1 + 10, drawPositionY });
                }
            } else {
                renderPositionedText(config.font, (std::to_wstring(entity->health()) + L" HP").c_str(), { bbox.x1 + 5, drawPositionY });
            }
        }

        if (config.armor.enabled) {
            if (config.armor.rainbow)
                interfaces->surface->setTextColor(rainbowColor(memory->globalVars->realtime, config.armor.rainbowSpeed));
            else
                interfaces->surface->setTextColor(config.armor.color);

            if (config.hpside == 2) {
                if (config.armorside == 2) {
                    renderPositionedText(config.font, (std::to_wstring(entity->armor()) + L" AR").c_str(), { bbox.x1 + 15, drawPositionY });
                } else {
                    renderPositionedText(config.font, (std::to_wstring(entity->armor()) + L" AR").c_str(), { bbox.x1 + 10, drawPositionY });
                }
            } else {
                renderPositionedText(config.font, (std::to_wstring(entity->armor()) + L" AR").c_str(), { bbox.x1 + 5, drawPositionY });
            }
        }

        if (config.money.enabled) {
            if (config.money.rainbow)
                interfaces->surface->setTextColor(rainbowColor(memory->globalVars->realtime, config.money.rainbowSpeed));
            else
                interfaces->surface->setTextColor(config.money.color);

            if (config.hpside == 2) {
                if (config.armorside == 2) {
                    renderPositionedText(config.font, (L'$' + std::to_wstring(entity->account())).c_str(), { bbox.x1 + 15, drawPositionY });
                } else {
                    renderPositionedText(config.font, (L'$' + std::to_wstring(entity->account())).c_str(), { bbox.x1 + 10, drawPositionY });
                }
            } else {
                renderPositionedText(config.font, (L'$' + std::to_wstring(entity->account())).c_str(), { bbox.x1 + 5, drawPositionY });
            }

        }

        if (config.distance.enabled && localPlayer) {
            if (config.distance.rainbow)
                interfaces->surface->setTextColor(rainbowColor(memory->globalVars->realtime, config.distance.rainbowSpeed));
            else
                interfaces->surface->setTextColor(config.distance.color);

            if (config.hpside == 2) {
                if (config.armorside == 2) {
                    renderPositionedText(config.font, (std::wostringstream{ } << std::fixed << std::showpoint << std::setprecision(2) << (entity->getAbsOrigin() - localPlayer->getAbsOrigin()).length() * 0.0254f << L'm').str().c_str(), { bbox.x1 + 15, drawPositionY });
                } else {
                    renderPositionedText(config.font, (std::wostringstream{ } << std::fixed << std::showpoint << std::setprecision(2) << (entity->getAbsOrigin() - localPlayer->getAbsOrigin()).length() * 0.0254f << L'm').str().c_str(), { bbox.x1 + 10, drawPositionY });
                }
            } else {
                renderPositionedText(config.font, (std::wostringstream{ } << std::fixed << std::showpoint << std::setprecision(2) << (entity->getAbsOrigin() - localPlayer->getAbsOrigin()).length() * 0.0254f << L'm').str().c_str(), { bbox.x1 + 5, drawPositionY });
            }
        }
    }
}

static void renderWeaponBox(Entity* entity, const Config::Esp::Weapon& config) noexcept
{
    BoundingBox bbox{ entity };

    if (!bbox)
        return;

    renderBox(bbox, config);

    if (config.name.enabled) {
        const auto name{ interfaces->localize->find(entity->getWeaponData()->name) };
        const auto [width, height] { interfaces->surface->getTextSize(config.font, name) };
        interfaces->surface->setTextFont(config.font);
        if (config.name.rainbow)
            interfaces->surface->setTextColor(rainbowColor(memory->globalVars->realtime, config.name.rainbowSpeed));
        else
            interfaces->surface->setTextColor(config.name.color);

        interfaces->surface->setTextPosition((bbox.x0 + bbox.x1 - width) / 2, bbox.y0 - 10);
        interfaces->surface->printText(name);
    }
    if (config.ammo.enabled)
    {
        int clip = entity->clip();
        int reserveAmmo = entity->reserveAmmoCount();
        const auto text{ std::to_wstring(clip) + L" / " + std::to_wstring(reserveAmmo) };
        const auto [width, height] { interfaces->surface->getTextSize(config.font, text.c_str()) };
        interfaces->surface->setTextFont(config.font);
        if (config.ammo.rainbow)
            interfaces->surface->setTextColor(rainbowColor(memory->globalVars->realtime, config.ammo.rainbowSpeed));
        else
            interfaces->surface->setTextColor(config.ammo.color);
        interfaces->surface->setTextPosition((bbox.x0 + bbox.x1 - width) / 2, bbox.y1 + 6);
        if (clip > -1)
        {
            interfaces->surface->printText(text);
        }
    }

    float drawPositionY = bbox.y0;

    if (!localPlayer || !config.distance.enabled)
        return;

    if (config.distance.rainbow)
        interfaces->surface->setTextColor(rainbowColor(memory->globalVars->realtime, config.distance.rainbowSpeed));
    else
        interfaces->surface->setTextColor(config.distance.color);

    renderPositionedText(config.font, (std::wostringstream{ } << std::fixed << std::showpoint << std::setprecision(2) << (entity->getAbsOrigin() - localPlayer->getAbsOrigin()).length() * 0.0254f << L'm').str().c_str(), { bbox.x1 + 5, drawPositionY });
}

static void renderEntityBox(Entity* entity, const Config::Esp::Shared& config, const wchar_t* name) noexcept
{
    if (BoundingBox bbox{ entity }) {
        renderBox(bbox, config);

        if (config.name.enabled) {
            const auto [width, height] { interfaces->surface->getTextSize(config.font, name) };
            interfaces->surface->setTextFont(config.font);
            if (config.name.rainbow)
                interfaces->surface->setTextColor(rainbowColor(memory->globalVars->realtime, config.name.rainbowSpeed));
            else
                interfaces->surface->setTextColor(config.name.color);

            interfaces->surface->setTextPosition((bbox.x0 + bbox.x1 - width) / 2, bbox.y1 + 5);
            interfaces->surface->printText(name);
        }

        float drawPositionY = bbox.y0;

        if (!localPlayer || !config.distance.enabled)
            return;

        if (config.distance.rainbow)
            interfaces->surface->setTextColor(rainbowColor(memory->globalVars->realtime, config.distance.rainbowSpeed));
        else
            interfaces->surface->setTextColor(config.distance.color);

        renderPositionedText(config.font, (std::wostringstream{ } << std::fixed << std::showpoint << std::setprecision(2) << (entity->getAbsOrigin() - localPlayer->getAbsOrigin()).length() * 0.0254f << L'm').str().c_str(), { bbox.x1 + 5, drawPositionY });
    }
}

static void renderHeadDot(Entity* entity, const Config::Esp::Player& config) noexcept
{
    if (!config.headDot.enabled)
        return;

    if (!localPlayer)
        return;

    Vector head;
    if (!worldToScreen(entity->getBonePosition(8), head))
        return;

    if (config.headDot.rainbow)
        interfaces->surface->setDrawColor(rainbowColor(memory->globalVars->realtime, config.headDot.rainbowSpeed));
    else
        interfaces->surface->setDrawColor(config.headDot.color);

    interfaces->surface->drawCircle(head.x, head.y, 0, static_cast<int>(100 / std::sqrt((localPlayer->getAbsOrigin() - entity->getAbsOrigin()).length())));
}

enum EspId {
    ALLIES_ALL = 0,
    ALLIES_VISIBLE,
    ALLIES_OCCLUDED,

    ENEMIES_ALL,
    ENEMIES_VISIBLE,
    ENEMIES_OCCLUDED
};

static bool isInRange(Entity* entity, float maxDistance) noexcept
{
    if (!localPlayer)
        return false;

    return maxDistance == 0.0f || (entity->getAbsOrigin() - localPlayer->getAbsOrigin()).length() * 0.0254f <= maxDistance;
}

static constexpr bool renderPlayerEsp(Entity* entity, EspId id) noexcept
{
    if (localPlayer && (config->esp.players[id].enabled ||
        config->esp.players[id].deadesp && !localPlayer->isAlive()) &&
        isInRange(entity, config->esp.players[id].maxDistance)) {
        renderSnaplines(entity, config->esp.players[id]);
        renderEyeTraces(entity, config->esp.players[id]);
        renderPlayerBox(entity, config->esp.players[id]);
        renderHeadDot(entity, config->esp.players[id]);
    }
    return config->esp.players[id].enabled;
}

static void renderWeaponEsp(Entity* entity) noexcept
{
    if (config->esp.weapon.enabled && isInRange(entity, config->esp.weapon.maxDistance)) {
        renderWeaponBox(entity, config->esp.weapon);
        renderSnaplines(entity, config->esp.weapon);
    }
}

static constexpr void renderEntityEsp(Entity* entity, const Config::Esp::Shared& config, const wchar_t* name) noexcept
{
    if (config.enabled && isInRange(entity, config.maxDistance)) {
        renderEntityBox(entity, config, name);
        renderSnaplines(entity, config);
    }
}

void Esp::render() noexcept
{
    if (interfaces->engine->isInGame()) {
        if (!localPlayer)
            return;

        const auto observerTarget = localPlayer->getObserverTarget();

        for (int i = 1; i <= interfaces->engine->getMaxClients(); i++) {
            auto entity = interfaces->entityList->getEntity(i);
            if (!entity || entity == localPlayer.get() || entity == observerTarget
                || entity->isDormant() || !entity->isAlive())
                continue;

            if (!entity->isOtherEnemy(localPlayer.get())) {
                if (!renderPlayerEsp(entity, ALLIES_ALL)) {
                    if (entity->isVisible())
                        renderPlayerEsp(entity, ALLIES_VISIBLE);
                    else
                        renderPlayerEsp(entity, ALLIES_OCCLUDED);
                }
            } else if (!renderPlayerEsp(entity, ENEMIES_ALL)) {
                if (entity->isVisible())
                    renderPlayerEsp(entity, ENEMIES_VISIBLE);
                else
                    renderPlayerEsp(entity, ENEMIES_OCCLUDED);
            }
        }

        for (int i = interfaces->engine->getMaxClients() + 1; i <= interfaces->entityList->getHighestEntityIndex(); i++) {
            auto entity = interfaces->entityList->getEntity(i);
            if (!entity || entity->isDormant())
                continue;

            if (entity->isWeapon() && entity->ownerEntity() == -1)
                renderWeaponEsp(entity);
            else {
                switch (entity->getClientClass()->classId) {
                case ClassId::Dronegun: {
                    renderEntityEsp(entity, config->esp.dangerZone[0], std::wstring{ interfaces->localize->find("#SFUI_WPNHUD_AutoSentry") }.append(L" (").append(std::to_wstring(entity->sentryHealth())).append(L" HP)").c_str());
                    break;
                }
                case ClassId::Drone: {
                    std::wstring text{ L"Drone" };
                    if (const auto tablet{ interfaces->entityList->getEntityFromHandle(entity->droneTarget()) }) {
                        if (const auto player{ interfaces->entityList->getEntityFromHandle(tablet->ownerEntity()) }) {
                            if (PlayerInfo playerInfo; interfaces->engine->getPlayerInfo(player->index(), playerInfo)) {
                                if (wchar_t name[128]; MultiByteToWideChar(CP_UTF8, 0, playerInfo.name, -1, name, 128)) {
                                    text += L" -> ";
                                    text += name;
                                }
                            }
                        }
                    }
                    renderEntityEsp(entity, config->esp.dangerZone[1], text.c_str());
                    break;
                }
                case ClassId::Cash:
                    renderEntityEsp(entity, config->esp.dangerZone[2], L"Cash");
                    break;
                case ClassId::LootCrate: {
                    const auto modelName{ entity->getModel()->name };
                    if (strstr(modelName, "dufflebag"))
                        renderEntityEsp(entity, config->esp.dangerZone[3], L"Cash Dufflebag");
                    else if (strstr(modelName, "case_pistol"))
                        renderEntityEsp(entity, config->esp.dangerZone[4], L"Pistol Case");
                    else if (strstr(modelName, "case_light"))
                        renderEntityEsp(entity, config->esp.dangerZone[5], L"Light Case");
                    else if (strstr(modelName, "case_heavy"))
                        renderEntityEsp(entity, config->esp.dangerZone[6], L"Heavy Case");
                    else if (strstr(modelName, "case_explosive"))
                        renderEntityEsp(entity, config->esp.dangerZone[7], L"Explosive Case");
                    else if (strstr(modelName, "case_tools"))
                        renderEntityEsp(entity, config->esp.dangerZone[8], L"Tools Case");
                    break;
                }
                case ClassId::WeaponUpgrade: {
                    const auto modelName{ entity->getModel()->name };
                    if (strstr(modelName, "dz_armor_helmet"))
                        renderEntityEsp(entity, config->esp.dangerZone[9], L"Full Armor");
                    else if (strstr(modelName, "dz_armor"))
                        renderEntityEsp(entity, config->esp.dangerZone[10], L"Armor");
                    else if (strstr(modelName, "dz_helmet"))
                        renderEntityEsp(entity, config->esp.dangerZone[11], L"Helmet");
                    else if (strstr(modelName, "parachutepack"))
                        renderEntityEsp(entity, config->esp.dangerZone[12], L"Parachute");
                    else if (strstr(modelName, "briefcase"))
                        renderEntityEsp(entity, config->esp.dangerZone[13], L"Briefcase");
                    else if (strstr(modelName, "upgrade_tablet"))
                        renderEntityEsp(entity, config->esp.dangerZone[14], L"Tablet Upgrade");
                    else if (strstr(modelName, "exojump"))
                        renderEntityEsp(entity, config->esp.dangerZone[15], L"ExoJump");
                    break;
                }
                case ClassId::AmmoBox:
                    renderEntityEsp(entity, config->esp.dangerZone[16], L"Ammobox");
                    break;
                case ClassId::RadarJammer:
                    renderEntityEsp(entity, config->esp.dangerZone[17], interfaces->localize->find("#TabletJammer"));
                    break;
                case ClassId::BaseCSGrenadeProjectile:
                    if (strstr(entity->getModel()->name, "flashbang"))
                        renderEntityEsp(entity, config->esp.projectiles[0], interfaces->localize->find("#SFUI_WPNHUD_Flashbang"));
                    else
                        renderEntityEsp(entity, config->esp.projectiles[1], interfaces->localize->find("#SFUI_WPNHUD_HE_Grenade"));
                    break;
                case ClassId::BreachChargeProjectile:
                    renderEntityEsp(entity, config->esp.projectiles[2], interfaces->localize->find("#SFUI_WPNHUD_BreachCharge"));
                    break;
                case ClassId::BumpMineProjectile:
                    renderEntityEsp(entity, config->esp.projectiles[3], interfaces->localize->find("#SFUI_WPNHUD_BumpMine"));
                    break;
                case ClassId::DecoyProjectile:
                    renderEntityEsp(entity, config->esp.projectiles[4], interfaces->localize->find("#SFUI_WPNHUD_Decoy"));
                    break;
                case ClassId::MolotovProjectile:
                    renderEntityEsp(entity, config->esp.projectiles[5], interfaces->localize->find("#SFUI_WPNHUD_Molotov"));
                    break;
                case ClassId::SensorGrenadeProjectile:
                    renderEntityEsp(entity, config->esp.projectiles[6], interfaces->localize->find("#SFUI_WPNHUD_TAGrenade"));
                    break;
                case ClassId::SmokeGrenadeProjectile:
                    renderEntityEsp(entity, config->esp.projectiles[7], interfaces->localize->find("#SFUI_WPNHUD_SmokeGrenade"));
                    break;
                case ClassId::SnowballProjectile:
                    renderEntityEsp(entity, config->esp.projectiles[8], interfaces->localize->find("#SFUI_WPNHUD_Snowball"));
                    break;
                }
            }
        }
    }
}
