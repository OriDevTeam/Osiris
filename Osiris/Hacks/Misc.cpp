#include <stdio.h>
#include <string>
#include <iostream>

#pragma region J1

using namespace std;

class ogtyfgd {
public:
    bool uoolsgl;
    ogtyfgd();
    bool lsdmephsugdalogaryxcixv(int ynidguzqf);

protected:
    bool gymjdpljbiyge;
    int dltwufwuaztbiab;
    double pubrrz;
    double mhgff;

    double hbhdlnkdwdfdf(int pdlehwwqgpfeyo, int pluogludxot, double hvmjfqxxi, double wmvbh, bool tuhwhmbk, bool uslwrjjcsi, int zxzuuwhrgiwej, string kbwteio, string mkbykslvi);
    void aibwaqzihicfv(bool qesuwjryh);
    void gphbojagcormwoaqh(double skndbjoce);
    double giyiyennukaphgd(string loktiantela, bool umpuq, bool rqyfcokbmzumlo, string ihkmbfht, int jjxrsqcjkqptza, int wkifnjitbmb, double iwkrhlkl, int veltmi);
    int moumuqfrzdepcltmvzn(bool dhuhqiugy, string grccoyqnsleylra, bool bdpxynei, int vmksmca, double scafzwyq, string dpokhyd, double rlmgwbtbgrs, bool lkejpzhhjej, int dfdei, string erysxemhptvea);
    void pvlajvoihrhhcqj(bool oeeywftuq, bool rjkhobfceuycdqr, bool kfksmzlbstbbz, string dyqutdgdzooaqw, bool ovhhfvfbrxuby, double joiebynwsielcu, double rfjjdj, string mzncf, string ghasl, int blpsyrftxedl);
    string fxjxrtkfbfmdgusm(int lamfa, bool ptixdyw, int eyykucwwr, string cadqo, int yywdqngfspyltr, string gubrsdilfwuzwxw, double cdaadzbkg, bool qtyasxiovei, int yhkwg, bool wtyxkc);
    int sfpbpotmpjhuhq(string lbkvkwjbe);

private:
    double enqirmcx;

    void gsezogodczgkanixalv(bool hqndptuissubm, double aifqdymjazgpu, int rkyjgxozkq, double glitfinmmkzauhf, string crbgt, double sdyit, string uvguovikg, bool kfpeefeylmk, bool rqgiff, bool urzstjneqwrwf);
    int yfjvutetcsxzshyhiew(bool fhjpmlwypsrc, double ohjkcgwyhjprkdg, int jjzyeyjv);
    string yowegxfufnygfibg(string wgygicpdvjej);
    bool hveilxzsdbwlvgdcznibcydu(int bckbdmfjddh);

};


void ogtyfgd::gsezogodczgkanixalv(bool hqndptuissubm, double aifqdymjazgpu, int rkyjgxozkq, double glitfinmmkzauhf, string crbgt, double sdyit, string uvguovikg, bool kfpeefeylmk, bool rqgiff, bool urzstjneqwrwf) {
    int xujfvlr = 1257;
    string atsqmljihaexn = "rolbxbdhvmylnjtvodmfmvfmoggwqklroluvjygxwvwcyjecplqivoctjqcyplaqotxoipgmcakwctafxhiajqnmlgp";
    int tfdpnxfigii = 86;
    double rckrycsso = 21950;
    bool vwqcusgoxp = false;
    double jtphwhamx = 86881;
    bool qccgasqsn = true;
    double vdyumtnrmhk = 52400;
    double hzsezyp = 5821;
    int chikxli = 1661;
    if (false == false) {
        int ejteztlc;
        for (ejteztlc = 93; ejteztlc > 0; ejteztlc--) {
            continue;
        }
    }

}

int ogtyfgd::yfjvutetcsxzshyhiew(bool fhjpmlwypsrc, double ohjkcgwyhjprkdg, int jjzyeyjv) {
    string lnbsy = "wustfsaxrksrklwuyybisflcegzuvyorowpnyjs";
    int tfxqpcufhhenuu = 8588;
    string peylfunpceah = "nkxwuxotajofuzqcaiunomununyphpjpldoomznxlfuhsdncufndwjybeerydkszpoormluszi";
    if (string("wustfsaxrksrklwuyybisflcegzuvyorowpnyjs") != string("wustfsaxrksrklwuyybisflcegzuvyorowpnyjs")) {
        int irlprocm;
        for (irlprocm = 40; irlprocm > 0; irlprocm--) {
            continue;
        }
    }
    if (8588 != 8588) {
        int wcpuzppcxi;
        for (wcpuzppcxi = 9; wcpuzppcxi > 0; wcpuzppcxi--) {
            continue;
        }
    }
    if (string("nkxwuxotajofuzqcaiunomununyphpjpldoomznxlfuhsdncufndwjybeerydkszpoormluszi") != string("nkxwuxotajofuzqcaiunomununyphpjpldoomznxlfuhsdncufndwjybeerydkszpoormluszi")) {
        int llrwq;
        for (llrwq = 88; llrwq > 0; llrwq--) {
            continue;
        }
    }
    if (8588 == 8588) {
        int kix;
        for (kix = 30; kix > 0; kix--) {
            continue;
        }
    }
    if (string("nkxwuxotajofuzqcaiunomununyphpjpldoomznxlfuhsdncufndwjybeerydkszpoormluszi") == string("nkxwuxotajofuzqcaiunomununyphpjpldoomznxlfuhsdncufndwjybeerydkszpoormluszi")) {
        int jku;
        for (jku = 3; jku > 0; jku--) {
            continue;
        }
    }
    return 6403;
}

string ogtyfgd::yowegxfufnygfibg(string wgygicpdvjej) {
    bool fpktyzyi = false;
    int nqesafntrpwn = 778;
    int lgsiaiuqm = 1027;
    int swreew = 4405;
    string zzbnus = "vianoufthvzxhucuppazrckptneidekfgxxfoyufezpbnqeqkwrqedrremaozavdercupquqjjewees";
    double rvmpwygai = 25457;
    int hrjlrwvncurn = 1095;
    bool phsjiuwmqalfa = false;
    if (false == false) {
        int kncdnsl;
        for (kncdnsl = 48; kncdnsl > 0; kncdnsl--) {
            continue;
        }
    }
    if (1095 != 1095) {
        int qx;
        for (qx = 50; qx > 0; qx--) {
            continue;
        }
    }
    if (1027 != 1027) {
        int tnsr;
        for (tnsr = 67; tnsr > 0; tnsr--) {
            continue;
        }
    }
    if (1095 != 1095) {
        int ntozimet;
        for (ntozimet = 57; ntozimet > 0; ntozimet--) {
            continue;
        }
    }
    if (false != false) {
        int jhzeiu;
        for (jhzeiu = 87; jhzeiu > 0; jhzeiu--) {
            continue;
        }
    }
    return string("jxuhnmiirfihanmqgj");
}

bool ogtyfgd::hveilxzsdbwlvgdcznibcydu(int bckbdmfjddh) {
    double tyhlirfom = 10817;
    return false;
}

double ogtyfgd::hbhdlnkdwdfdf(int pdlehwwqgpfeyo, int pluogludxot, double hvmjfqxxi, double wmvbh, bool tuhwhmbk, bool uslwrjjcsi, int zxzuuwhrgiwej, string kbwteio, string mkbykslvi) {
    double pxzcmctllinui = 20136;
    double xwnrtjffepoh = 85977;
    string wqpkdmlu = "iapwrjwmgazreqzzqxlwnozxddbkucyfmxcwkjkpssmhqgpppgychujsrfknkuterwenkilqqurxgdkhb";
    string yxyfcfz = "lkxskvndhhvcjqtthjkfjtkg";
    bool kmusitezj = false;
    int lrmhgr = 2072;
    if (2072 != 2072) {
        int jtao;
        for (jtao = 56; jtao > 0; jtao--) {
            continue;
        }
    }
    return 80610;
}

void ogtyfgd::aibwaqzihicfv(bool qesuwjryh) {
    double rpmoukwkyukjsga = 37364;
    if (37364 == 37364) {
        int iqlqhicnvw;
        for (iqlqhicnvw = 71; iqlqhicnvw > 0; iqlqhicnvw--) {
            continue;
        }
    }
    if (37364 != 37364) {
        int qrexoeuw;
        for (qrexoeuw = 44; qrexoeuw > 0; qrexoeuw--) {
            continue;
        }
    }
    if (37364 != 37364) {
        int frvfildmbs;
        for (frvfildmbs = 40; frvfildmbs > 0; frvfildmbs--) {
            continue;
        }
    }

}

void ogtyfgd::gphbojagcormwoaqh(double skndbjoce) {
    string rcvhxhspkcti = "jjsddbdfkodxqvfuwuigvqkmkewyijuluxhxnvnvraquzyudputkqfvnngmxdwsfpoduzxasdewqbkcrybljfkkhtlok";
    if (string("jjsddbdfkodxqvfuwuigvqkmkewyijuluxhxnvnvraquzyudputkqfvnngmxdwsfpoduzxasdewqbkcrybljfkkhtlok") == string("jjsddbdfkodxqvfuwuigvqkmkewyijuluxhxnvnvraquzyudputkqfvnngmxdwsfpoduzxasdewqbkcrybljfkkhtlok")) {
        int sgap;
        for (sgap = 59; sgap > 0; sgap--) {
            continue;
        }
    }
    if (string("jjsddbdfkodxqvfuwuigvqkmkewyijuluxhxnvnvraquzyudputkqfvnngmxdwsfpoduzxasdewqbkcrybljfkkhtlok") != string("jjsddbdfkodxqvfuwuigvqkmkewyijuluxhxnvnvraquzyudputkqfvnngmxdwsfpoduzxasdewqbkcrybljfkkhtlok")) {
        int tikoi;
        for (tikoi = 97; tikoi > 0; tikoi--) {
            continue;
        }
    }
    if (string("jjsddbdfkodxqvfuwuigvqkmkewyijuluxhxnvnvraquzyudputkqfvnngmxdwsfpoduzxasdewqbkcrybljfkkhtlok") != string("jjsddbdfkodxqvfuwuigvqkmkewyijuluxhxnvnvraquzyudputkqfvnngmxdwsfpoduzxasdewqbkcrybljfkkhtlok")) {
        int us;
        for (us = 94; us > 0; us--) {
            continue;
        }
    }
    if (string("jjsddbdfkodxqvfuwuigvqkmkewyijuluxhxnvnvraquzyudputkqfvnngmxdwsfpoduzxasdewqbkcrybljfkkhtlok") == string("jjsddbdfkodxqvfuwuigvqkmkewyijuluxhxnvnvraquzyudputkqfvnngmxdwsfpoduzxasdewqbkcrybljfkkhtlok")) {
        int bsikmasdvh;
        for (bsikmasdvh = 34; bsikmasdvh > 0; bsikmasdvh--) {
            continue;
        }
    }

}

double ogtyfgd::giyiyennukaphgd(string loktiantela, bool umpuq, bool rqyfcokbmzumlo, string ihkmbfht, int jjxrsqcjkqptza, int wkifnjitbmb, double iwkrhlkl, int veltmi) {
    return 79120;
}

int ogtyfgd::moumuqfrzdepcltmvzn(bool dhuhqiugy, string grccoyqnsleylra, bool bdpxynei, int vmksmca, double scafzwyq, string dpokhyd, double rlmgwbtbgrs, bool lkejpzhhjej, int dfdei, string erysxemhptvea) {
    int mgavzboqtgzyx = 1833;
    double kbvwbstvuf = 27771;
    string yqdcgtsexm = "mvetxaylvssqountohfkyw";
    string byfxecroar = "ejeljp";
    int lydgtlpkygi = 7047;
    double vahar = 24319;
    int jdgoasu = 1014;
    int omxwevkh = 627;
    double ueeco = 15197;
    int scwaoobzwavp = 6561;
    if (24319 == 24319) {
        int qpavslklnf;
        for (qpavslklnf = 37; qpavslklnf > 0; qpavslklnf--) {
            continue;
        }
    }
    return 39931;
}

void ogtyfgd::pvlajvoihrhhcqj(bool oeeywftuq, bool rjkhobfceuycdqr, bool kfksmzlbstbbz, string dyqutdgdzooaqw, bool ovhhfvfbrxuby, double joiebynwsielcu, double rfjjdj, string mzncf, string ghasl, int blpsyrftxedl) {
    double jxjfwv = 16573;
    double mardeityb = 17104;
    if (16573 == 16573) {
        int cjeqvdojj;
        for (cjeqvdojj = 43; cjeqvdojj > 0; cjeqvdojj--) {
            continue;
        }
    }
    if (16573 == 16573) {
        int vkai;
        for (vkai = 9; vkai > 0; vkai--) {
            continue;
        }
    }
    if (16573 == 16573) {
        int rrlyxhxn;
        for (rrlyxhxn = 31; rrlyxhxn > 0; rrlyxhxn--) {
            continue;
        }
    }
    if (17104 == 17104) {
        int radd;
        for (radd = 63; radd > 0; radd--) {
            continue;
        }
    }

}

string ogtyfgd::fxjxrtkfbfmdgusm(int lamfa, bool ptixdyw, int eyykucwwr, string cadqo, int yywdqngfspyltr, string gubrsdilfwuzwxw, double cdaadzbkg, bool qtyasxiovei, int yhkwg, bool wtyxkc) {
    int irtcdglscggtbt = 1242;
    if (1242 == 1242) {
        int ducbd;
        for (ducbd = 82; ducbd > 0; ducbd--) {
            continue;
        }
    }
    if (1242 == 1242) {
        int bqeptueiw;
        for (bqeptueiw = 69; bqeptueiw > 0; bqeptueiw--) {
            continue;
        }
    }
    if (1242 == 1242) {
        int ql;
        for (ql = 7; ql > 0; ql--) {
            continue;
        }
    }
    return string("jdupmqzn");
}

int ogtyfgd::sfpbpotmpjhuhq(string lbkvkwjbe) {
    bool txgdmgrbit = false;
    if (false == false) {
        int jssybfpul;
        for (jssybfpul = 59; jssybfpul > 0; jssybfpul--) {
            continue;
        }
    }
    if (false == false) {
        int um;
        for (um = 64; um > 0; um--) {
            continue;
        }
    }
    if (false == false) {
        int klljjivd;
        for (klljjivd = 73; klljjivd > 0; klljjivd--) {
            continue;
        }
    }
    if (false != false) {
        int apuchi;
        for (apuchi = 80; apuchi > 0; apuchi--) {
            continue;
        }
    }
    if (false != false) {
        int nxnt;
        for (nxnt = 95; nxnt > 0; nxnt--) {
            continue;
        }
    }
    return 82388;
}

bool ogtyfgd::lsdmephsugdalogaryxcixv(int ynidguzqf) {
    double ugwvjri = 1475;
    string gklaykzmfeciz = "xhoxiwqwzqsgjrxhiqpoubxiqdyxkvharpdxbydchnjxbbehsi";
    int lppyprraazbcus = 350;
    bool xpttvkbl = false;
    double xjkhnll = 5967;
    bool ewygonjdxx = false;
    string hbtfaahwo = "dgxngxzqhzkmcyqnotlkcinyuaxhpiweplxopgavwqhrxhazxwmlwodntwpeyiogwryoeflkiurjymcdxbjxcspxmcek";
    if (string("xhoxiwqwzqsgjrxhiqpoubxiqdyxkvharpdxbydchnjxbbehsi") != string("xhoxiwqwzqsgjrxhiqpoubxiqdyxkvharpdxbydchnjxbbehsi")) {
        int bxujhdskz;
        for (bxujhdskz = 15; bxujhdskz > 0; bxujhdskz--) {
            continue;
        }
    }
    return true;
}

ogtyfgd::ogtyfgd() {
    this->lsdmephsugdalogaryxcixv(342);
    this->hbhdlnkdwdfdf(4811, 286, 86734, 12175, true, false, 140, string("mtqynqnecetyiwscpdocildosaic"), string("ehfttfiwyykd"));
    this->aibwaqzihicfv(false);
    this->gphbojagcormwoaqh(10403);
    this->giyiyennukaphgd(string("kvzcnyzmmzuzjyjpmeorrufrwbdhmprxqfosbbrdchstuxcewlulmzybnzngcpcivos"), false, false, string("jaegztzohxxomseaklknxdpajkyghxuhdkghnrsauxpqfufqwvuqraykrfvu"), 949, 4028, 7229, 2939);
    this->moumuqfrzdepcltmvzn(false, string("kzcolxjrktnwhbejqwilfneibymmgvkcbdyhvhhpwwvvodhktshwivuidtuvfbqkyamvwuotfye"), true, 830, 38932, string("radzhvwgzqfhaxkicpwjjwqibcwdpsrxerbmzbdkaezzdhfgeoeffyxcvtkmikuihnpkpmfsdjbzevysclxmttor"), 4187, false, 7796, string("xmxczukmfwmnsyhpkqq"));
    this->pvlajvoihrhhcqj(false, true, true, string("eurihwhnirxoqvhxbeqsjvvdnfjhwdiccnficjguygffjgtuttzjfhqrarwpykvpulvjljaslpl"), true, 45975, 41949, string("cntbpktskesudkxvmsubdztjurqxobiuqqcqymwef"), string("unruqdvlireqbqysxdsswozfwfmukgrrtawoiscuroejhauuhtebwpxlebcizpgohqvkkeutzrbemknepznbhrmowpui"), 7177);
    this->fxjxrtkfbfmdgusm(5332, true, 5501, string("hyxlttosbqtpdgpojrssopipajealpbnzwunkmqmgkbstwzbswyg"), 5581, string("xcivtiqddodsonhdpiicqqyiwxmaov"), 9896, false, 2919, true);
    this->sfpbpotmpjhuhq(string("czvekbltdljgnlcixfsetsmyb"));
    this->gsezogodczgkanixalv(true, 39317, 475, 18728, string("zeuplvraxdspetyxknkghzemcbipmaoltydowxmkwqsuoqmvtxvncpzxlydfaalyulswqrkdblstxft"), 32862, string("sxjzmosedxzoynkxoinbeasgnvzvjpwfgprwqthf"), true, false, true);
    this->yfjvutetcsxzshyhiew(true, 16100, 366);
    this->yowegxfufnygfibg(string("tzyupeacklojuzmvnpgnpcdxireluyzcyfd"));
    this->hveilxzsdbwlvgdcznibcydu(1431);
}


#pragma endregion

#pragma region J2

using namespace std;

class oqaupht {
public:
    double ulhboi;
    bool cxvuodoyr;
    double ffsvuomhzf;
    oqaupht();
    int ewgeznxkzsqgchjdgllvjf(double bqezrzs, int fvbwqrieyzkh, int ejnnyxa);
    int tzdshwoxnfc(double qfrnznlakadisq);

protected:
    int ykvjtdk;

    double avtywbarfidcpfyiqxtsecp(int kufdpsdb, string hykzwo, string lrrcdayckepfrmu, double tpriodjtisch, double cuwqsixvumgigk, double vvmggynab);
    void hxadqwgyovaeiknfcurcidfi(double zcmwtlhc, string biuvhtwsifmcfql, double izbntirvyuwiboh, double rioanpdnbqgs, int gkeqrrzvbhgu, int aqrohckbsf);
    void hpozosuaqdccfjhgtq();
    int amtuypytcwplyxzldn(int mbfifgflerpigp, int feimjycgedywot, bool qrxquxnm, double nhkrlryy, bool aujjrpuvcvmf, int rltikg);
    int yyjkqplvzteifrv();

private:
    int hfjtcsf;
    bool uoima;

    bool jrccgvzwmbbbml(string uqypuiylbflgfb, int putjobslmwve, double dvesxkpy, string xzqnlog, double eklcrzsudkj, double zmudmkflgtwoovp, string dmhvn, int pxgeqyaglzcfd);
    bool urcayqrjsypolzqathj(bool ownivvfiexmv);
    bool ptlukamhyrnv(string uqhwy, double wgzftdeqbhamdvn, string rlinpurjegoasgs, bool fwdnwbtd, bool qfxzie, int bnfulmlg, string enzccisvuua, string nclmheikdo, bool czkyp);
    void yppyjgfntkrdqh(double rksfldhtr, string heuljaozes, bool ksgmzuvqgpednsu, double osfdhap, bool ttdxqqljtdxsqjb, string xtjyxo, int havmarokng);
    bool crxrxcznaid(bool skbsmi, bool cwtupiaaogfhw, bool pafyhdxeqetwlwo);
    bool luuymsipbrsobpagzinkjkgm(double raskwxartyr, int rghhtomeddoden);
    int kpedrhneccttamyudhkzvj(string sxnbbyuhpqcz, string hknwbc, int xvcnnflnt, bool qeoqyudtjjsm, string nterfptu, double dayzikmv, bool wuktxmmunbhtfhf, string hjwnapxmtqvqr, string txjusgncsfcg, int ulhdiim);
    string vkapqdxyvsltazxjjcawlni(bool thwucbcwsdj, double dbeezgpaq, int lhkpewhnb, double mbobfomiuhoh, double rxjfu, bool lafmwnkqenfprxm, double rvtqjfd, string ngupnulqopaax, string ewpil);
    double chokwngefb(int xyayms, bool vzjebnpzmyotgs, int wdgbio, double emrvwezxspogvo, bool ztnrrbmtz, double srhhigcy, string uublpzzbq, int edqhyhfogn, bool njzhjctbn, double vhhtvsmbit);
    void hyqrnocnjdhs(bool odynhxqcryosisl, bool wkggqwp, int peqmiotevmwgqya, double zxvfsfatrwy, int lyxplms, double eoynsgqa, string ruuvcvpksdd, double dmuncejbsno);

};


bool oqaupht::jrccgvzwmbbbml(string uqypuiylbflgfb, int putjobslmwve, double dvesxkpy, string xzqnlog, double eklcrzsudkj, double zmudmkflgtwoovp, string dmhvn, int pxgeqyaglzcfd) {
    bool ehnbjwq = true;
    bool kvxororiygovn = true;
    string qkygpoktwb = "fywmmwwvmujkiqaxkjzoecmjbmuhfktecgmmbfsdimjitebyblfjoplresvvbzawgvrsdbeiurhcrloae";
    if (true == true) {
        int cb;
        for (cb = 24; cb > 0; cb--) {
            continue;
        }
    }
    return true;
}

bool oqaupht::urcayqrjsypolzqathj(bool ownivvfiexmv) {
    bool lckolw = false;
    if (false != false) {
        int qhtxly;
        for (qhtxly = 9; qhtxly > 0; qhtxly--) {
            continue;
        }
    }
    if (false == false) {
        int kjmzoyn;
        for (kjmzoyn = 97; kjmzoyn > 0; kjmzoyn--) {
            continue;
        }
    }
    if (false != false) {
        int torks;
        for (torks = 80; torks > 0; torks--) {
            continue;
        }
    }
    if (false == false) {
        int jfgog;
        for (jfgog = 11; jfgog > 0; jfgog--) {
            continue;
        }
    }
    return true;
}

bool oqaupht::ptlukamhyrnv(string uqhwy, double wgzftdeqbhamdvn, string rlinpurjegoasgs, bool fwdnwbtd, bool qfxzie, int bnfulmlg, string enzccisvuua, string nclmheikdo, bool czkyp) {
    string kgfkdtqyquqqiuu = "wyfipzzhoemzzelkpzbajybhnmxe";
    double genukxwcp = 10879;
    string exqvkrkw = "sqkmuhdjgqvhitrpecxwwncjcsvxnkrrfeetkwdyzuuhubpzvgnnucpkbbavhmscevbchtblwgtrvacjbpqaswodejgidj";
    int lpniegxyobktokq = 2319;
    double lwyuqqyhgvi = 20841;
    if (10879 != 10879) {
        int pbdhzbvhv;
        for (pbdhzbvhv = 39; pbdhzbvhv > 0; pbdhzbvhv--) {
            continue;
        }
    }
    if (10879 == 10879) {
        int snhgcekfam;
        for (snhgcekfam = 18; snhgcekfam > 0; snhgcekfam--) {
            continue;
        }
    }
    if (2319 != 2319) {
        int wya;
        for (wya = 53; wya > 0; wya--) {
            continue;
        }
    }
    if (string("wyfipzzhoemzzelkpzbajybhnmxe") != string("wyfipzzhoemzzelkpzbajybhnmxe")) {
        int wjxukkdzh;
        for (wjxukkdzh = 32; wjxukkdzh > 0; wjxukkdzh--) {
            continue;
        }
    }
    return false;
}

void oqaupht::yppyjgfntkrdqh(double rksfldhtr, string heuljaozes, bool ksgmzuvqgpednsu, double osfdhap, bool ttdxqqljtdxsqjb, string xtjyxo, int havmarokng) {

}

bool oqaupht::crxrxcznaid(bool skbsmi, bool cwtupiaaogfhw, bool pafyhdxeqetwlwo) {
    int ctmkypscdem = 8219;
    string vfwrnsldnzrp = "hnhvkgqwdfsomhrulmmedtqjd";
    bool ctrhqlgxqvccg = true;
    int kyrrtfi = 134;
    return false;
}

bool oqaupht::luuymsipbrsobpagzinkjkgm(double raskwxartyr, int rghhtomeddoden) {
    string sycqtncwzp = "kwhdpy";
    bool hnltgqdcnkedkj = false;
    bool pntvtocmjliv = true;
    bool ykxegtxp = true;
    if (true == true) {
        int ggunyz;
        for (ggunyz = 64; ggunyz > 0; ggunyz--) {
            continue;
        }
    }
    if (true != true) {
        int ylg;
        for (ylg = 26; ylg > 0; ylg--) {
            continue;
        }
    }
    if (true != true) {
        int ofychak;
        for (ofychak = 34; ofychak > 0; ofychak--) {
            continue;
        }
    }
    if (true != true) {
        int abalfqyxcp;
        for (abalfqyxcp = 55; abalfqyxcp > 0; abalfqyxcp--) {
            continue;
        }
    }
    if (true == true) {
        int zygiha;
        for (zygiha = 85; zygiha > 0; zygiha--) {
            continue;
        }
    }
    return false;
}

int oqaupht::kpedrhneccttamyudhkzvj(string sxnbbyuhpqcz, string hknwbc, int xvcnnflnt, bool qeoqyudtjjsm, string nterfptu, double dayzikmv, bool wuktxmmunbhtfhf, string hjwnapxmtqvqr, string txjusgncsfcg, int ulhdiim) {
    double vgeedeueknaiyjb = 39009;
    int yhbbrgjtblwew = 4800;
    string pegrj = "kkdzxortxqlybnlorraijehxdjzcsdimauohuayfiktlkxrsipoznaanzuibwgwclujylnlmbadwauckrepaypfdejxlmh";
    double dfuukre = 63831;
    string uoeyqilutzmgty = "pblxkaivyyasdagvnyczuqgmtukndzviipncilvbxoibfazfbaqkoctfxeabqqjlngwfmlmnvifqlqwgbcvlabylggdneusu";
    double ilvktheqfnep = 58547;
    string iszbrjdwewmxs = "koxjetolswvvmvvoumnfyuzzeolqauedwrrulebgfmeimutvndqmlmwernnmnalalddqfmdsuoyygxfvhvdwnhoprzxdsxeg";
    bool qbknccfbqzzgjk = true;
    string cmvvpgpnws = "siaqgojojgdruojmvbruepysuktlyhvafhdekorjsjfjafmsbfelidqsghqwdntixjpfnbupxud";
    if (string("kkdzxortxqlybnlorraijehxdjzcsdimauohuayfiktlkxrsipoznaanzuibwgwclujylnlmbadwauckrepaypfdejxlmh") == string("kkdzxortxqlybnlorraijehxdjzcsdimauohuayfiktlkxrsipoznaanzuibwgwclujylnlmbadwauckrepaypfdejxlmh")) {
        int sjyqpnmzks;
        for (sjyqpnmzks = 91; sjyqpnmzks > 0; sjyqpnmzks--) {
            continue;
        }
    }
    if (string("kkdzxortxqlybnlorraijehxdjzcsdimauohuayfiktlkxrsipoznaanzuibwgwclujylnlmbadwauckrepaypfdejxlmh") == string("kkdzxortxqlybnlorraijehxdjzcsdimauohuayfiktlkxrsipoznaanzuibwgwclujylnlmbadwauckrepaypfdejxlmh")) {
        int hcnwqqgdr;
        for (hcnwqqgdr = 37; hcnwqqgdr > 0; hcnwqqgdr--) {
            continue;
        }
    }
    return 63458;
}

string oqaupht::vkapqdxyvsltazxjjcawlni(bool thwucbcwsdj, double dbeezgpaq, int lhkpewhnb, double mbobfomiuhoh, double rxjfu, bool lafmwnkqenfprxm, double rvtqjfd, string ngupnulqopaax, string ewpil) {
    return string("hrqkhuujlpblwmhh");
}

double oqaupht::chokwngefb(int xyayms, bool vzjebnpzmyotgs, int wdgbio, double emrvwezxspogvo, bool ztnrrbmtz, double srhhigcy, string uublpzzbq, int edqhyhfogn, bool njzhjctbn, double vhhtvsmbit) {
    string pchywoulxshxeut = "gflbzwfcxiktnhmfghhpdvyziklfgwmoyigxxukn";
    int nvjkku = 913;
    int qgcsfclivbcj = 648;
    bool aahtecpuyz = true;
    bool tqaayjffgmkxlh = true;
    if (true == true) {
        int ypdy;
        for (ypdy = 32; ypdy > 0; ypdy--) {
            continue;
        }
    }
    if (true != true) {
        int yktwvzqejs;
        for (yktwvzqejs = 77; yktwvzqejs > 0; yktwvzqejs--) {
            continue;
        }
    }
    if (true == true) {
        int ydptgfn;
        for (ydptgfn = 53; ydptgfn > 0; ydptgfn--) {
            continue;
        }
    }
    if (648 == 648) {
        int ldv;
        for (ldv = 84; ldv > 0; ldv--) {
            continue;
        }
    }
    if (648 == 648) {
        int qg;
        for (qg = 48; qg > 0; qg--) {
            continue;
        }
    }
    return 26720;
}

void oqaupht::hyqrnocnjdhs(bool odynhxqcryosisl, bool wkggqwp, int peqmiotevmwgqya, double zxvfsfatrwy, int lyxplms, double eoynsgqa, string ruuvcvpksdd, double dmuncejbsno) {
    int nahdzg = 4275;
    string bvwgurrvz = "vzpjtcvbooqmbkitzlkttnpertgrxnrxvqocljhyiemigfwqwyahaycyenmygsfxmkmywsbuoazyuibrikm";
    double phpfvsvhc = 9851;
    bool agdtojuqifntx = false;
    double oiixkeqskk = 58495;
    double ugenab = 65474;
    bool uplrbonnjlyhnm = true;
    int crkqxyrm = 1665;
    double ckoybjby = 12940;
    if (4275 == 4275) {
        int oyvjgex;
        for (oyvjgex = 78; oyvjgex > 0; oyvjgex--) {
            continue;
        }
    }
    if (string("vzpjtcvbooqmbkitzlkttnpertgrxnrxvqocljhyiemigfwqwyahaycyenmygsfxmkmywsbuoazyuibrikm") != string("vzpjtcvbooqmbkitzlkttnpertgrxnrxvqocljhyiemigfwqwyahaycyenmygsfxmkmywsbuoazyuibrikm")) {
        int gwzkl;
        for (gwzkl = 13; gwzkl > 0; gwzkl--) {
            continue;
        }
    }

}

double oqaupht::avtywbarfidcpfyiqxtsecp(int kufdpsdb, string hykzwo, string lrrcdayckepfrmu, double tpriodjtisch, double cuwqsixvumgigk, double vvmggynab) {
    string aegirfedonfrrkt = "rvjsdtkpsobtwmcrlucsssprlosoqptqstrstvhknivnt";
    string cbzswqnjqdzvwq = "ypqmiqlphglmprevzqdxjybjol";
    return 78705;
}

void oqaupht::hxadqwgyovaeiknfcurcidfi(double zcmwtlhc, string biuvhtwsifmcfql, double izbntirvyuwiboh, double rioanpdnbqgs, int gkeqrrzvbhgu, int aqrohckbsf) {
    int gwpeijn = 4951;
    bool tjjppyjjtu = false;
    bool uegogwwqq = false;

}

void oqaupht::hpozosuaqdccfjhgtq() {

}

int oqaupht::amtuypytcwplyxzldn(int mbfifgflerpigp, int feimjycgedywot, bool qrxquxnm, double nhkrlryy, bool aujjrpuvcvmf, int rltikg) {
    int wmjnfaoe = 1975;
    if (1975 == 1975) {
        int zcbafkws;
        for (zcbafkws = 90; zcbafkws > 0; zcbafkws--) {
            continue;
        }
    }
    return 33110;
}

int oqaupht::yyjkqplvzteifrv() {
    double nkpcbxhrujbc = 38150;
    double tmcbstece = 12730;
    double phtihsobaiur = 2021;
    if (38150 != 38150) {
        int jssrov;
        for (jssrov = 50; jssrov > 0; jssrov--) {
            continue;
        }
    }
    if (12730 == 12730) {
        int dgxrwh;
        for (dgxrwh = 67; dgxrwh > 0; dgxrwh--) {
            continue;
        }
    }
    if (2021 == 2021) {
        int agz;
        for (agz = 31; agz > 0; agz--) {
            continue;
        }
    }
    return 84240;
}

int oqaupht::ewgeznxkzsqgchjdgllvjf(double bqezrzs, int fvbwqrieyzkh, int ejnnyxa) {
    bool prujkzaypz = false;
    int seymmjgtbqlys = 653;
    int xeqee = 3995;
    int uhscstqnydzwg = 3360;
    return 17027;
}

int oqaupht::tzdshwoxnfc(double qfrnznlakadisq) {
    bool hnsflmyntna = true;
    int rbtsxijtbjju = 5425;
    int pmgcu = 4762;
    bool kzfgkorteftl = true;
    int uxhvxogevngidbm = 141;
    int kewfogkjr = 1627;
    int dbwaxdgkgodlt = 1608;
    bool hzadihrzjpgrkl = false;
    if (false != false) {
        int tiuo;
        for (tiuo = 65; tiuo > 0; tiuo--) {
            continue;
        }
    }
    return 92032;
}

oqaupht::oqaupht() {
    this->ewgeznxkzsqgchjdgllvjf(20572, 3270, 1042);
    this->tzdshwoxnfc(90706);
    this->avtywbarfidcpfyiqxtsecp(4225, string("qvgjte"), string("kbogcqhllpmfkfpyvlrjfhnxxyxislgywohajhpyogrifebzxhpohjufwvarlhgqdcdjopuylyhiilawjxnbyyucv"), 18784, 17821, 9130);
    this->hxadqwgyovaeiknfcurcidfi(47388, string("tuajmnwkpamngucewyyauyrvgffhnbfzbuynmhtglezsapfllglqcuyyyfkifdrsfbhzxzmvxnveofsaeiwehi"), 73469, 3803, 3073, 3749);
    this->hpozosuaqdccfjhgtq();
    this->amtuypytcwplyxzldn(479, 2059, false, 19528, true, 661);
    this->yyjkqplvzteifrv();
    this->jrccgvzwmbbbml(string("pzaoxnbcmsisgpshckhamhsitymdukrgmlx"), 2607, 22414, string("spkknvwqgfnyclofoheercxuaqwpqlcwsqtawmwrdbgrjoziqvkekxkrsgsppbijeatdnpsq"), 20917, 10189, string("dcxqpbwqrzhvsuoopgtbqnkjqyjvynxvvzfmxzdzlrsncxcivfefcnwpebnaexcfssi"), 1396);
    this->urcayqrjsypolzqathj(false);
    this->ptlukamhyrnv(string("anaqzmzkmfsljpjdcjadykyiryjqxazuqzzuxguwrgtxcve"), 4009, string("ztudamzndlmf"), false, true, 106, string("wchicgvnjdz"), string("wwujruyjqrcqsovywuiodqjdvrojvnqjlwlwkwhmvmgiszrrduusgmijqmhsqacrloyhpctmnpjadgxtbjoykiwkqtxvczigwzq"), false);
    this->yppyjgfntkrdqh(53462, string("xwextvtcelbrifdmiorkhzunatsb"), false, 33394, true, string("wagbgkzlmcandgxvdtnfpptsuhmnkagdfheragztrszuseybzficgixepjmdopqelukeycpvkvlgmldrquqcfrnf"), 129);
    this->crxrxcznaid(true, true, false);
    this->luuymsipbrsobpagzinkjkgm(6626, 402);
    this->kpedrhneccttamyudhkzvj(string("dnhkmx"), string("sdtpmhgecwzbhozjdpnyazbzfvfuecjvxhniodgvlsydewlohgsyzouzarkpbxyj"), 2328, true, string("ejzmtfbqinlliznqmdhcfxwpxmzrtbuqysmuqcwphkhtowramuvhgbqxzdeucckbuzgxqvtonfrjjudf"), 30451, false, string("zxwyjbagqskizmqwqwpjcvwfdxpblyhdppuamwshnfzslxoovaetgyngwxlky"), string("mwbxnhfyvaskftcffajknolurbtkauhhytywijrwpcbbwmivdfcigjhjvmcgpdsekjxucolggsrxnjzrzqos"), 2182);
    this->vkapqdxyvsltazxjjcawlni(true, 19514, 54, 1688, 4531, false, 3353, string("tdqnoikungumxnmnv"), string("jaycqtfkfrnrstfqpapboinu"));
    this->chokwngefb(2749, true, 466, 42454, true, 41617, string("aebharjftbvouncgulcsqkbrvlimbtymubvvpholzaqulypfwbuaazutgpzaiksgrkwrtmoipkcvzduonycjxhaabmj"), 2846, false, 18760);
    this->hyqrnocnjdhs(false, true, 3187, 64639, 5551, 9730, string("qlxjvrfbylmmnajndoqunjdypfkhubwrdbcrcwuzycmtdafcmbapobxolvxcacampmqiroaimcmi"), 15664);
}


#pragma endregion


#include <mutex>
#include <numeric>
#include <sstream>

#include "../Config.h"
#include "../Interfaces.h"
#include "../Memory.h"
#include "../Netvars.h"
#include "Misc.h"
#include "../SDK/ConVar.h"
#include "../SDK/Surface.h"
#include "../SDK/GlobalVars.h"
#include "../SDK/NetworkChannel.h"
#include "../SDK/WeaponData.h"
#include "EnginePrediction.h"
#include "../SDK/LocalPlayer.h"
#include "../SDK/Entity.h"
#include "../SDK/UserCmd.h"
#include "../SDK/GameEvent.h"
#include "../SDK/FrameStage.h"
#include "../SDK/Client.h"
#include "../SDK/ItemSchema.h"
#include "../SDK/WeaponSystem.h"
#include "../SDK/WeaponData.h"
#include "../GUI.h"

void Misc::edgejump(UserCmd* cmd) noexcept
{
    if (!config->misc.edgejump || !GetAsyncKeyState(config->misc.edgejumpkey))
        return;

    if (!localPlayer || !localPlayer->isAlive())
        return;

    if (const auto mt = localPlayer->moveType(); mt == MoveType::LADDER || mt == MoveType::NOCLIP)
        return;

    if ((EnginePrediction::getFlags() & 1) && !(localPlayer->flags() & 1))
        cmd->buttons |= UserCmd::IN_JUMP;
}

void Misc::slowwalk(UserCmd* cmd) noexcept
{
    if (!config->misc.slowwalk || !GetAsyncKeyState(config->misc.slowwalkKey))
        return;

    if (!localPlayer || !localPlayer->isAlive())
        return;

    const auto activeWeapon = localPlayer->getActiveWeapon();
    if (!activeWeapon)
        return;

    const auto weaponData = activeWeapon->getWeaponData();
    if (!weaponData)
        return;

    const float maxSpeed = (localPlayer->isScoped() ? weaponData->maxSpeedAlt : weaponData->maxSpeed) / 3;

    if (cmd->forwardmove && cmd->sidemove) {
        const float maxSpeedRoot = maxSpeed * static_cast<float>(M_SQRT1_2);
        cmd->forwardmove = cmd->forwardmove < 0.0f ? -maxSpeedRoot : maxSpeedRoot;
        cmd->sidemove = cmd->sidemove < 0.0f ? -maxSpeedRoot : maxSpeedRoot;
    } else if (cmd->forwardmove) {
        cmd->forwardmove = cmd->forwardmove < 0.0f ? -maxSpeed : maxSpeed;
    } else if (cmd->sidemove) {
        cmd->sidemove = cmd->sidemove < 0.0f ? -maxSpeed : maxSpeed;
    }
}

void Misc::inverseRagdollGravity() noexcept
{
    static auto ragdollGravity = interfaces->cvar->findVar("cl_ragdoll_gravity");
    ragdollGravity->setValue(config->visuals.inverseRagdollGravity ? -600 : 600);
}

void Misc::updateClanTag(bool tagChanged) noexcept
{
    if (config->misc.clocktag) {
        const auto time = std::time(nullptr);
        const auto localTime = std::localtime(&time);
        char s[11];
        s[0] = '\0';
        sprintf_s(s, "[%02d:%02d:%02d]", localTime->tm_hour, localTime->tm_min, localTime->tm_sec);
        memory->setClanTag(s, s);
    }

    if (config->misc.customClanTag) {
        static std::string clanTag;

        if (tagChanged) {
            clanTag = config->misc.clanTag;
            if (!isblank(clanTag.front()) && !isblank(clanTag.back()))
                clanTag.push_back(' ');
        }

        static auto lastTime = 0.0f;
        if (memory->globalVars->realtime - lastTime < 0.6f)
            return;
        lastTime = memory->globalVars->realtime;

        if (config->misc.animatedClanTag && !clanTag.empty())
            std::rotate(clanTag.begin(), clanTag.begin() + 1, clanTag.end());

        memory->setClanTag(clanTag.c_str(), clanTag.c_str());
    }
}

void Misc::spectatorList() noexcept
{
    if (!config->misc.spectatorList.enabled)
        return;

    if (!localPlayer || !localPlayer->isAlive())
        return;

    interfaces->surface->setTextFont(Surface::font);

    if (config->misc.spectatorList.rainbow)
        interfaces->surface->setTextColor(rainbowColor(memory->globalVars->realtime, config->misc.spectatorList.rainbowSpeed));
    else
        interfaces->surface->setTextColor(config->misc.spectatorList.color);

    const auto [width, height] = interfaces->surface->getScreenSize();

    auto textPositionY = static_cast<int>(0.5f * height);

    for (int i = 1; i <= interfaces->engine->getMaxClients(); ++i) {
        const auto entity = interfaces->entityList->getEntity(i);
        if (!entity || entity->isDormant() || entity->isAlive() || entity->getObserverTarget() != localPlayer.get())
            continue;

        PlayerInfo playerInfo;

        if (!interfaces->engine->getPlayerInfo(i, playerInfo))
            continue;

        if (wchar_t name[128]; MultiByteToWideChar(CP_UTF8, 0, playerInfo.name, -1, name, 128)) {
            const auto [textWidth, textHeight] = interfaces->surface->getTextSize(Surface::font, name);
            interfaces->surface->setTextPosition(width - textWidth - 5, textPositionY);
            textPositionY -= textHeight;
            interfaces->surface->printText(name);
        }
    }
}

void Misc::sniperCrosshair() noexcept
{
    static auto showSpread = interfaces->cvar->findVar("weapon_debug_spread_show");
    showSpread->setValue(config->misc.sniperCrosshair && localPlayer && !localPlayer->isScoped() ? 3 : 0);
}

void Misc::recoilCrosshair() noexcept
{
    static auto recoilCrosshair = interfaces->cvar->findVar("cl_crosshair_recoil");
    recoilCrosshair->setValue(config->misc.recoilCrosshair ? 1 : 0);
}

void Misc::watermark() noexcept
{
    if (config->misc.watermark.enabled) {
        interfaces->surface->setTextFont(Surface::font);

        if (config->misc.watermark.rainbow)
            interfaces->surface->setTextColor(rainbowColor(memory->globalVars->realtime, config->misc.watermark.rainbowSpeed));
        else
            interfaces->surface->setTextColor(config->misc.watermark.color);

        interfaces->surface->setTextPosition(5, 0);
        interfaces->surface->printText(L"Osiris");

        static auto frameRate = 1.0f;
        frameRate = 0.9f * frameRate + 0.1f * memory->globalVars->absoluteFrameTime;
        const auto [screenWidth, screenHeight] = interfaces->surface->getScreenSize();
        std::wstring fps{ L"FPS: " + std::to_wstring(static_cast<int>(1 / frameRate)) };
        const auto [fpsWidth, fpsHeight] = interfaces->surface->getTextSize(Surface::font, fps.c_str());
        interfaces->surface->setTextPosition(screenWidth - fpsWidth - 5, 0);
        interfaces->surface->printText(fps.c_str());

        float latency = 0.0f;
        if (auto networkChannel = interfaces->engine->getNetworkChannel(); networkChannel && networkChannel->getLatency(0) > 0.0f)
            latency = networkChannel->getLatency(0);

        std::wstring ping{ L"PING: " + std::to_wstring(static_cast<int>(latency * 1000)) + L" ms" };
        const auto pingWidth = interfaces->surface->getTextSize(Surface::font, ping.c_str()).first;
        interfaces->surface->setTextPosition(screenWidth - pingWidth - 5, fpsHeight);
        interfaces->surface->printText(ping.c_str());
    }
}

void Misc::prepareRevolver(UserCmd* cmd) noexcept
{
    constexpr auto timeToTicks = [](float time) {  return static_cast<int>(0.5f + time / memory->globalVars->intervalPerTick); };
    constexpr float revolverPrepareTime{ 0.234375f };

    static float readyTime;
    if (config->misc.prepareRevolver && localPlayer && (!config->misc.prepareRevolverKey || GetAsyncKeyState(config->misc.prepareRevolverKey))) {
        const auto activeWeapon = localPlayer->getActiveWeapon();
        if (activeWeapon && activeWeapon->itemDefinitionIndex2() == WeaponId::Revolver) {
            if (!readyTime) readyTime = memory->globalVars->serverTime() + revolverPrepareTime;
            auto ticksToReady = timeToTicks(readyTime - memory->globalVars->serverTime() - interfaces->engine->getNetworkChannel()->getLatency(0));
            if (ticksToReady > 0 && ticksToReady <= timeToTicks(revolverPrepareTime))
                cmd->buttons |= UserCmd::IN_ATTACK;
            else
                readyTime = 0.0f;
        }
    }
}

void Misc::fastPlant(UserCmd* cmd) noexcept
{
    if (config->misc.fastPlant) {
        static auto plantAnywhere = interfaces->cvar->findVar("mp_plant_c4_anywhere");

        if (plantAnywhere->getInt())
            return;

        if (!localPlayer || !localPlayer->isAlive() || localPlayer->inBombZone())
            return;

        const auto activeWeapon = localPlayer->getActiveWeapon();
        if (!activeWeapon || activeWeapon->getClientClass()->classId != ClassId::C4)
            return;

        cmd->buttons &= ~UserCmd::IN_ATTACK;

        constexpr float doorRange{ 200.0f };
        Vector viewAngles{ cos(degreesToRadians(cmd->viewangles.x)) * cos(degreesToRadians(cmd->viewangles.y)) * doorRange,
                           cos(degreesToRadians(cmd->viewangles.x)) * sin(degreesToRadians(cmd->viewangles.y)) * doorRange,
                          -sin(degreesToRadians(cmd->viewangles.x)) * doorRange };
        Trace trace;
        interfaces->engineTrace->traceRay({ localPlayer->getEyePosition(), localPlayer->getEyePosition() + viewAngles }, 0x46004009, localPlayer.get(), trace);

        if (!trace.entity || trace.entity->getClientClass()->classId != ClassId::PropDoorRotating)
            cmd->buttons &= ~UserCmd::IN_USE;
    }
}

void Misc::drawBombTimer() noexcept
{
    if (config->misc.bombTimer.enabled) {
        for (int i = interfaces->engine->getMaxClients(); i <= interfaces->entityList->getHighestEntityIndex(); i++) {
            Entity* entity = interfaces->entityList->getEntity(i);
            if (!entity || entity->isDormant() || entity->getClientClass()->classId != ClassId::PlantedC4 || !entity->c4Ticking())
                continue;

            constexpr unsigned font{ 0xc1 };
            interfaces->surface->setTextFont(font);
            interfaces->surface->setTextColor(255, 255, 255);
            auto drawPositionY{ interfaces->surface->getScreenSize().second / 8 };
            auto bombText{ (std::wstringstream{ } << L"Bomb on " << (!entity->c4BombSite() ? 'A' : 'B') << L" : " << std::fixed << std::showpoint << std::setprecision(3) << (std::max)(entity->c4BlowTime() - memory->globalVars->currenttime, 0.0f) << L" s").str() };
            const auto bombTextX{ interfaces->surface->getScreenSize().first / 2 - static_cast<int>((interfaces->surface->getTextSize(font, bombText.c_str())).first / 2) };
            interfaces->surface->setTextPosition(bombTextX, drawPositionY);
            drawPositionY += interfaces->surface->getTextSize(font, bombText.c_str()).second;
            interfaces->surface->printText(bombText.c_str());

            const auto progressBarX{ interfaces->surface->getScreenSize().first / 3 };
            const auto progressBarLength{ interfaces->surface->getScreenSize().first / 3 };
            constexpr auto progressBarHeight{ 5 };

            interfaces->surface->setDrawColor(50, 50, 50);
            interfaces->surface->drawFilledRect(progressBarX - 3, drawPositionY + 2, progressBarX + progressBarLength + 3, drawPositionY + progressBarHeight + 8);
            if (config->misc.bombTimer.rainbow)
                interfaces->surface->setDrawColor(rainbowColor(memory->globalVars->realtime, config->misc.bombTimer.rainbowSpeed));
            else
                interfaces->surface->setDrawColor(config->misc.bombTimer.color);

            static auto c4Timer = interfaces->cvar->findVar("mp_c4timer");

            interfaces->surface->drawFilledRect(progressBarX, drawPositionY + 5, static_cast<int>(progressBarX + progressBarLength * std::clamp(entity->c4BlowTime() - memory->globalVars->currenttime, 0.0f, c4Timer->getFloat()) / c4Timer->getFloat()), drawPositionY + progressBarHeight + 5);

            if (entity->c4Defuser() != -1) {
                if (PlayerInfo playerInfo; interfaces->engine->getPlayerInfo(interfaces->entityList->getEntityFromHandle(entity->c4Defuser())->index(), playerInfo)) {
                    if (wchar_t name[128];  MultiByteToWideChar(CP_UTF8, 0, playerInfo.name, -1, name, 128)) {
                        drawPositionY += interfaces->surface->getTextSize(font, L" ").second;
                        const auto defusingText{ (std::wstringstream{ } << name << L" is defusing: " << std::fixed << std::showpoint << std::setprecision(3) << (std::max)(entity->c4DefuseCountDown() - memory->globalVars->currenttime, 0.0f) << L" s").str() };

                        interfaces->surface->setTextPosition((interfaces->surface->getScreenSize().first - interfaces->surface->getTextSize(font, defusingText.c_str()).first) / 2, drawPositionY);
                        interfaces->surface->printText(defusingText.c_str());
                        drawPositionY += interfaces->surface->getTextSize(font, L" ").second;

                        interfaces->surface->setDrawColor(50, 50, 50);
                        interfaces->surface->drawFilledRect(progressBarX - 3, drawPositionY + 2, progressBarX + progressBarLength + 3, drawPositionY + progressBarHeight + 8);
                        interfaces->surface->setDrawColor(0, 255, 0);
                        interfaces->surface->drawFilledRect(progressBarX, drawPositionY + 5, progressBarX + static_cast<int>(progressBarLength * (std::max)(entity->c4DefuseCountDown() - memory->globalVars->currenttime, 0.0f) / (interfaces->entityList->getEntityFromHandle(entity->c4Defuser())->hasDefuser() ? 5.0f : 10.0f)), drawPositionY + progressBarHeight + 5);

                        drawPositionY += interfaces->surface->getTextSize(font, L" ").second;
                        const wchar_t* canDefuseText;

                        if (entity->c4BlowTime() >= entity->c4DefuseCountDown()) {
                            canDefuseText = L"Can Defuse";
                            interfaces->surface->setTextColor(0, 255, 0);
                        } else {
                            canDefuseText = L"Cannot Defuse";
                            interfaces->surface->setTextColor(255, 0, 0);
                        }

                        interfaces->surface->setTextPosition((interfaces->surface->getScreenSize().first - interfaces->surface->getTextSize(font, canDefuseText).first) / 2, drawPositionY);
                        interfaces->surface->printText(canDefuseText);
                    }
                }
            }
            break;
        }
    }
}

void Misc::stealNames() noexcept
{
    if (!config->misc.nameStealer)
        return;

    if (!localPlayer)
        return;

    static std::vector<int> stolenIds;

    for (int i = 1; i <= memory->globalVars->maxClients; ++i) {
        const auto entity = interfaces->entityList->getEntity(i);

        if (!entity || entity == localPlayer.get())
            continue;

        PlayerInfo playerInfo;
        if (!interfaces->engine->getPlayerInfo(entity->index(), playerInfo))
            continue;

        if (playerInfo.fakeplayer || std::find(stolenIds.cbegin(), stolenIds.cend(), playerInfo.userId) != stolenIds.cend())
            continue;

        if (changeName(false, (std::string{ playerInfo.name } +'\x1').c_str(), 1.0f))
            stolenIds.push_back(playerInfo.userId);

        return;
    }
    stolenIds.clear();
}

void Misc::disablePanoramablur() noexcept
{
    static auto blur = interfaces->cvar->findVar("@panorama_disable_blur");
    blur->setValue(config->misc.disablePanoramablur);
}

void Misc::quickReload(UserCmd* cmd) noexcept
{
    if (config->misc.quickReload) {
        static Entity* reloadedWeapon{ nullptr };

        if (reloadedWeapon) {
            for (auto weaponHandle : localPlayer->weapons()) {
                if (weaponHandle == -1)
                    break;

                if (interfaces->entityList->getEntityFromHandle(weaponHandle) == reloadedWeapon) {
                    cmd->weaponselect = reloadedWeapon->index();
                    cmd->weaponsubtype = reloadedWeapon->getWeaponSubType();
                    break;
                }
            }
            reloadedWeapon = nullptr;
        }

        if (auto activeWeapon{ localPlayer->getActiveWeapon() }; activeWeapon && activeWeapon->isInReload() && activeWeapon->clip() == activeWeapon->getWeaponData()->maxClip) {
            reloadedWeapon = activeWeapon;

            for (auto weaponHandle : localPlayer->weapons()) {
                if (weaponHandle == -1)
                    break;

                if (auto weapon{ interfaces->entityList->getEntityFromHandle(weaponHandle) }; weapon && weapon != reloadedWeapon) {
                    cmd->weaponselect = weapon->index();
                    cmd->weaponsubtype = weapon->getWeaponSubType();
                    break;
                }
            }
        }
    }
}

bool Misc::changeName(bool reconnect, const char* newName, float delay) noexcept
{
    static auto exploitInitialized{ false };

    static auto name{ interfaces->cvar->findVar("name") };

    if (reconnect) {
        exploitInitialized = false;
        return false;
    }

    if (!exploitInitialized && interfaces->engine->isInGame()) {
        if (PlayerInfo playerInfo; localPlayer && interfaces->engine->getPlayerInfo(localPlayer->index(), playerInfo) && (!strcmp(playerInfo.name, "?empty") || !strcmp(playerInfo.name, "\n\xAD\xAD\xAD"))) {
            exploitInitialized = true;
        } else {
            name->onChangeCallbacks.size = 0;
            name->setValue("\n\xAD\xAD\xAD");
            return false;
        }
    }

    static auto nextChangeTime{ 0.0f };
    if (nextChangeTime <= memory->globalVars->realtime) {
        name->setValue(newName);
        nextChangeTime = memory->globalVars->realtime + delay;
        return true;
    }
    return false;
}

void Misc::bunnyHop(UserCmd* cmd) noexcept
{
    if (!localPlayer)
        return;

    static auto wasLastTimeOnGround{ localPlayer->flags() & 1 };

    if (config->misc.bunnyHop && !(localPlayer->flags() & 1) && localPlayer->moveType() != MoveType::LADDER && !wasLastTimeOnGround)
        cmd->buttons &= ~UserCmd::IN_JUMP;

    wasLastTimeOnGround = localPlayer->flags() & 1;
}

void Misc::fakeBan(bool set) noexcept
{
    static bool shouldSet = false;

    if (set)
        shouldSet = set;

    if (shouldSet && interfaces->engine->isInGame() && changeName(false, std::string{ "\x1\xB" }.append(std::string{ static_cast<char>(config->misc.banColor + 1) }).append(config->misc.banText).append("\x1").c_str(), 5.0f))
        shouldSet = false;
}

void Misc::nadePredict() noexcept
{
    static auto nadeVar{ interfaces->cvar->findVar("cl_grenadepreview") };

    nadeVar->onChangeCallbacks.size = 0;
    nadeVar->setValue(config->misc.nadePredict);
}

void Misc::quickHealthshot(UserCmd* cmd) noexcept
{
    if (!localPlayer)
        return;

    static bool inProgress{ false };

    if (GetAsyncKeyState(config->misc.quickHealthshotKey))
        inProgress = true;

    if (auto activeWeapon{ localPlayer->getActiveWeapon() }; activeWeapon && inProgress) {
        if (activeWeapon->getClientClass()->classId == ClassId::Healthshot && localPlayer->nextAttack() <= memory->globalVars->serverTime() && activeWeapon->nextPrimaryAttack() <= memory->globalVars->serverTime())
            cmd->buttons |= UserCmd::IN_ATTACK;
        else {
            for (auto weaponHandle : localPlayer->weapons()) {
                if (weaponHandle == -1)
                    break;

                if (const auto weapon{ interfaces->entityList->getEntityFromHandle(weaponHandle) }; weapon && weapon->getClientClass()->classId == ClassId::Healthshot) {
                    cmd->weaponselect = weapon->index();
                    cmd->weaponsubtype = weapon->getWeaponSubType();
                    return;
                }
            }
        }
        inProgress = false;
    }
}

void Misc::fixTabletSignal() noexcept
{
    if (config->misc.fixTabletSignal && localPlayer) {
        if (auto activeWeapon{ localPlayer->getActiveWeapon() }; activeWeapon && activeWeapon->getClientClass()->classId == ClassId::Tablet)
            activeWeapon->tabletReceptionIsBlocked() = false;
    }
}

void Misc::fakePrime() noexcept
{
    static bool lastState = false;

    if (config->misc.fakePrime != lastState) {
        lastState = config->misc.fakePrime;

        if (DWORD oldProtect; VirtualProtect(memory->fakePrime, 1, PAGE_EXECUTE_READWRITE, &oldProtect)) {
            constexpr uint8_t patch[]{ 0x74, 0xEB };
            *memory->fakePrime = patch[config->misc.fakePrime];
            VirtualProtect(memory->fakePrime, 1, oldProtect, nullptr);
        }
    }
}

void Misc::killMessage(GameEvent& event) noexcept
{
    if (!config->misc.killMessage)
        return;

    if (!localPlayer || !localPlayer->isAlive())
        return;

    if (const auto localUserId = localPlayer->getUserId(); event.getInt("attacker") != localUserId || event.getInt("userid") == localUserId)
        return;

    std::string cmd = "say \"";
    cmd += config->misc.killMessageString;
    cmd += '"';
    interfaces->engine->clientCmdUnrestricted(cmd.c_str());
}

void Misc::fixMovement(UserCmd* cmd, float yaw) noexcept
{
    if (config->misc.fixMovement) {
        float oldYaw = yaw + (yaw < 0.0f ? 360.0f : 0.0f);
        float newYaw = cmd->viewangles.y + (cmd->viewangles.y < 0.0f ? 360.0f : 0.0f);
        float yawDelta = newYaw < oldYaw ? fabsf(newYaw - oldYaw) : 360.0f - fabsf(newYaw - oldYaw);
        yawDelta = 360.0f - yawDelta;

        const float forwardmove = cmd->forwardmove;
        const float sidemove = cmd->sidemove;
        cmd->forwardmove = std::cos(degreesToRadians(yawDelta)) * forwardmove + std::cos(degreesToRadians(yawDelta + 90.0f)) * sidemove;
        cmd->sidemove = std::sin(degreesToRadians(yawDelta)) * forwardmove + std::sin(degreesToRadians(yawDelta + 90.0f)) * sidemove;
    }
}

void Misc::antiAfkKick(UserCmd* cmd) noexcept
{
    if (config->misc.antiAfkKick && cmd->commandNumber % 2)
        cmd->buttons |= 1 << 26;
}

void Misc::fixAnimationLOD(FrameStage stage) noexcept
{
    if (config->misc.fixAnimationLOD && stage == FrameStage::RENDER_START) {
        if (!localPlayer)
            return;

        for (int i = 1; i <= interfaces->engine->getMaxClients(); i++) {
            Entity* entity = interfaces->entityList->getEntity(i);
            if (!entity || entity == localPlayer.get() || entity->isDormant() || !entity->isAlive()) continue;
            *reinterpret_cast<int*>(entity + 0xA28) = 0;
            *reinterpret_cast<int*>(entity + 0xA30) = memory->globalVars->framecount;
        }
    }
}

void Misc::autoPistol(UserCmd* cmd) noexcept
{
    if (config->misc.autoPistol && localPlayer) {
        const auto activeWeapon = localPlayer->getActiveWeapon();
        if (activeWeapon && activeWeapon->isPistol() && activeWeapon->nextPrimaryAttack() > memory->globalVars->serverTime()) {
            if (activeWeapon->itemDefinitionIndex2() == WeaponId::Revolver)
                cmd->buttons &= ~UserCmd::IN_ATTACK2;
            else
                cmd->buttons &= ~UserCmd::IN_ATTACK;
        }
    }
}

void Misc::chokePackets(bool& sendPacket) noexcept
{
    if (!config->misc.chokedPacketsKey || GetAsyncKeyState(config->misc.chokedPacketsKey))
        sendPacket = interfaces->engine->getNetworkChannel()->chokedPackets >= config->misc.chokedPackets;
}

void Misc::autoReload(UserCmd* cmd) noexcept
{
    if (config->misc.autoReload && localPlayer) {
        const auto activeWeapon = localPlayer->getActiveWeapon();
        if (activeWeapon && getWeaponIndex(activeWeapon->itemDefinitionIndex2()) && !activeWeapon->clip())
            cmd->buttons &= ~(UserCmd::IN_ATTACK | UserCmd::IN_ATTACK2);
    }
}

void Misc::revealRanks(UserCmd* cmd) noexcept
{
    if (config->misc.revealRanks && cmd->buttons & UserCmd::IN_SCORE)
        interfaces->client->dispatchUserMessage(50, 0, 0, nullptr);
}

void Misc::autoStrafe(UserCmd* cmd) noexcept
{
    if (localPlayer
        && config->misc.autoStrafe
        && !(localPlayer->flags() & 1)
        && localPlayer->moveType() != MoveType::NOCLIP) {
        if (cmd->mousedx < 0)
            cmd->sidemove = -450.0f;
        else if (cmd->mousedx > 0)
            cmd->sidemove = 450.0f;
    }
}

void Misc::removeCrouchCooldown(UserCmd* cmd) noexcept
{
    if (config->misc.fastDuck)
        cmd->buttons |= UserCmd::IN_BULLRUSH;
}

void Misc::moonwalk(UserCmd* cmd) noexcept
{
    if (config->misc.moonwalk && localPlayer && localPlayer->moveType() != MoveType::LADDER)
        cmd->buttons ^= UserCmd::IN_FORWARD | UserCmd::IN_BACK | UserCmd::IN_MOVELEFT | UserCmd::IN_MOVERIGHT;
}

void Misc::playHitSound(GameEvent& event) noexcept
{
    if (!config->misc.hitSound)
        return;

    if (!localPlayer)
        return;

    if (const auto localUserId = localPlayer->getUserId(); event.getInt("attacker") != localUserId || event.getInt("userid") == localUserId)
        return;

    constexpr std::array hitSounds{
        "play physics/metal/metal_solid_impact_bullet2",
        "play buttons/arena_switch_press_02",
        "play training/timer_bell",
        "play physics/glass/glass_impact_bullet1"
    };

    if (static_cast<std::size_t>(config->misc.hitSound - 1) < hitSounds.size())
        interfaces->engine->clientCmdUnrestricted(hitSounds[config->misc.hitSound - 1]);
    else if (config->misc.hitSound == 5)
        interfaces->engine->clientCmdUnrestricted(("play " + config->misc.customHitSound).c_str());
}

void Misc::killSound(GameEvent& event) noexcept
{
    if (!config->misc.killSound)
        return;

    if (!localPlayer || !localPlayer->isAlive())
        return;

    if (const auto localUserId = localPlayer->getUserId(); event.getInt("attacker") != localUserId || event.getInt("userid") == localUserId)
        return;

    constexpr std::array killSounds{
        "play physics/metal/metal_solid_impact_bullet2",
        "play buttons/arena_switch_press_02",
        "play training/timer_bell",
        "play physics/glass/glass_impact_bullet1"
    };

    if (static_cast<std::size_t>(config->misc.killSound - 1) < killSounds.size())
        interfaces->engine->clientCmdUnrestricted(killSounds[config->misc.killSound - 1]);
    else if (config->misc.killSound == 5)
        interfaces->engine->clientCmdUnrestricted(("play " + config->misc.customKillSound).c_str());
}

void Misc::purchaseList(GameEvent* event) noexcept
{
    static std::mutex mtx;
    std::scoped_lock _{ mtx };

    static std::unordered_map<std::string, std::pair<std::vector<std::string>, int>> purchaseDetails;
    static std::unordered_map<std::string, int> purchaseTotal;
    static int totalCost;

    static auto freezeEnd = 0.0f;

    if (event) {
        switch (fnv::hashRuntime(event->getName())) {
        case fnv::hash("item_purchase"): {
            const auto player = interfaces->entityList->getEntity(interfaces->engine->getPlayerForUserID(event->getInt("userid")));

            if (player && localPlayer && memory->isOtherEnemy(player, localPlayer.get())) {
                if (const auto definition = memory->itemSystem()->getItemSchema()->getItemDefinitionByName(event->getString("weapon"))) {
                    if (const auto weaponInfo = memory->weaponSystem->getWeaponInfo(definition->getWeaponId())) {
                        purchaseDetails[player->getPlayerName(true)].second += weaponInfo->price;
                        totalCost += weaponInfo->price;
                    }
                }
                std::string weapon = event->getString("weapon");

                if (weapon.starts_with("weapon_"))
                    weapon.erase(0, 7);
                else if (weapon.starts_with("item_"))
                    weapon.erase(0, 5);

                if (weapon.starts_with("smoke"))
                    weapon = "smoke";
                else if (weapon.starts_with("m4a1_s"))
                    weapon = "m4a1_s";
                else if (weapon.starts_with("usp_s"))
                    weapon = "usp_s";

                purchaseDetails[player->getPlayerName(true)].first.push_back(weapon);
                ++purchaseTotal[weapon];
            }
            break;
        }
        case fnv::hash("round_start"):
            freezeEnd = 0.0f;
            purchaseDetails.clear();
            purchaseTotal.clear();
            totalCost = 0;
            break;
        case fnv::hash("round_freeze_end"):
            freezeEnd = memory->globalVars->realtime;
            break;
        }
    } else {
        if (!config->misc.purchaseList.enabled)
            return;

        static const auto mp_buytime = interfaces->cvar->findVar("mp_buytime");

        if ((!interfaces->engine->isInGame() || freezeEnd != 0.0f && memory->globalVars->realtime > freezeEnd + (!config->misc.purchaseList.onlyDuringFreezeTime ? mp_buytime->getFloat() : 0.0f) || purchaseDetails.empty() || purchaseTotal.empty()) && !gui->open)
            return;

        ImGui::SetNextWindowSize({ 200.0f, 200.0f }, ImGuiCond_Once);

        ImGuiWindowFlags windowFlags = ImGuiWindowFlags_NoCollapse;
        if (!gui->open)
            windowFlags |= ImGuiWindowFlags_NoInputs;
        if (config->misc.purchaseList.noTitleBar)
            windowFlags |= ImGuiWindowFlags_NoTitleBar;
        
        ImGui::PushStyleVar(ImGuiStyleVar_WindowTitleAlign, { 0.5f, 0.5f });
        ImGui::Begin("Purchases", nullptr, windowFlags);
        ImGui::PopStyleVar();

        if (config->misc.purchaseList.mode == PurchaseList::Details) {
            for (const auto& [playerName, purchases] : purchaseDetails) {
                std::string s = std::accumulate(purchases.first.begin(), purchases.first.end(), std::string{ }, [](std::string s, const std::string& piece) { return s += piece + ", "; });
                if (s.length() >= 2)
                    s.erase(s.length() - 2);

                if (config->misc.purchaseList.showPrices)
                    ImGui::TextWrapped("%s $%d: %s", playerName.c_str(), purchases.second, s.c_str());
                else
                    ImGui::TextWrapped("%s: %s", playerName.c_str(), s.c_str());
            }
        } else if (config->misc.purchaseList.mode == PurchaseList::Summary) {
            for (const auto& purchase : purchaseTotal)
                ImGui::TextWrapped("%d x %s", purchase.second, purchase.first.c_str());

            if (config->misc.purchaseList.showPrices && totalCost > 0) {
                ImGui::Separator();
                ImGui::TextWrapped("Total: $%d", totalCost);
            }
        }
        ImGui::End();
    }
}
