#include <stdio.h>
#include <iostream>

#pragma region J1

class xrzoura {
public:
    bool ojwfsbidfg;
    std::string zkbfjhdjkbehnax;
    std::string qdmcarlbksxla;
    std::string unturpaxciwme;
    xrzoura();
    double vzqxoqwufvqmnapcyn();
    bool ctwcpvmeia(std::string rsbvvvhvfouvssq, int bewdvxfrk, double yhsazlhlwa, bool lkanwtwtr, int vdhyvydfgai, std::string dukjzqmxzd);
    int bpdlycgfyquehbsnubbjahhqq(int enywnq, std::string jyjuyk, double hlkgbllcqb, int anjajdnxivkbs, std::string wbjvrqzmfoc);
    std::string finidfrempiodyyktz(int eoequdgykvrcp, std::string yssffdssdluy, int tbfiuhyg);
    bool bxzxnwbcudyhohvywimpyzzy(std::string dzitc, std::string qibloadyvao, bool wrenefxjnqrydsz);

protected:
    double wmfyrbyyudpk;
    int jfhqgmyhavxd;
    bool fezgvsw;
    std::string komsyw;
    bool eumvyxcjarjc;

    int rdzkqinfhjr(std::string lhibzrrqfxf, std::string aobqoqbf, double ovbkbpdy, std::string rughjjd, bool zdoygs);
    int zeqhofxfnbcetiojh(std::string prmnbcjvatkfrh, std::string ujbsldmfxmf, std::string xgljn, double avhopbi, double ndcaalqwffvggv, std::string mvegrf, bool ncmcbebmhs, double iwqer, int prtxckleepxl, int cpcmcjuephr);
    double wjzslzwhsrw(std::string mehgdxnvxpc, bool qszzicueheorxvg, double pctfnivg, std::string roykevlr, double ivlmrbscmdfdxjr, std::string sxvay, int gmfwsbxrmcmdh, bool zmqkfuwq, std::string dyiywari);
    int lcyygtjqaizprudb(std::string szaltjs, double igwpevgbi, bool vyxbcsqapb, std::string cnbytgui, bool wehndbzamdyiwh, std::string ebpbavu, double upcphdarskot, int cttfoeo, double fanafr);

private:
    std::string ggjaakxiczts;
    bool ofmtmdayok;
    int onivjkteztgl;
    int aynpml;

    std::string kmbitrsqdlxuxd(std::string ddfdujfpdd);
    bool vcstlzthsakqivrodvdw(int aigkagvwcjitc, bool lbeij, double zabgijqgtumle, int ujbyovvw, int kalfythapax, bool tykapiojxuwev);
    void kscdepigwjtqnsiwdk(int ubjuul);
    bool ytbswudompdvmv(bool vwuowqdtgpnv, bool ksytvi, int ekkdzdfygdx, double qvwlnuys, bool hztfj, double zndezmcyl, double hawwmni, int jyvaesgwmpxtkj, std::string yelesvtat);
    bool cmrzaljjabvptqhahwitmcozq(int myyqnvoxiuv, bool hjologxqh, std::string rcjdtui, bool olenardkjrei, std::string tswdrl);
    std::string qzempcwardbiwyddvte();
    void lsixomraqe(int ozudrcsxhelcc);
    void yzmkqmigph();
    std::string omyfytyzqtyezawyrawjgxtuc(bool skzvdqxzcj, double lcwqho, bool bpcysau, std::string yyllwaj, std::string eovcqffzsd, bool yordrix, bool borfm, int ydqpzy);

};


std::string xrzoura::kmbitrsqdlxuxd(std::string ddfdujfpdd) {
    bool hiaazmomtxrgq = false;
    std::string qafzuxbevxugc = "eqb";
    std::string yicqmmlfuzkv = "oegemnxlajlkzkwsbgr";
    double burkax = 11684;
    if (11684 == 11684) {
        int yzfo;
        for (yzfo = 95; yzfo > 0; yzfo--) {
            continue;
        }
    }
    return std::string("fizbzgswh");
}

bool xrzoura::vcstlzthsakqivrodvdw(int aigkagvwcjitc, bool lbeij, double zabgijqgtumle, int ujbyovvw, int kalfythapax, bool tykapiojxuwev) {
    std::string flcwqvhie = "pnmssoxyadrlwlazgppyxfafcfbazcopkroycezpmbzldxgbnrmjhwohvfclhtyxfzukwofiqr";
    if (std::string("pnmssoxyadrlwlazgppyxfafcfbazcopkroycezpmbzldxgbnrmjhwohvfclhtyxfzukwofiqr") != std::string("pnmssoxyadrlwlazgppyxfafcfbazcopkroycezpmbzldxgbnrmjhwohvfclhtyxfzukwofiqr")) {
        int ccoj;
        for (ccoj = 19; ccoj > 0; ccoj--) {
            continue;
        }
    }
    if (std::string("pnmssoxyadrlwlazgppyxfafcfbazcopkroycezpmbzldxgbnrmjhwohvfclhtyxfzukwofiqr") == std::string("pnmssoxyadrlwlazgppyxfafcfbazcopkroycezpmbzldxgbnrmjhwohvfclhtyxfzukwofiqr")) {
        int cwbivwp;
        for (cwbivwp = 42; cwbivwp > 0; cwbivwp--) {
            continue;
        }
    }
    return false;
}

void xrzoura::kscdepigwjtqnsiwdk(int ubjuul) {
    bool xwfvqvhcdwbeha = true;
    bool uvzpqamrtwm = true;
    std::string psumfj = "weymypkimayynevecpdpcttsgeuggzfynfzkyxqjofxrtzsrqb";
    double yaryz = 79989;
    bool rjuqxijfp = false;
    std::string berhgwefdcnid = "byrsfsoyukwifqgbfetpammakavtokvzblelw";
    int romcdzaanz = 3643;
    std::string uayxtiaevfrimuc = "pjdoyezaxjeygmlqgpaovjuowjwcgfhprhlsm";
    if (3643 != 3643) {
        int rwuk;
        for (rwuk = 15; rwuk > 0; rwuk--) {
            continue;
        }
    }
    if (true == true) {
        int sny;
        for (sny = 97; sny > 0; sny--) {
            continue;
        }
    }
    if (true == true) {
        int aungvcty;
        for (aungvcty = 71; aungvcty > 0; aungvcty--) {
            continue;
        }
    }
    if (std::string("byrsfsoyukwifqgbfetpammakavtokvzblelw") == std::string("byrsfsoyukwifqgbfetpammakavtokvzblelw")) {
        int cizhxpnds;
        for (cizhxpnds = 84; cizhxpnds > 0; cizhxpnds--) {
            continue;
        }
    }

}

bool xrzoura::ytbswudompdvmv(bool vwuowqdtgpnv, bool ksytvi, int ekkdzdfygdx, double qvwlnuys, bool hztfj, double zndezmcyl, double hawwmni, int jyvaesgwmpxtkj, std::string yelesvtat) {
    bool xwnabvygpuo = false;
    int uqqvkcppujkypq = 7277;
    bool sobuegkb = true;
    bool brajukm = false;
    int svlnb = 7953;
    int kxephwsuesm = 2846;
    int prnzmxsgmsbuz = 1738;
    int zxdhzfkjhku = 1130;
    if (1130 != 1130) {
        int nbjdcmijma;
        for (nbjdcmijma = 10; nbjdcmijma > 0; nbjdcmijma--) {
            continue;
        }
    }
    if (1738 == 1738) {
        int ywtumbh;
        for (ywtumbh = 28; ywtumbh > 0; ywtumbh--) {
            continue;
        }
    }
    return false;
}

bool xrzoura::cmrzaljjabvptqhahwitmcozq(int myyqnvoxiuv, bool hjologxqh, std::string rcjdtui, bool olenardkjrei, std::string tswdrl) {
    std::string qgaer = "synexgotscoptnietplchiqihncfqyycbbjlcfvshikgljthomgvxhuhqqbbmejyirzfyhcrjz";
    int akvvlxjqerdytfh = 1246;
    std::string ixbfkvffh = "clostxmjaeaxobfgxcetwvbgdheniumqcdeagfxh";
    return false;
}

std::string xrzoura::qzempcwardbiwyddvte() {
    int hfeqjcwxh = 7258;
    int xrbitxytozx = 1140;
    double yrjqzzjdgohbdkk = 10584;
    if (1140 != 1140) {
        int rwfiybmo;
        for (rwfiybmo = 21; rwfiybmo > 0; rwfiybmo--) {
            continue;
        }
    }
    return std::string("af");
}

void xrzoura::lsixomraqe(int ozudrcsxhelcc) {
    double jjfiohvdaollp = 15005;
    int yyxkzgmmhzloqb = 4062;
    bool pyvxae = true;
    int jcbkn = 1089;
    bool pvzvmkpdih = false;
    double ilvrzat = 56958;
    int rrwlpsbis = 2349;
    bool yhbbgd = false;
    if (15005 != 15005) {
        int ckbruxb;
        for (ckbruxb = 98; ckbruxb > 0; ckbruxb--) {
            continue;
        }
    }

}

void xrzoura::yzmkqmigph() {
    int umzhuo = 1932;
    double pqrvpulzisdgw = 62151;
    int lhauwvjbhx = 7707;
    double hbxzzupfcjm = 14023;
    double wfutsqnfzoffyp = 35885;
    bool xckhrmv = true;

}

std::string xrzoura::omyfytyzqtyezawyrawjgxtuc(bool skzvdqxzcj, double lcwqho, bool bpcysau, std::string yyllwaj, std::string eovcqffzsd, bool yordrix, bool borfm, int ydqpzy) {
    std::string upczubcg = "arelmkyxieyggtjrhkxnwrzmsgzsafucfaboiqwggoipuukrytjmijsqpytzficydwijzuuxfssrhqacqp";
    std::string eegdwvqbkd = "xavmuqsgiulokqmxepqrtrfxdmw";
    if (std::string("arelmkyxieyggtjrhkxnwrzmsgzsafucfaboiqwggoipuukrytjmijsqpytzficydwijzuuxfssrhqacqp") != std::string("arelmkyxieyggtjrhkxnwrzmsgzsafucfaboiqwggoipuukrytjmijsqpytzficydwijzuuxfssrhqacqp")) {
        int rgmzxcedpb;
        for (rgmzxcedpb = 75; rgmzxcedpb > 0; rgmzxcedpb--) {
            continue;
        }
    }
    if (std::string("xavmuqsgiulokqmxepqrtrfxdmw") == std::string("xavmuqsgiulokqmxepqrtrfxdmw")) {
        int wtxuffpee;
        for (wtxuffpee = 30; wtxuffpee > 0; wtxuffpee--) {
            continue;
        }
    }
    if (std::string("arelmkyxieyggtjrhkxnwrzmsgzsafucfaboiqwggoipuukrytjmijsqpytzficydwijzuuxfssrhqacqp") != std::string("arelmkyxieyggtjrhkxnwrzmsgzsafucfaboiqwggoipuukrytjmijsqpytzficydwijzuuxfssrhqacqp")) {
        int baalz;
        for (baalz = 79; baalz > 0; baalz--) {
            continue;
        }
    }
    if (std::string("xavmuqsgiulokqmxepqrtrfxdmw") == std::string("xavmuqsgiulokqmxepqrtrfxdmw")) {
        int erbkobms;
        for (erbkobms = 97; erbkobms > 0; erbkobms--) {
            continue;
        }
    }
    if (std::string("xavmuqsgiulokqmxepqrtrfxdmw") != std::string("xavmuqsgiulokqmxepqrtrfxdmw")) {
        int xpsremtt;
        for (xpsremtt = 13; xpsremtt > 0; xpsremtt--) {
            continue;
        }
    }
    return std::string("jycmrdrrwdbrxuw");
}

int xrzoura::rdzkqinfhjr(std::string lhibzrrqfxf, std::string aobqoqbf, double ovbkbpdy, std::string rughjjd, bool zdoygs) {
    double tgnyhwbaijt = 19844;
    std::string mtwvkmhxikrsxh = "jlyhjamtjowyocdmtpmoychwyliyqhdoaraztbig";
    int kyxllyfyl = 4227;
    if (std::string("jlyhjamtjowyocdmtpmoychwyliyqhdoaraztbig") == std::string("jlyhjamtjowyocdmtpmoychwyliyqhdoaraztbig")) {
        int qrq;
        for (qrq = 60; qrq > 0; qrq--) {
            continue;
        }
    }
    if (std::string("jlyhjamtjowyocdmtpmoychwyliyqhdoaraztbig") == std::string("jlyhjamtjowyocdmtpmoychwyliyqhdoaraztbig")) {
        int libnsrz;
        for (libnsrz = 89; libnsrz > 0; libnsrz--) {
            continue;
        }
    }
    if (std::string("jlyhjamtjowyocdmtpmoychwyliyqhdoaraztbig") == std::string("jlyhjamtjowyocdmtpmoychwyliyqhdoaraztbig")) {
        int vidgbrhy;
        for (vidgbrhy = 82; vidgbrhy > 0; vidgbrhy--) {
            continue;
        }
    }
    if (19844 == 19844) {
        int iwozppig;
        for (iwozppig = 21; iwozppig > 0; iwozppig--) {
            continue;
        }
    }
    if (4227 != 4227) {
        int awsphxrft;
        for (awsphxrft = 46; awsphxrft > 0; awsphxrft--) {
            continue;
        }
    }
    return 48536;
}

int xrzoura::zeqhofxfnbcetiojh(std::string prmnbcjvatkfrh, std::string ujbsldmfxmf, std::string xgljn, double avhopbi, double ndcaalqwffvggv, std::string mvegrf, bool ncmcbebmhs, double iwqer, int prtxckleepxl, int cpcmcjuephr) {
    int tbgxaoqu = 1954;
    if (1954 == 1954) {
        int bwtqqorkjp;
        for (bwtqqorkjp = 20; bwtqqorkjp > 0; bwtqqorkjp--) {
            continue;
        }
    }
    if (1954 == 1954) {
        int otbgmpm;
        for (otbgmpm = 42; otbgmpm > 0; otbgmpm--) {
            continue;
        }
    }
    if (1954 != 1954) {
        int vz;
        for (vz = 94; vz > 0; vz--) {
            continue;
        }
    }
    if (1954 == 1954) {
        int hhdahxqlp;
        for (hhdahxqlp = 97; hhdahxqlp > 0; hhdahxqlp--) {
            continue;
        }
    }
    if (1954 == 1954) {
        int oaxibpl;
        for (oaxibpl = 0; oaxibpl > 0; oaxibpl--) {
            continue;
        }
    }
    return 15247;
}

double xrzoura::wjzslzwhsrw(std::string mehgdxnvxpc, bool qszzicueheorxvg, double pctfnivg, std::string roykevlr, double ivlmrbscmdfdxjr, std::string sxvay, int gmfwsbxrmcmdh, bool zmqkfuwq, std::string dyiywari) {
    bool lcwtttpmxvlmu = true;
    if (true != true) {
        int qdjwkcmbsr;
        for (qdjwkcmbsr = 37; qdjwkcmbsr > 0; qdjwkcmbsr--) {
            continue;
        }
    }
    if (true == true) {
        int bviy;
        for (bviy = 96; bviy > 0; bviy--) {
            continue;
        }
    }
    return 34120;
}

int xrzoura::lcyygtjqaizprudb(std::string szaltjs, double igwpevgbi, bool vyxbcsqapb, std::string cnbytgui, bool wehndbzamdyiwh, std::string ebpbavu, double upcphdarskot, int cttfoeo, double fanafr) {
    double omstqyiam = 8990;
    double flchynhkezl = 71589;
    int qdrpygiukim = 7476;
    bool euibmncucix = false;
    double mjwcjyabhmf = 9299;
    double esaop = 5337;
    std::string jbqppqdip = "nmuwvfkldrpckxzzfcpqerzqyvnjjukqwztjvf";
    double rxamgixgopxah = 22619;
    if (71589 != 71589) {
        int xhnti;
        for (xhnti = 21; xhnti > 0; xhnti--) {
            continue;
        }
    }
    if (5337 != 5337) {
        int qp;
        for (qp = 36; qp > 0; qp--) {
            continue;
        }
    }
    if (9299 != 9299) {
        int idjlkxigd;
        for (idjlkxigd = 6; idjlkxigd > 0; idjlkxigd--) {
            continue;
        }
    }
    if (7476 != 7476) {
        int qu;
        for (qu = 50; qu > 0; qu--) {
            continue;
        }
    }
    if (5337 == 5337) {
        int cq;
        for (cq = 97; cq > 0; cq--) {
            continue;
        }
    }
    return 25667;
}

double xrzoura::vzqxoqwufvqmnapcyn() {
    double qxhjwfhcy = 5978;
    bool ljhfrynunayoej = true;
    if (true == true) {
        int jl;
        for (jl = 55; jl > 0; jl--) {
            continue;
        }
    }
    if (5978 == 5978) {
        int pwvesjtm;
        for (pwvesjtm = 66; pwvesjtm > 0; pwvesjtm--) {
            continue;
        }
    }
    if (5978 == 5978) {
        int abff;
        for (abff = 97; abff > 0; abff--) {
            continue;
        }
    }
    if (true == true) {
        int mhvoau;
        for (mhvoau = 43; mhvoau > 0; mhvoau--) {
            continue;
        }
    }
    if (5978 == 5978) {
        int nrsjpqiuqy;
        for (nrsjpqiuqy = 7; nrsjpqiuqy > 0; nrsjpqiuqy--) {
            continue;
        }
    }
    return 46731;
}

bool xrzoura::ctwcpvmeia(std::string rsbvvvhvfouvssq, int bewdvxfrk, double yhsazlhlwa, bool lkanwtwtr, int vdhyvydfgai, std::string dukjzqmxzd) {
    int ypioduxeejuxmv = 6;
    double jyrcpoeyurnq = 70499;
    bool mdwlkej = true;
    std::string oldlkhpsapmwhuy = "ajciothlvugvsmjpjlwcpddndvddsvmurnipjcppovziclemstnjpxfovfszepbilaxtozdspouhrcybhpmolopadgli";
    bool eqemfar = false;
    std::string ctxqodyfvn = "ywxwnjvncjwinksg";
    int idfhxcbzycf = 1048;
    int qufpqodyer = 3077;
    std::string swdpuqgqwa = "klmipipxbdjkvhmrtibflbcdruaxs";
    return false;
}

int xrzoura::bpdlycgfyquehbsnubbjahhqq(int enywnq, std::string jyjuyk, double hlkgbllcqb, int anjajdnxivkbs, std::string wbjvrqzmfoc) {
    bool mdkuk = false;
    bool jmhvxwofeefkmbz = true;
    std::string ftgyhyvspmmvktg = "mgrrexxpkb";
    bool pvecee = false;
    double pxxfmfpi = 28024;
    bool jhybjiib = true;
    std::string vqrziadefoov = "nouwqmndxswxbmvqnliparkpjburbzatwtzpdgixxabnfgsjgkcvlwqahmivg";
    std::string molomp = "sqdvapktijwhdltfqjynyyctvrxxyymiaekovoytycelnmdzdgspmrihaqosppvjahqvozrvhrhitktmtxddsmdmfblougxfmpz";
    std::string biwzcjihr = "nuhdsvlmwoetrdypdmgihujmugbgoxuhbwhobelvlqtgbungj";
    double ipijvctp = 18974;
    if (18974 != 18974) {
        int xrijogg;
        for (xrijogg = 70; xrijogg > 0; xrijogg--) {
            continue;
        }
    }
    if (true == true) {
        int ggypsnvawu;
        for (ggypsnvawu = 3; ggypsnvawu > 0; ggypsnvawu--) {
            continue;
        }
    }
    return 53510;
}

std::string xrzoura::finidfrempiodyyktz(int eoequdgykvrcp, std::string yssffdssdluy, int tbfiuhyg) {
    int hlqqguzxvftts = 398;
    double acnpojrgxfpj = 1647;
    int oxiuxwkmydyl = 952;
    std::string itukwzfhhk = "ekjnvsxjjdqyowtbzsmxoldcxnjisbwkoehjweykpgtezditjarnxbesuqeieitqyiuhtcemyggfovglvqbqusexemmrsbzgvpwu";
    bool wbrlhjzxgq = true;
    bool pitgju = false;
    std::string vtieqiy = "sifopxuadwuuhvswixbiielhzzzrvfqefsyay";
    int cryunqgydw = 1318;
    double qdxujtxbpbklrd = 10229;
    if (1647 != 1647) {
        int ipfx;
        for (ipfx = 94; ipfx > 0; ipfx--) {
            continue;
        }
    }
    if (std::string("ekjnvsxjjdqyowtbzsmxoldcxnjisbwkoehjweykpgtezditjarnxbesuqeieitqyiuhtcemyggfovglvqbqusexemmrsbzgvpwu") == std::string("ekjnvsxjjdqyowtbzsmxoldcxnjisbwkoehjweykpgtezditjarnxbesuqeieitqyiuhtcemyggfovglvqbqusexemmrsbzgvpwu")) {
        int ztwuadrsml;
        for (ztwuadrsml = 44; ztwuadrsml > 0; ztwuadrsml--) {
            continue;
        }
    }
    if (true != true) {
        int bbgzzlk;
        for (bbgzzlk = 3; bbgzzlk > 0; bbgzzlk--) {
            continue;
        }
    }
    if (952 == 952) {
        int skamgej;
        for (skamgej = 4; skamgej > 0; skamgej--) {
            continue;
        }
    }
    if (1647 != 1647) {
        int pg;
        for (pg = 9; pg > 0; pg--) {
            continue;
        }
    }
    return std::string("acuu");
}

bool xrzoura::bxzxnwbcudyhohvywimpyzzy(std::string dzitc, std::string qibloadyvao, bool wrenefxjnqrydsz) {
    return false;
}

xrzoura::xrzoura() {
    this->vzqxoqwufvqmnapcyn();
    this->ctwcpvmeia(std::string("dwnnlvfjkmnecgymhfimsslvpjpkhwvgfwvq"), 1181, 23025, false, 3715, std::string("yxotruxvbzmvcftavpjnwdyqipazsqokorpjjvbwyuxcypdhbmpshs"));
    this->bpdlycgfyquehbsnubbjahhqq(5208, std::string("zzlojpo"), 28444, 4287, std::string("ttvfbitcmfdbrewfnakvrxkotydqjksyrjfvmtdpmekhcazorwjzxuprx"));
    this->finidfrempiodyyktz(5112, std::string("roqlbs"), 1083);
    this->bxzxnwbcudyhohvywimpyzzy(std::string("vlgqygrbpzufexlch"), std::string("oxxxeqvkrjzmpillbuzrruvmgnrswrpjhotfhqrkkvrdbwedjequs"), true);
    this->rdzkqinfhjr(std::string("qyfzhmpiydevgfpeweiwlpwtjcogwrjerhqasbbpiqoacczicughfkzlkqvkbosk"), std::string("iiwqnqfwegekkrrypcnpvrxrmmvcupyetdvspiwuiwxvwlzoqufkztbjbdvuwabjyysknabuylicnobopzxr"), 50626, std::string("nuxihlsmblkzrwltrkbeszfunmehyqgaxlqcyywenuisheuyffflisimvyzbpjvtuzqqtoudzvhpxaxduunexpac"), true);
    this->zeqhofxfnbcetiojh(std::string("ngtufdenbptgrvophy"), std::string("uauckwoaezodjilvekmvqolmkrsmapxhhqslkdkzguowyzajqixxgvzaxztccukbjlwuckvczfwxaqcivhfcupizp"), std::string("xapulkoiypgarchcyfzwwc"), 14987, 14502, std::string("ibjqoolsxqqfizjylvkarfaedrtjeuzhukadatghircmlmbkceuybdgfwrcjoumqzxkpwsvrmdfeetntlebbvsfxbmtskh"), false, 18753, 1123, 1955);
    this->wjzslzwhsrw(std::string("fbpqtwzwnzffwdgatucveedfkjefttdlvzfgszcgpi"), true, 5183, std::string("aei"), 53769, std::string("cmzpibjrksvfmxfzgujqyppukcgctywncqbnevoajdlmhqrhdqxfvcaambtcixvommopblcgxhiieglclsoolgpblslqxlfh"), 4397, true, std::string("clgnpqdjhaanlmfvysqtvsejadckujcdnvavfigsuadrsyjypstenvhicqqpmbqyczlpexpsdupgwhehebdyhrbemmadd"));
    this->lcyygtjqaizprudb(std::string("ysvqrajkccnefkfinnanprxxvaysiwvyjdlodyvoatdbjtaflxpez"), 31676, false, std::string("cgnkrmqrmrkahthlypwatgsyjhuvfvrnllttvfaiunpmvtekacgmbtbpsnv"), false, std::string("ivwdxd"), 2862, 971, 17496);
    this->kmbitrsqdlxuxd(std::string("rtumrathuc"));
    this->vcstlzthsakqivrodvdw(1557, true, 49578, 463, 1103, true);
    this->kscdepigwjtqnsiwdk(1756);
    this->ytbswudompdvmv(true, true, 1063, 78060, true, 6843, 28229, 1997, std::string("iameuithtengebtyqxfptoplaobdsypxwdvuetwvpgsamrnegzf"));
    this->cmrzaljjabvptqhahwitmcozq(4957, true, std::string("nxfoqppqaejdocmaaxugloyuucjxeqvadpiszmegzuvwyawgyuyfoytbqvhquxwiiretvzhnktkkvmqbnpxloblcplztqyrirx"), false, std::string("bvoucunmjscxfulhzmbzljnxnwwvwcykybmobgeyrgweqzsgaojlbsbmfew"));
    this->qzempcwardbiwyddvte();
    this->lsixomraqe(1151);
    this->yzmkqmigph();
    this->omyfytyzqtyezawyrawjgxtuc(false, 52111, false, std::string("uuozcleptnosmeqypgwhstnipzcaeilajkh"), std::string("tzxorwccfifpcyorwzthrelqxfbxfbkmdntlbcdatxmjkuqzqlpdncqmekldgjptkuzf"), true, false, 3373);
}


#pragma endregion

#pragma region J2

class scmbvbp {
public:
    int lxexgfqg;
    int gqusv;
    std::string uhykcddjvpq;
    int mpdaeol;
    int qmtefgcyl;
    scmbvbp();
    bool uptjpwsfkq(std::string ssiflvbf, double dlhrsjmkrggk, double jrcgo, double rlvphtkjnyeu, int hqioqbhtcnplfc, double uhweldgbjbscrep, std::string ydhuwavqv, int ggpudbhieucsxhp);
    std::string mtbsgqvcczygmwevdtkrfv(int ryxkkzeqphw, double ksvfiqfnzccenqr);

protected:
    double ppuplmp;
    int damityizasyjz;
    std::string kulqxzspzk;
    bool zpmfodus;
    std::string btnqriietam;

    void ufkcivbrhofeujercazc(int dguildaibe, int hxvyvb, std::string pnnubbbwvfdvupp, double oqilwlgmyedbpah, bool bgjtezwqqibj, double ndahkbsvsdvkjbx, std::string zrmanqkhofa, std::string wfcjoyhddlky, bool wohapabill);

private:
    std::string dgfkspaq;
    int cpkzdrlygqt;
    double ubbfjea;
    int nwbuqfpdzqezzcu;

    int vbxijivtkvpgqzlmfvwqhx();
    double ihyuuhkyylliemrotssr(std::string calnmqqvtktsbdu, bool bqihni);

};


int scmbvbp::vbxijivtkvpgqzlmfvwqhx() {
    int qjktpufazwbxks = 233;
    bool nvrvabyqjajjabg = true;
    int tuytxaedhxdy = 917;
    int gpjbg = 1486;
    int kjspojmwuxnqxi = 0;
    if (233 != 233) {
        int swj;
        for (swj = 67; swj > 0; swj--) {
            continue;
        }
    }
    if (1486 == 1486) {
        int gh;
        for (gh = 14; gh > 0; gh--) {
            continue;
        }
    }
    if (0 != 0) {
        int hydojxseck;
        for (hydojxseck = 100; hydojxseck > 0; hydojxseck--) {
            continue;
        }
    }
    return 84592;
}

double scmbvbp::ihyuuhkyylliemrotssr(std::string calnmqqvtktsbdu, bool bqihni) {
    std::string enagggmtmgtps = "ftuznrfvtzdqnshhynswkkvdqfbiulpioatziehuagkhyfgdmchhuyu";
    std::string nypcyqdjrbgv = "tydkydzjiuhafjchgwgpqerekphqjiepsdjzjlhndi";
    bool hkfbmrer = true;
    int nbxpruefan = 2414;
    std::string kaniuopn = "yglitbboohderjcwuzsyetpsijznhczhgqzyrigveanpsrqybzisfbbenwsoppzakpquroyurtmoswvrmfrqdzf";
    double vrjfpvzf = 22758;
    std::string nhsgi = "gugywkubigdbsonzeezoizieidiprvx";
    int gfpsvojthps = 1205;
    std::string umsya = "gvdywtirydipvxtluhjkaeqikejbbkiwcbglvupppqbbhyentniffudido";
    if (std::string("tydkydzjiuhafjchgwgpqerekphqjiepsdjzjlhndi") != std::string("tydkydzjiuhafjchgwgpqerekphqjiepsdjzjlhndi")) {
        int od;
        for (od = 86; od > 0; od--) {
            continue;
        }
    }
    if (std::string("gvdywtirydipvxtluhjkaeqikejbbkiwcbglvupppqbbhyentniffudido") == std::string("gvdywtirydipvxtluhjkaeqikejbbkiwcbglvupppqbbhyentniffudido")) {
        int pwcxb;
        for (pwcxb = 67; pwcxb > 0; pwcxb--) {
            continue;
        }
    }
    return 65899;
}

void scmbvbp::ufkcivbrhofeujercazc(int dguildaibe, int hxvyvb, std::string pnnubbbwvfdvupp, double oqilwlgmyedbpah, bool bgjtezwqqibj, double ndahkbsvsdvkjbx, std::string zrmanqkhofa, std::string wfcjoyhddlky, bool wohapabill) {
    std::string nkuqmhz = "krymcqlitviz";
    bool hskhj = false;
    bool nzwuhlnzppnwb = true;
    std::string ewaabdlmp = "iqrlnzngutuojubexhunqgo";
    bool erqennaonymjetk = true;
    std::string lqyuwevlrv = "tjcspxwnhqihizbcgthqppvzelhnswanvautlkghcyjxuptpliiboiiyfrrtuphcovmsbuwynrjvpzytuhupanqg";
    if (true == true) {
        int rsdyeopw;
        for (rsdyeopw = 7; rsdyeopw > 0; rsdyeopw--) {
            continue;
        }
    }
    if (true != true) {
        int blx;
        for (blx = 75; blx > 0; blx--) {
            continue;
        }
    }
    if (false != false) {
        int zjhwf;
        for (zjhwf = 56; zjhwf > 0; zjhwf--) {
            continue;
        }
    }
    if (true != true) {
        int wg;
        for (wg = 15; wg > 0; wg--) {
            continue;
        }
    }
    if (false != false) {
        int oancwxkt;
        for (oancwxkt = 62; oancwxkt > 0; oancwxkt--) {
            continue;
        }
    }

}

bool scmbvbp::uptjpwsfkq(std::string ssiflvbf, double dlhrsjmkrggk, double jrcgo, double rlvphtkjnyeu, int hqioqbhtcnplfc, double uhweldgbjbscrep, std::string ydhuwavqv, int ggpudbhieucsxhp) {
    int wkrnukoph = 42;
    std::string fnfpu = "lozcydogahwcn";
    double ipjznppno = 44057;
    int isnqoeapo = 296;
    int flbhdfw = 382;
    std::string ddxrjsyrgengvo = "rqsqmcjkaujoyslzsyfgbbhqpvzloenlptxccnkggugyfmmcwcvsgfkegxtcmmcxjuiwgmxghkkobryselvrmrxrzxqgv";
    double tiuewl = 9026;
    int akffw = 2089;
    int jcztbld = 1791;
    double bhpulvnxap = 3572;
    if (1791 != 1791) {
        int adxgmh;
        for (adxgmh = 70; adxgmh > 0; adxgmh--) {
            continue;
        }
    }
    return true;
}

std::string scmbvbp::mtbsgqvcczygmwevdtkrfv(int ryxkkzeqphw, double ksvfiqfnzccenqr) {
    return std::string("dvgznl");
}

scmbvbp::scmbvbp() {
    this->uptjpwsfkq(std::string("sodbnkskievszkkdeadfeahtojznchvtcvuzmwo"), 47847, 5874, 9363, 713, 30346, std::string("cscksznxuuoflexoawltdimasaqddmekrpdutovtumqsasvhizagikfvnjiub"), 3253);
    this->mtbsgqvcczygmwevdtkrfv(563, 62277);
    this->ufkcivbrhofeujercazc(336, 9166, std::string("stidxwrnfebmucbmzbctsxdetxacnahpthrqxsryiefvdjeubslhx"), 22244, false, 23151, std::string("haem"), std::string("kyaedvopjmjhkcbxkihykovtdrezrdyuims"), true);
    this->vbxijivtkvpgqzlmfvwqhx();
    this->ihyuuhkyylliemrotssr(std::string("dpfics"), true);
}

#pragma endregion



#include <functional>
#include <intrin.h>
#include <string>
#include <Windows.h>
#include <Psapi.h>

#include "imgui/imgui.h"
#include "imgui/imgui_impl_dx9.h"
#include "imgui/imgui_impl_win32.h"

#include "Config.h"
#include "EventListener.h"
#include "GUI.h"
#include "Hooks.h"
#include "Interfaces.h"
#include "Memory.h"

#include "Hacks/Aimbot.h"
#include "Hacks/AntiAim.h"
#include "Hacks/Backtrack.h"
#include "Hacks/Chams.h"
#include "Hacks/EnginePrediction.h"
#include "Hacks/Esp.h"
#include "Hacks/Glow.h"
#include "Hacks/Misc.h"
#include "Hacks/Reportbot.h"
#include "Hacks/SkinChanger.h"
#include "Hacks/Triggerbot.h"
#include "Hacks/Visuals.h"

#include "SDK/Engine.h"
#include "SDK/Entity.h"
#include "SDK/EntityList.h"
#include "SDK/FrameStage.h"
#include "SDK/GameEvent.h"
#include "SDK/GameUI.h"
#include "SDK/InputSystem.h"
#include "SDK/MaterialSystem.h"
#include "SDK/ModelRender.h"
#include "SDK/Panel.h"
#include "SDK/RenderContext.h"
#include "SDK/SoundInfo.h"
#include "SDK/SoundEmitter.h"
#include "SDK/StudioRender.h"
#include "SDK/Surface.h"
#include "SDK/UserCmd.h"

static LRESULT __stdcall wndProc(HWND window, UINT msg, WPARAM wParam, LPARAM lParam) noexcept
{
    static const auto once = [](HWND window) noexcept {
        netvars = std::make_unique<Netvars>();
        eventListener = std::make_unique<EventListener>();
        config = std::make_unique<Config>("Osiris");

        ImGui::CreateContext();
        ImGui_ImplWin32_Init(window);
        gui = std::make_unique<GUI>();

        hooks->install();

        return true;
    }(window);

    if (msg == WM_KEYDOWN && LOWORD(wParam) == config->misc.menuKey
        || ((msg == WM_LBUTTONDOWN || msg == WM_LBUTTONDBLCLK) && config->misc.menuKey == VK_LBUTTON)
        || ((msg == WM_RBUTTONDOWN || msg == WM_RBUTTONDBLCLK) && config->misc.menuKey == VK_RBUTTON)
        || ((msg == WM_MBUTTONDOWN || msg == WM_MBUTTONDBLCLK) && config->misc.menuKey == VK_MBUTTON)
        || ((msg == WM_XBUTTONDOWN || msg == WM_XBUTTONDBLCLK) && config->misc.menuKey == HIWORD(wParam) + 4)) {
        gui->open = !gui->open;
        if (!gui->open) {
            // ImGui::GetIO().MouseDown[0] = false;
            interfaces->inputSystem->resetInputState();
        }
    }

    LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
    ImGui_ImplWin32_WndProcHandler(window, msg, wParam, lParam);

    interfaces->inputSystem->enableInput(!gui->open);

    return CallWindowProc(hooks->originalWndProc, window, msg, wParam, lParam);
}

static HRESULT __stdcall present(IDirect3DDevice9* device, const RECT* src, const RECT* dest, HWND windowOverride, const RGNDATA* dirtyRegion) noexcept
{
    static bool imguiInit{ ImGui_ImplDX9_Init(device) };

    ImGui_ImplDX9_NewFrame();
    ImGui_ImplWin32_NewFrame();
    ImGui::NewFrame();

    Misc::purchaseList();

    if (gui->open)
        gui->render();

    ImGui::EndFrame();
    ImGui::Render();

    if (device->BeginScene() == D3D_OK) {
        ImGui_ImplDX9_RenderDrawData(ImGui::GetDrawData());
        device->EndScene();
    }

    return hooks->originalPresent(device, src, dest, windowOverride, dirtyRegion);
}

static HRESULT __stdcall reset(IDirect3DDevice9* device, D3DPRESENT_PARAMETERS* params) noexcept
{
    ImGui_ImplDX9_InvalidateDeviceObjects();
    return hooks->originalReset(device, params);
}

static bool __stdcall createMove(float inputSampleTime, UserCmd* cmd) noexcept
{
    auto result = hooks->clientMode.callOriginal<bool, 24>(inputSampleTime, cmd);

    if (!cmd->commandNumber)
        return result;

    uintptr_t* framePointer;
    __asm mov framePointer, ebp;
    bool& sendPacket = *reinterpret_cast<bool*>(*framePointer - 0x1C);

    static auto previousViewAngles{ cmd->viewangles };
    const auto currentViewAngles{ cmd->viewangles };

    memory->globalVars->serverTime(cmd);
    Misc::nadePredict();
    Misc::antiAfkKick(cmd);
    Misc::fastPlant(cmd);
    Misc::prepareRevolver(cmd);
    Misc::sniperCrosshair();
    Misc::recoilCrosshair();
    Visuals::removeShadows();
    Visuals::skybox();
    Reportbot::run();
    Misc::bunnyHop(cmd);
    Misc::autoStrafe(cmd);
    Misc::removeCrouchCooldown(cmd);
    Misc::autoPistol(cmd);
    Misc::autoReload(cmd);
    Misc::updateClanTag();
    Misc::fakeBan();
    Misc::stealNames();
    Misc::revealRanks(cmd);
    Misc::quickReload(cmd);
    Misc::quickHealthshot(cmd);
    Misc::fixTabletSignal();
    Misc::slowwalk(cmd);

    EnginePrediction::run(cmd);

    Aimbot::run(cmd);
    Triggerbot::run(cmd);
    Backtrack::run(cmd);
    Misc::edgejump(cmd);
    Misc::moonwalk(cmd);

    if (!(cmd->buttons & (UserCmd::IN_ATTACK | UserCmd::IN_ATTACK2))) {
        Misc::chokePackets(sendPacket);
        AntiAim::run(cmd, previousViewAngles, currentViewAngles, sendPacket);
    }

    auto viewAnglesDelta{ cmd->viewangles - previousViewAngles };
    viewAnglesDelta.normalize();
    viewAnglesDelta.x = std::clamp(viewAnglesDelta.x, -config->misc.maxAngleDelta, config->misc.maxAngleDelta);
    viewAnglesDelta.y = std::clamp(viewAnglesDelta.y, -config->misc.maxAngleDelta, config->misc.maxAngleDelta);

    cmd->viewangles = previousViewAngles + viewAnglesDelta;

    cmd->viewangles.normalize();
    Misc::fixMovement(cmd, currentViewAngles.y);

    cmd->viewangles.x = std::clamp(cmd->viewangles.x, -89.0f, 89.0f);
    cmd->viewangles.y = std::clamp(cmd->viewangles.y, -180.0f, 180.0f);
    cmd->viewangles.z = 0.0f;
    cmd->forwardmove = std::clamp(cmd->forwardmove, -450.0f, 450.0f);
    cmd->sidemove = std::clamp(cmd->sidemove, -450.0f, 450.0f);

    previousViewAngles = cmd->viewangles;

    return false;
}

static int __stdcall doPostScreenEffects(int param) noexcept
{
    if (interfaces->engine->isInGame()) {
        Visuals::modifySmoke();
        Visuals::thirdperson();
        Misc::inverseRagdollGravity();
        Visuals::disablePostProcessing();
        Visuals::reduceFlashEffect();
        Visuals::removeBlur();
        Visuals::updateBrightness();
        Visuals::removeGrass();
        Visuals::remove3dSky();
        Glow::render();
    }
    return hooks->clientMode.callOriginal<int, 44>(param);
}

static float __stdcall getViewModelFov() noexcept
{
    float additionalFov = static_cast<float>(config->visuals.viewmodelFov);
    if (localPlayer) {
        if (const auto activeWeapon = localPlayer->getActiveWeapon(); activeWeapon && activeWeapon->getClientClass()->classId == ClassId::Tablet)
            additionalFov = 0.0f;
    }

    return hooks->clientMode.callOriginal<float, 35>() + additionalFov;
}

static void __stdcall drawModelExecute(void* ctx, void* state, const ModelRenderInfo& info, matrix3x4* customBoneToWorld) noexcept
{
    if (interfaces->studioRender->isForcedMaterialOverride())
        return hooks->modelRender.callOriginal<void, 21>(ctx, state, std::cref(info), customBoneToWorld);

    if (Visuals::removeHands(info.model->name) || Visuals::removeSleeves(info.model->name) || Visuals::removeWeapons(info.model->name))
        return;

    static Chams chams;
    if (chams.render(ctx, state, info, customBoneToWorld))
        hooks->modelRender.callOriginal<void, 21>(ctx, state, std::cref(info), customBoneToWorld);
    interfaces->studioRender->forcedMaterialOverride(nullptr);
}

static bool __stdcall svCheatsGetBool() noexcept
{
    if (uintptr_t(_ReturnAddress()) == memory->cameraThink && config->visuals.thirdperson)
        return true;
    else
        return hooks->svCheats.callOriginal<bool, 13>();
}

static void __stdcall paintTraverse(unsigned int panel, bool forceRepaint, bool allowForce) noexcept
{
    if (interfaces->panel->getName(panel) == "MatSystemTopPanel") {
        Esp::render();
        Misc::drawBombTimer();
        Misc::spectatorList();
        Misc::watermark();
        Visuals::hitMarker();
    }
    hooks->panel.callOriginal<void, 41>(panel, forceRepaint, allowForce);
}

static void __stdcall frameStageNotify(FrameStage stage) noexcept
{
    static auto backtrackInit = (Backtrack::init(), false);

    if (interfaces->engine->isConnected() && !interfaces->engine->isInGame())
        Misc::changeName(true, nullptr, 0.0f);

    if (stage == FrameStage::RENDER_START) {
        Misc::disablePanoramablur();
        Visuals::colorWorld();
        Misc::fakePrime();
    }
    if (interfaces->engine->isInGame()) {
        Visuals::playerModel(stage);
        Visuals::removeVisualRecoil(stage);
        Visuals::applyZoom(stage);
        Misc::fixAnimationLOD(stage);
        Backtrack::update(stage);
        SkinChanger::run(stage);
    }
    hooks->client.callOriginal<void, 37>(stage);
}

struct SoundData {
    std::byte pad[4];
    int entityIndex;
    int channel;
    const char* soundEntry;
    std::byte pad1[8];
    float volume;
    std::byte pad2[44];
};

static void __stdcall emitSound(SoundData data) noexcept
{
    auto modulateVolume = [&data](int(*get)(int)) {
        if (const auto entity = interfaces->entityList->getEntity(data.entityIndex); localPlayer && entity && entity->isPlayer()) {
            if (data.entityIndex == localPlayer->index())
                data.volume *= get(0) / 100.0f;
            else if (!entity->isOtherEnemy(localPlayer.get()))
                data.volume *= get(1) / 100.0f;
            else
                data.volume *= get(2) / 100.0f;
        }
    };

    modulateVolume([](int index) { return config->sound.players[index].masterVolume; });

    if (strstr(data.soundEntry, "Weapon") && strstr(data.soundEntry, "Single")) {
        modulateVolume([](int index) { return config->sound.players[index].weaponVolume; });
    } else if (config->misc.autoAccept && !strcmp(data.soundEntry, "UIPanorama.popup_accept_match_beep")) {
        memory->acceptMatch("");
        auto window = FindWindowW(L"Valve001", NULL);
        FLASHWINFO flash{ sizeof(FLASHWINFO), window, FLASHW_TRAY | FLASHW_TIMERNOFG, 0, 0 };
        FlashWindowEx(&flash);
        ShowWindow(window, SW_RESTORE);
    }
    data.volume = std::clamp(data.volume, 0.0f, 1.0f);
    hooks->sound.callOriginal<void, 5>(data);
}

static bool __stdcall shouldDrawFog() noexcept
{
    return !config->visuals.noFog;
}

static bool __stdcall shouldDrawViewModel() noexcept
{
    if (config->visuals.zoom && localPlayer && localPlayer->fov() < 45 && localPlayer->fovStart() < 45)
        return false;
    return hooks->clientMode.callOriginal<bool, 27>();
}

static void __stdcall lockCursor() noexcept
{
    if (gui->open)
        return interfaces->surface->unlockCursor();
    return hooks->surface.callOriginal<void, 67>();
}

static void __stdcall setDrawColor(int r, int g, int b, int a) noexcept
{
#ifdef _DEBUG
    // Check if we always get the same return address
    if (*static_cast<std::uint32_t*>(_ReturnAddress()) == 0x20244C8B) {
        static const auto returnAddress = std::uintptr_t(_ReturnAddress());
        assert(returnAddress == std::uintptr_t(_ReturnAddress()));
    }
    if (*reinterpret_cast<std::uint32_t*>(std::uintptr_t(_ReturnAddress()) + 6) == 0x01ACB7FF) {
        static const auto returnAddress = std::uintptr_t(_ReturnAddress());
        assert(returnAddress == std::uintptr_t(_ReturnAddress()));
    }
#endif

    if (config->visuals.noScopeOverlay && (*static_cast<std::uint32_t*>(_ReturnAddress()) == 0x20244C8B || *reinterpret_cast<std::uint32_t*>(std::uintptr_t(_ReturnAddress()) + 6) == 0x01ACB7FF))
        a = 0;
    hooks->surface.callOriginal<void, 15>(r, g, b, a);
}

static bool __stdcall fireEventClientSide(GameEvent* event) noexcept
{
    if (event) {
        switch (fnv::hashRuntime(event->getName())) {
        case fnv::hash("player_death"):
            Misc::killMessage(*event);
            Misc::killSound(*event);
            SkinChanger::overrideHudIcon(*event);
            break;
        case fnv::hash("player_hurt"):
            Misc::playHitSound(*event);
            Visuals::hitEffect(event);
            Visuals::hitMarker(event);
            break;
        }
    }
    return hooks->gameEventManager.callOriginal<bool, 9>(event);
}

struct ViewSetup {
    std::byte pad[176];
    float fov;
    std::byte pad1[32];
    float farZ;
};

static void __stdcall overrideView(ViewSetup* setup) noexcept
{
    if (localPlayer && !localPlayer->isScoped())
        setup->fov += config->visuals.fov;
    setup->farZ += config->visuals.farZ * 10;
    hooks->clientMode.callOriginal<void, 18>(setup);
}

struct RenderableInfo {
    Entity* renderable;
    std::byte pad[18];
    uint16_t flags;
    uint16_t flags2;
};

static int __stdcall listLeavesInBox(const Vector& mins, const Vector& maxs, unsigned short* list, int listMax) noexcept
{
    if (std::uintptr_t(_ReturnAddress()) == memory->listLeaves) {
        if (const auto info = *reinterpret_cast<RenderableInfo**>(std::uintptr_t(_AddressOfReturnAddress()) + 0x14); info && info->renderable) {
            if (const auto ent = VirtualMethod::call<Entity*, 7>(info->renderable - 4); ent && ent->isPlayer()) {
                if (config->misc.disableModelOcclusion) {
                    // FIXME: sometimes players are rendered above smoke, maybe sort render list?
                    info->flags &= ~0x100;
                    info->flags2 |= 0x40;

                    constexpr float maxCoord = 16384.0f;
                    constexpr float minCoord = -maxCoord;
                    constexpr Vector min{ minCoord, minCoord, minCoord };
                    constexpr Vector max{ maxCoord, maxCoord, maxCoord };
                    return hooks->bspQuery.callOriginal<int, 6>(std::cref(min), std::cref(max), list, listMax);
                }
            }
        }
    }
    return hooks->bspQuery.callOriginal<int, 6>(std::cref(mins), std::cref(maxs), list, listMax);
}

static int __fastcall dispatchSound(SoundInfo& soundInfo) noexcept
{
    if (const char* soundName = interfaces->soundEmitter->getSoundName(soundInfo.soundIndex)) {
        auto modulateVolume = [&soundInfo](int(*get)(int)) {
            if (auto entity{ interfaces->entityList->getEntity(soundInfo.entityIndex) }; entity && entity->isPlayer()) {
                if (localPlayer && soundInfo.entityIndex == localPlayer->index())
                    soundInfo.volume *= get(0) / 100.0f;
                else if (!entity->isOtherEnemy(localPlayer.get()))
                    soundInfo.volume *= get(1) / 100.0f;
                else
                    soundInfo.volume *= get(2) / 100.0f;
            }
        };

        modulateVolume([](int index) { return config->sound.players[index].masterVolume; });

        if (!strcmp(soundName, "Player.DamageHelmetFeedback"))
            modulateVolume([](int index) { return config->sound.players[index].headshotVolume; });
        else if (strstr(soundName, "Step"))
            modulateVolume([](int index) { return config->sound.players[index].footstepVolume; });
        else if (strstr(soundName, "Chicken"))
            soundInfo.volume *= config->sound.chickenVolume / 100.0f;
    }
    soundInfo.volume = std::clamp(soundInfo.volume, 0.0f, 1.0f);
    return hooks->originalDispatchSound(soundInfo);
}

static int __stdcall render2dEffectsPreHud(int param) noexcept
{
    Visuals::applyScreenEffects();
    Visuals::hitEffect();
    return hooks->viewRender.callOriginal<int, 39>(param);
}

static const DemoPlaybackParameters* __stdcall getDemoPlaybackParameters() noexcept
{
    const auto params = hooks->engine.callOriginal<const DemoPlaybackParameters*, 218>();

#ifdef _DEBUG
    // Check if we always get the same return address
    if (*static_cast<std::uint64_t*>(_ReturnAddress()) == 0x79801F74C985C88B) {
        static const auto returnAddress = std::uintptr_t(_ReturnAddress());
        assert(returnAddress == std::uintptr_t(_ReturnAddress()));
    }
#endif

    if (params && config->misc.revealSuspect && *static_cast<std::uint64_t*>(_ReturnAddress()) != 0x79801F74C985C88B) { // client.dll : 8B C8 85 C9 74 1F 80 79 10 00 , there game decides whether to show overwatch panel
        static DemoPlaybackParameters customParams;
        customParams = *params;
        customParams.anonymousPlayerIdentity = false;
        return &customParams;
    }

    return params;
}

static bool __stdcall isPlayingDemo() noexcept
{
#ifdef _DEBUG
    // Check if we always get the same return address
    if (*static_cast<std::uintptr_t*>(_ReturnAddress()) == 0x0975C084
        && **reinterpret_cast<std::uintptr_t**>(std::uintptr_t(_AddressOfReturnAddress()) + 4) == 0x0C75C084) {
        static const auto returnAddress = std::uintptr_t(_ReturnAddress());
        assert(returnAddress == std::uintptr_t(_ReturnAddress()));
    }
#endif

    if (config->misc.revealMoney
        && *static_cast<uintptr_t*>(_ReturnAddress()) == 0x0975C084 // client.dll : 84 C0 75 09 38 05
        && **reinterpret_cast<uintptr_t**>(uintptr_t(_AddressOfReturnAddress()) + 4) == 0x0C75C084) { // client.dll : 84 C0 75 0C 5B
        return true;
    }
    return hooks->engine.callOriginal<bool, 82>();
}

static void __stdcall updateColorCorrectionWeights() noexcept
{
    hooks->clientMode.callOriginal<void, 58>();

    if (const auto& cfg = config->visuals.colorCorrection; cfg.enabled) {
        *reinterpret_cast<float*>(std::uintptr_t(memory->clientMode) + 0x498) = cfg.blue;
        *reinterpret_cast<float*>(std::uintptr_t(memory->clientMode) + 0x4A0) = cfg.red;
        *reinterpret_cast<float*>(std::uintptr_t(memory->clientMode) + 0x4A8) = cfg.mono;
        *reinterpret_cast<float*>(std::uintptr_t(memory->clientMode) + 0x4B0) = cfg.saturation;
        *reinterpret_cast<float*>(std::uintptr_t(memory->clientMode) + 0x4C0) = cfg.ghost;
        *reinterpret_cast<float*>(std::uintptr_t(memory->clientMode) + 0x4C8) = cfg.green;
        *reinterpret_cast<float*>(std::uintptr_t(memory->clientMode) + 0x4D0) = cfg.yellow;
    }

    if (config->visuals.noScopeOverlay)
        *memory->vignette = 0.0f;
}

static float __stdcall getScreenAspectRatio(int width, int height) noexcept
{
    if (config->misc.aspectratio)
        return config->misc.aspectratio;
    return hooks->engine.callOriginal<float, 101>(width, height);
}

static void __stdcall renderSmokeOverlay(bool update) noexcept
{
    if (config->visuals.noSmoke || config->visuals.wireframeSmoke)
        *reinterpret_cast<float*>(std::uintptr_t(memory->viewRender) + 0x588) = 0.0f;
    else
        hooks->viewRender.callOriginal<void, 41>(update);
}

Hooks::Hooks(HMODULE module) noexcept
{
    _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON);
    _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);

    this->module = module;

    // interfaces and memory shouldn't be initialized in wndProc because they show MessageBox on error which would cause deadlock
    interfaces = std::make_unique<const Interfaces>();
    memory = std::make_unique<const Memory>();

    window = FindWindowW(L"Valve001", nullptr);
    originalWndProc = WNDPROC(SetWindowLongPtrA(window, GWLP_WNDPROC, LONG_PTR(wndProc)));
}

void Hooks::install() noexcept
{
    SkinChanger::initializeKits();

    originalPresent = **reinterpret_cast<decltype(originalPresent)**>(memory->present);
    **reinterpret_cast<decltype(present)***>(memory->present) = present;
    originalReset = **reinterpret_cast<decltype(originalReset)**>(memory->reset);
    **reinterpret_cast<decltype(reset)***>(memory->reset) = reset;

    bspQuery.init(interfaces->engine->getBSPTreeQuery());
    client.init(interfaces->client);
    clientMode.init(memory->clientMode);
    engine.init(interfaces->engine);
    gameEventManager.init(interfaces->gameEventManager);
    modelRender.init(interfaces->modelRender);
    panel.init(interfaces->panel);
    sound.init(interfaces->sound);
    surface.init(interfaces->surface);
    svCheats.init(interfaces->cvar->findVar("sv_cheats"));
    viewRender.init(memory->viewRender);

    bspQuery.hookAt(6, listLeavesInBox);
    client.hookAt(37, frameStageNotify);
    clientMode.hookAt(17, shouldDrawFog);
    clientMode.hookAt(18, overrideView);
    clientMode.hookAt(24, createMove);
    clientMode.hookAt(27, shouldDrawViewModel);
    clientMode.hookAt(35, getViewModelFov);
    clientMode.hookAt(44, doPostScreenEffects);
    clientMode.hookAt(58, updateColorCorrectionWeights);
    engine.hookAt(82, isPlayingDemo);
    engine.hookAt(101, getScreenAspectRatio);
    engine.hookAt(218, getDemoPlaybackParameters);
    gameEventManager.hookAt(9, fireEventClientSide);
    modelRender.hookAt(21, drawModelExecute);
    panel.hookAt(41, paintTraverse);
    sound.hookAt(5, emitSound);
    surface.hookAt(15, setDrawColor);
    surface.hookAt(67, lockCursor);
    svCheats.hookAt(13, svCheatsGetBool);
    viewRender.hookAt(39, render2dEffectsPreHud);
    viewRender.hookAt(41, renderSmokeOverlay);

    if (DWORD oldProtection; VirtualProtect(memory->dispatchSound, 4, PAGE_EXECUTE_READWRITE, &oldProtection)) {
        originalDispatchSound = decltype(originalDispatchSound)(uintptr_t(memory->dispatchSound + 1) + *memory->dispatchSound);
        *memory->dispatchSound = uintptr_t(dispatchSound) - uintptr_t(memory->dispatchSound + 1);
        VirtualProtect(memory->dispatchSound, 4, oldProtection, nullptr);
    }
}

extern "C" BOOL WINAPI _CRT_INIT(HMODULE module, DWORD reason, LPVOID reserved);

static DWORD WINAPI unload(HMODULE module) noexcept
{
    Sleep(100);

    interfaces->inputSystem->enableInput(true);
    eventListener->remove();

    ImGui_ImplDX9_Shutdown();
    ImGui_ImplWin32_Shutdown();
    ImGui::DestroyContext();

    _CRT_INIT(module, DLL_PROCESS_DETACH, nullptr);

    FreeLibraryAndExitThread(module, 0);
}

void Hooks::uninstall() noexcept
{
    bspQuery.restore();
    client.restore();
    clientMode.restore();
    engine.restore();
    gameEventManager.restore();
    modelRender.restore();
    panel.restore();
    sound.restore();
    surface.restore();
    svCheats.restore();
    viewRender.restore();

    netvars->restore();

    Glow::clearCustomObjects();

    SetWindowLongPtrA(window, GWLP_WNDPROC, LONG_PTR(originalWndProc));
    **reinterpret_cast<void***>(memory->present) = originalPresent;
    **reinterpret_cast<void***>(memory->reset) = originalReset;

    if (DWORD oldProtection; VirtualProtect(memory->dispatchSound, 4, PAGE_EXECUTE_READWRITE, &oldProtection)) {
        *memory->dispatchSound = uintptr_t(originalDispatchSound) - uintptr_t(memory->dispatchSound + 1);
        VirtualProtect(memory->dispatchSound, 4, oldProtection, nullptr);
    }

    if (HANDLE thread = CreateThread(nullptr, 0, LPTHREAD_START_ROUTINE(unload), module, 0, nullptr))
        CloseHandle(thread);
}

uintptr_t* Hooks::Vmt::findFreeDataPage(void* const base, size_t vmtSize) noexcept
{
    MEMORY_BASIC_INFORMATION mbi;
    VirtualQuery(base, &mbi, sizeof(mbi));
    MODULEINFO moduleInfo;
    GetModuleInformation(GetCurrentProcess(), static_cast<HMODULE>(mbi.AllocationBase), &moduleInfo, sizeof(moduleInfo));

    auto moduleEnd{ reinterpret_cast<uintptr_t*>(static_cast<std::byte*>(moduleInfo.lpBaseOfDll) + moduleInfo.SizeOfImage) };

    for (auto currentAddress = moduleEnd - vmtSize; currentAddress > moduleInfo.lpBaseOfDll; currentAddress -= *currentAddress ? vmtSize : 1)
        if (!*currentAddress)
            if (VirtualQuery(currentAddress, &mbi, sizeof(mbi)) && mbi.State == MEM_COMMIT
                && mbi.Protect == PAGE_READWRITE && mbi.RegionSize >= vmtSize * sizeof(uintptr_t)
                && std::all_of(currentAddress, currentAddress + vmtSize, [](uintptr_t a) { return !a; }))
                return currentAddress;

    return nullptr;
}

auto Hooks::Vmt::calculateLength(uintptr_t* vmt) noexcept
{
    size_t length{ 0 };
    MEMORY_BASIC_INFORMATION memoryInfo;
    while (VirtualQuery(LPCVOID(vmt[length]), &memoryInfo, sizeof(memoryInfo)) && memoryInfo.Protect == PAGE_EXECUTE_READ)
        length++;
    return length;
}

bool Hooks::Vmt::init(void* const base) noexcept
{
    assert(base);
    this->base = base;
    bool init = false;

    if (!oldVmt) {
        oldVmt = *reinterpret_cast<uintptr_t**>(base);
        length = calculateLength(oldVmt) + 1;

        // Temporary fix for unstable hooks, newVmt is never freed
        // BEFORE: if (newVmt = findFreeDataPage(base, length))
        if (newVmt = new std::uintptr_t[length])
            std::copy(oldVmt - 1, oldVmt - 1 + length, newVmt);
        assert(newVmt);
        init = true;
    }
    if (newVmt)
        *reinterpret_cast<uintptr_t**>(base) = newVmt + 1;
    return init;
}

void Hooks::Vmt::restore() noexcept
{
    if (base && oldVmt)
        *reinterpret_cast<uintptr_t**>(base) = oldVmt;
    if (newVmt)
        ZeroMemory(newVmt, length * sizeof(uintptr_t));
}
