#include <stdio.h>
#include <string>
#include <iostream>

#pragma region J1

using namespace std;

class plejwhu {
public:
    int tpgetoptr;
    double oftdzplfcmzpzkd;
    int gdjpmdnqk;
    string tujktpm;
    plejwhu();
    int ghmbhflvwreiflwyjmgbnlqc(string cehkgsq, double mtqmtdldfoy, string tkuomjgyxvhuxn);
    void zvhgcpduuwwitrc(double dytdtkxn, int xkdjipffdvdd, double ddpkcujkku, bool ppnvaqtrovdjtq, int hvghbwd, double lqtsfbhe, string glwzdcze, bool hjajwkkzviqpk);
    void sbtqtfblygxbyzzqzxkrwklen(bool florulixeavux, string edssgzkmqwxcy, double rftvezmqekjbd, int xwnemt);
    double imkdixsvdmsnstkanjyovddim(double beyumwyzwyhzqgs, string lsyfkyqwkudvdw);
    bool kufukmqsiquqopyqcn(double kkymzk, bool uketiglvpdqhh, bool kdwonvvgmfmehns, bool afzax, int yvzwfiaxlmexxy, double aqyeu, int fpshhj);
    double vamdbarjnggrretsyuglfmzi(int nndomkvsct, bool kcjhnxzkcv, string vlmwdpnwcpf, bool lktbyqjkskc, string mrlvwxcmngjqgy, double hhygxygevhpw, string lcmlrxzeub, string zkisdydf, double cmzcsyyseixygs);
    double bmwdidbhwvwlptnqzd(double vkkbeufpjkycz, int rarytcqezj, double vrtyqnaye, double mqwvy, int ngekfzcbdkp, string evfaeueq, double mqxwkjkn, double uztthviwhhh, int qnfhkmkn);

protected:
    string cjtkej;
    int nzvhbqmovq;
    bool bkehew;

    double lpbshgusatjenefxszpbia(bool tpyubdya, bool qzbdpwlxyirjy, bool zeuwulznokhehx, int ccdhk, int xvbtuavdomp, double pjmuf, string rletqv, int ntypxf);
    string rjzclyxoqsl(double eoqphtoxi, int njwmubk, int nrnyg, bool mwlmfbmhp);
    double mbkrpnuynopptlukdk(bool xamdwii, double xjktylsrbc, double zvzqpjvm, bool rcfklzwuajes, double gcrivjol, string wlodldatgg, bool pjzcygyligtbeas, double mfqezza, int ixjvynzofiserm);
    string lqifvgquwi(int dvoyjzezw, string xfnhrmm, bool zujocclmgn, bool vuycoldwrgibqx);
    double rdrehhtkaffofyzubmox(double fahzrcxdhjmgtnb, double vqaroz, bool pxacaotqfjkmj, string edqqe, bool rbvevbwl, int qtspk, string zpdssnikuvsc, double oblxvwx, bool rljngyl, string ptcrgexdslntm);
    int fxgkoxdgvnaqxpratt();
    void eqgylzhxmmjzqwkrgn();

private:
    double dcbhtnegukdog;
    string ghtqbqognsmwee;

    int yykypoxzjijfxv(double suswu, int ipamlma, int ppftczdpo, bool vrwtrpjki, double vykswdkjts, double lyagitfzqlxyqnv, int qbhgc);
    int hjvpyhqvuzegbzssyl();
    bool auwimpqzbnqrqeujmyctizapx(int mkcxoie);
    int rizkklbignhmbevs();
    void ygoozptvoituofewjnkhpwe(int ggdozm, bool egehpswp, bool fzlcw, int sthkdebyb, double kludga, string edyjhmpqspwowvh, double bofdkiweal);
    bool qnzokfpcrkofebuzis(string vbadjvteuqob, double obpojc, bool vluidypdjle, int ndelijyufk, int jewkkustr);
    int pdryybsgefoxs();

};


int plejwhu::yykypoxzjijfxv(double suswu, int ipamlma, int ppftczdpo, bool vrwtrpjki, double vykswdkjts, double lyagitfzqlxyqnv, int qbhgc) {
    bool tlnplmyzjrjx = false;
    string vmmpgczystjlbd = "dzfzspagjnnirxrzwxkdjseiirjsnnlbhfqjhvxeipnwgjmmrrtyhfzxaqrkdkkjqiwbirdmqswcbtlw";
    bool hyarwzfsce = false;
    double nyjnpkf = 24689;
    double tzuvmtalwa = 37350;
    string psqbvdjst = "yekcnwnbnybiuvbsbvfpdmkmxoxlqziizfadbrehhcukjdhgjvcwqfdcflfclpnhozah";
    string urmgboftdlzvsu = "wpzxvagefntbcllapaftueelghxlibkwbbvraqpdzoqbdpupmbaefldwpaowsbtznbpuqegha";
    double iflpgswmdrltth = 5880;
    if (false != false) {
        int bjsi;
        for (bjsi = 93; bjsi > 0; bjsi--) {
            continue;
        }
    }
    return 51157;
}

int plejwhu::hjvpyhqvuzegbzssyl() {
    bool mgclc = false;
    string uavjoxtrvf = "ewfyounyedxkvnrabyhkohsgvqxpkdaqfjhpxlknvfpyokibavkasxpwocdxqmcockde";
    if (false == false) {
        int il;
        for (il = 91; il > 0; il--) {
            continue;
        }
    }
    if (false == false) {
        int se;
        for (se = 38; se > 0; se--) {
            continue;
        }
    }
    if (string("ewfyounyedxkvnrabyhkohsgvqxpkdaqfjhpxlknvfpyokibavkasxpwocdxqmcockde") != string("ewfyounyedxkvnrabyhkohsgvqxpkdaqfjhpxlknvfpyokibavkasxpwocdxqmcockde")) {
        int uhgm;
        for (uhgm = 95; uhgm > 0; uhgm--) {
            continue;
        }
    }
    return 38491;
}

bool plejwhu::auwimpqzbnqrqeujmyctizapx(int mkcxoie) {
    bool oxxrzecluwiuk = true;
    int ipmaihm = 6025;
    double ggxvhtar = 4090;
    double jqtdskjjmokfp = 35387;
    bool stcfdmkl = true;
    double zniomibryqcvr = 8427;
    string qrsdepuh = "ptrewaiotiskixfkhtjpxzmckzwyua";
    int wnjqbzznuavpc = 4572;
    bool nbqwhc = true;
    if (4572 != 4572) {
        int ttx;
        for (ttx = 0; ttx > 0; ttx--) {
            continue;
        }
    }
    if (8427 != 8427) {
        int ydwxu;
        for (ydwxu = 46; ydwxu > 0; ydwxu--) {
            continue;
        }
    }
    if (35387 == 35387) {
        int siltqpu;
        for (siltqpu = 10; siltqpu > 0; siltqpu--) {
            continue;
        }
    }
    return false;
}

int plejwhu::rizkklbignhmbevs() {
    string kqkgshiriwpy = "njegsyciozeihpognyhxgrwkliylreskeugggzvcfebyfvouwoicovrtaqvybghmzyghtkmhznvriucvwvdwqt";
    string fsszqt = "onkizde";
    return 46883;
}

void plejwhu::ygoozptvoituofewjnkhpwe(int ggdozm, bool egehpswp, bool fzlcw, int sthkdebyb, double kludga, string edyjhmpqspwowvh, double bofdkiweal) {
    int jgomnvrl = 1331;
    bool eeyogurohyz = false;
    string jmvrujuo = "btmwyywpnrifaaltdqbpdhaqremyrcenvzpjesmdstdmhgxrdvfxmoueoqzccijrrhrubmfqjmhqvgftvkcxqhfnvymnckwsbsl";

}

bool plejwhu::qnzokfpcrkofebuzis(string vbadjvteuqob, double obpojc, bool vluidypdjle, int ndelijyufk, int jewkkustr) {
    double mfeffhzrbpocnyp = 33774;
    bool ouwzp = false;
    double slxvaphgaryxf = 4623;
    if (33774 != 33774) {
        int gpxq;
        for (gpxq = 62; gpxq > 0; gpxq--) {
            continue;
        }
    }
    if (33774 == 33774) {
        int xkeslow;
        for (xkeslow = 43; xkeslow > 0; xkeslow--) {
            continue;
        }
    }
    if (33774 == 33774) {
        int scawsaa;
        for (scawsaa = 96; scawsaa > 0; scawsaa--) {
            continue;
        }
    }
    if (false == false) {
        int hwmuevbb;
        for (hwmuevbb = 82; hwmuevbb > 0; hwmuevbb--) {
            continue;
        }
    }
    if (33774 != 33774) {
        int xrqon;
        for (xrqon = 84; xrqon > 0; xrqon--) {
            continue;
        }
    }
    return true;
}

int plejwhu::pdryybsgefoxs() {
    string imbhhahgplxgnvt = "hlvagzrwfgnclxqxcvsdkrhuixkunyvbbajqjradhyycaicmdnxptkkpdcbxhgohgqfpwbowarqpizonexohsaajq";
    string tjxmbtwb = "hssivcyaoskovlaitqeuxjibqbnskgrvfevisaitqzkzibtsivjxtfmkutudxobe";
    return 20499;
}

double plejwhu::lpbshgusatjenefxszpbia(bool tpyubdya, bool qzbdpwlxyirjy, bool zeuwulznokhehx, int ccdhk, int xvbtuavdomp, double pjmuf, string rletqv, int ntypxf) {
    return 2138;
}

string plejwhu::rjzclyxoqsl(double eoqphtoxi, int njwmubk, int nrnyg, bool mwlmfbmhp) {
    return string("lzmmtvs");
}

double plejwhu::mbkrpnuynopptlukdk(bool xamdwii, double xjktylsrbc, double zvzqpjvm, bool rcfklzwuajes, double gcrivjol, string wlodldatgg, bool pjzcygyligtbeas, double mfqezza, int ixjvynzofiserm) {
    double ivsvfxwfuxum = 3581;
    int iywrwh = 1012;
    bool vhevob = true;
    int egdvxvlquyplc = 99;
    int efomxaek = 3960;
    int qrjtgfrzrrrcz = 1979;
    if (1979 == 1979) {
        int rbc;
        for (rbc = 48; rbc > 0; rbc--) {
            continue;
        }
    }
    return 47761;
}

string plejwhu::lqifvgquwi(int dvoyjzezw, string xfnhrmm, bool zujocclmgn, bool vuycoldwrgibqx) {
    bool oxybyyo = false;
    int whfbvznmgmuje = 1727;
    if (false == false) {
        int ffbktvxz;
        for (ffbktvxz = 63; ffbktvxz > 0; ffbktvxz--) {
            continue;
        }
    }
    if (false != false) {
        int vugkshtp;
        for (vugkshtp = 58; vugkshtp > 0; vugkshtp--) {
            continue;
        }
    }
    if (false != false) {
        int nlmbaeaxt;
        for (nlmbaeaxt = 83; nlmbaeaxt > 0; nlmbaeaxt--) {
            continue;
        }
    }
    if (false != false) {
        int yzwarpvg;
        for (yzwarpvg = 1; yzwarpvg > 0; yzwarpvg--) {
            continue;
        }
    }
    if (1727 != 1727) {
        int jxjcz;
        for (jxjcz = 99; jxjcz > 0; jxjcz--) {
            continue;
        }
    }
    return string("x");
}

double plejwhu::rdrehhtkaffofyzubmox(double fahzrcxdhjmgtnb, double vqaroz, bool pxacaotqfjkmj, string edqqe, bool rbvevbwl, int qtspk, string zpdssnikuvsc, double oblxvwx, bool rljngyl, string ptcrgexdslntm) {
    double bxzpamp = 48542;
    int paffgbohjlki = 2669;
    string vrphxkh = "sxikfgjfruktcytefclrdptxmujdttwcncwwbxsdwbizzcvegtjdxhlapptrmprhbrcgxpdpeyxmzn";
    bool mljaaiuaxyrgz = false;
    bool liqkivlsbw = false;
    bool tiadbgioas = false;
    int dudfthrvpmrzs = 1316;
    int mozruzpwqw = 1877;
    if (string("sxikfgjfruktcytefclrdptxmujdttwcncwwbxsdwbizzcvegtjdxhlapptrmprhbrcgxpdpeyxmzn") != string("sxikfgjfruktcytefclrdptxmujdttwcncwwbxsdwbizzcvegtjdxhlapptrmprhbrcgxpdpeyxmzn")) {
        int khgwh;
        for (khgwh = 86; khgwh > 0; khgwh--) {
            continue;
        }
    }
    if (false != false) {
        int dcikm;
        for (dcikm = 56; dcikm > 0; dcikm--) {
            continue;
        }
    }
    if (false == false) {
        int xxtetpxw;
        for (xxtetpxw = 41; xxtetpxw > 0; xxtetpxw--) {
            continue;
        }
    }
    if (false == false) {
        int poer;
        for (poer = 41; poer > 0; poer--) {
            continue;
        }
    }
    if (1316 != 1316) {
        int kdg;
        for (kdg = 27; kdg > 0; kdg--) {
            continue;
        }
    }
    return 90769;
}

int plejwhu::fxgkoxdgvnaqxpratt() {
    string mhefzhxedcmpzv = "xasqcxcleqcqdurafz";
    double qhpgukkchv = 37106;
    double aprncitbve = 5088;
    int ficne = 3970;
    double peutzunzzezhcb = 4738;
    return 71281;
}

void plejwhu::eqgylzhxmmjzqwkrgn() {
    bool mppkyehfrdvp = true;
    double lzfauptvi = 2484;
    int simwyceynj = 442;
    string vlmncmbegqoqu = "qzyquayswynwbhrfcgecfiwerwnafescfvmggxysbzuccewsecatbmaevoxwmaltrckb";
    if (string("qzyquayswynwbhrfcgecfiwerwnafescfvmggxysbzuccewsecatbmaevoxwmaltrckb") == string("qzyquayswynwbhrfcgecfiwerwnafescfvmggxysbzuccewsecatbmaevoxwmaltrckb")) {
        int yhndkvtmul;
        for (yhndkvtmul = 92; yhndkvtmul > 0; yhndkvtmul--) {
            continue;
        }
    }

}

int plejwhu::ghmbhflvwreiflwyjmgbnlqc(string cehkgsq, double mtqmtdldfoy, string tkuomjgyxvhuxn) {
    bool omdzfbbjrnsxq = true;
    string oaabqkohjytdpd = "atuvusdyeel";
    int tbftepgrtl = 3121;
    double vnkkoedfhlok = 60424;
    string fradjsuzgmas = "wqrivxbitgcqpsusfpytarlhgbzlicykcumhzzvdlmogwjqugpiwirjsxstup";
    bool xzprqp = false;
    if (string("atuvusdyeel") == string("atuvusdyeel")) {
        int nx;
        for (nx = 32; nx > 0; nx--) {
            continue;
        }
    }
    return 31809;
}

void plejwhu::zvhgcpduuwwitrc(double dytdtkxn, int xkdjipffdvdd, double ddpkcujkku, bool ppnvaqtrovdjtq, int hvghbwd, double lqtsfbhe, string glwzdcze, bool hjajwkkzviqpk) {
    double qoyxciftnddv = 873;
    int ovdke = 2607;
    bool phkiphi = false;
    if (2607 != 2607) {
        int ohklujemp;
        for (ohklujemp = 16; ohklujemp > 0; ohklujemp--) {
            continue;
        }
    }
    if (false == false) {
        int zfcryy;
        for (zfcryy = 97; zfcryy > 0; zfcryy--) {
            continue;
        }
    }
    if (false == false) {
        int bcvzrsmws;
        for (bcvzrsmws = 100; bcvzrsmws > 0; bcvzrsmws--) {
            continue;
        }
    }

}

void plejwhu::sbtqtfblygxbyzzqzxkrwklen(bool florulixeavux, string edssgzkmqwxcy, double rftvezmqekjbd, int xwnemt) {
    bool erceontk = false;
    bool fcumjwhzixphw = true;
    int iktlkrogayq = 3247;
    bool hyohyjbbngjfubz = false;
    string hdbwgbojztqtlv = "uyfbgxmecdtokcoorucnzehelmxcmzzqoetenkzsfneqwauwfupi";
    bool yvlajojfuhsq = false;
    double xieotloyhmj = 40698;
    string wlolognhpe = "nrguadksgmmovdvvccqajflqzddcmegmjxapizzlynaorvjqodagaeaabszgigsrspcvugumvxsqnrbbpp";
    if (3247 != 3247) {
        int zuzyv;
        for (zuzyv = 73; zuzyv > 0; zuzyv--) {
            continue;
        }
    }
    if (false != false) {
        int wngat;
        for (wngat = 41; wngat > 0; wngat--) {
            continue;
        }
    }
    if (false != false) {
        int eqo;
        for (eqo = 93; eqo > 0; eqo--) {
            continue;
        }
    }
    if (false == false) {
        int nlnwusahd;
        for (nlnwusahd = 44; nlnwusahd > 0; nlnwusahd--) {
            continue;
        }
    }
    if (false == false) {
        int aivreh;
        for (aivreh = 54; aivreh > 0; aivreh--) {
            continue;
        }
    }

}

double plejwhu::imkdixsvdmsnstkanjyovddim(double beyumwyzwyhzqgs, string lsyfkyqwkudvdw) {
    string cznrhlorpxjz = "mxqwudwmxvy";
    double eeglnskwgf = 51231;
    string laignc = "xlbiunoscuunmmubncfsajdeyqokaddvktkkykirxcolgksanyvexrxtdwwpbiqujpscohwdwhsgrnpbuubvevwvyqdq";
    double xsssqsat = 19834;
    string dccybiixf = "mhczpjzdamjwmmryandvjocpdgowtrjaqhbhviainpobeajewjbvocwytzlevcbxsmahmyvdbvqyu";
    double czwwcfvvxb = 4039;
    double zjrqmjdhnbhaaa = 8271;
    double dsrfwxezxbyjldv = 51698;
    string ufzvqgnqm = "nlrxxdcipiyhyyhmjrjjisilkgfgpsmycxzoonpdsqfawntbe";
    return 31572;
}

bool plejwhu::kufukmqsiquqopyqcn(double kkymzk, bool uketiglvpdqhh, bool kdwonvvgmfmehns, bool afzax, int yvzwfiaxlmexxy, double aqyeu, int fpshhj) {
    bool cwonlbmspub = true;
    int qbvuiucsuvzem = 164;
    string gsrgapmcoq = "zlvpqjfmtlemvksuwbszxoqqptfqmycldygxmfvqrjzdsachpzzhxgxasduxfkpfqgorz";
    int nwihlj = 517;
    string hnfwyehfdjin = "wltrs";
    bool genqs = true;
    string twlvp = "ljtbqorjcaruktv";
    double ihzkvefynlthew = 34043;
    if (34043 != 34043) {
        int qwn;
        for (qwn = 5; qwn > 0; qwn--) {
            continue;
        }
    }
    return false;
}

double plejwhu::vamdbarjnggrretsyuglfmzi(int nndomkvsct, bool kcjhnxzkcv, string vlmwdpnwcpf, bool lktbyqjkskc, string mrlvwxcmngjqgy, double hhygxygevhpw, string lcmlrxzeub, string zkisdydf, double cmzcsyyseixygs) {
    double lbacz = 26160;
    bool uxugdiyoo = true;
    string jjqtrxakfw = "wwmqpphufxufacrngnpqzzufniuadpqdzsahtuwbmcycnuvkmsxwgjbzwqecxm";
    int yztgphu = 4662;
    string hsdvdguvfbymv = "rmkxuyovjz";
    bool enxntav = true;
    string wuniymgcibjlomb = "jmtsougfquszztsdztwotnzfazwffoissjrfeuoehnzkygoeqixejhtfdayfzggqypjeck";
    string cmllwmtrhksv = "pwftgwmyjxfznsjgpfbifrviunopbmwyielpctujqrzndqcgwfubnwonmrcsuwiecjapgpmmkqvcrvzfoufjny";
    if (string("rmkxuyovjz") != string("rmkxuyovjz")) {
        int wntt;
        for (wntt = 3; wntt > 0; wntt--) {
            continue;
        }
    }
    if (4662 != 4662) {
        int jfxmuhpv;
        for (jfxmuhpv = 8; jfxmuhpv > 0; jfxmuhpv--) {
            continue;
        }
    }
    return 26630;
}

double plejwhu::bmwdidbhwvwlptnqzd(double vkkbeufpjkycz, int rarytcqezj, double vrtyqnaye, double mqwvy, int ngekfzcbdkp, string evfaeueq, double mqxwkjkn, double uztthviwhhh, int qnfhkmkn) {
    return 31733;
}

plejwhu::plejwhu() {
    this->ghmbhflvwreiflwyjmgbnlqc(string("wmoyfmwryiquunkgphqlvgulbeuedhwjcgr"), 3035, string("ybrwisstazeprhdqvwfowo"));
    this->zvhgcpduuwwitrc(16001, 4083, 20086, true, 682, 10313, string("gsioiuwoftzuggdsjnvzgfwowfnlhrofcgtoolssyziljpdrsdmxvxztxocfynzdkpmxyduodmigiibjztbjksphxgotjzzl"), false);
    this->sbtqtfblygxbyzzqzxkrwklen(true, string("gykwvyycrjtki"), 20597, 686);
    this->imkdixsvdmsnstkanjyovddim(28007, string("cnttsvdlzlkmzhoacjvmdrofhavszkjlorxsbbmriwlefkkrqnewrmbckuliwndyxidzidketvni"));
    this->kufukmqsiquqopyqcn(87272, true, true, true, 1318, 10263, 4803);
    this->vamdbarjnggrretsyuglfmzi(707, true, string("ewnnydrtpqifzfis"), false, string("cyskvqsfvckrzwwhlcopkhojottjpsdzlxfydyxvwzhifwzrnfeyfowpbzypp"), 21452, string("dysdjtqgwmgdvymznsomevzgszsrvnzjvivrgpcqnpkncmkeawpvffbolgpulrfgmocumczx"), string("llmjctgbzlmjcpactpibgixebjscdeeefdvguwtqjsjaqjgynwxtigzsnwxdvhxyeiqsxpjztvz"), 35296);
    this->bmwdidbhwvwlptnqzd(18454, 3677, 7090, 14859, 1255, string("nbomftgzhtyugtldibmdjvrytioxxpwzkhndgmhhsrgnzivtaptrizxuigdkfcynnrftmzyn"), 54219, 67696, 844);
    this->lpbshgusatjenefxszpbia(false, true, false, 7595, 1397, 12963, string("tkndzaepffnnzyloirqcxmhiqmqdjaqbstgbhjjdvwpype"), 6552);
    this->rjzclyxoqsl(9458, 4189, 7665, true);
    this->mbkrpnuynopptlukdk(true, 29658, 14123, true, 66028, string("mktceljxqjbkvkwfwartkbhkkqbrhuobthbiatodgfsxbupglddcgaldqrdtyh"), false, 10355, 1854);
    this->lqifvgquwi(209, string("wacpwdlarlspvzzlghklmfhqigbi"), false, false);
    this->rdrehhtkaffofyzubmox(33391, 32530, true, string("hjwnltfkwstlgdzroecwrohfxmzqggctzvypljvguqkxsqmlnbjfqm"), false, 5912, string("wpxcnfpcnczzbnkxfqdaclzjkcahazpjkrhteplhtesijfnyzlggwzmekltedseywgcqggtyaklvvwwwbiaenvnnl"), 13186, false, string("atlozvwvpzzqhmcqnvbuii"));
    this->fxgkoxdgvnaqxpratt();
    this->eqgylzhxmmjzqwkrgn();
    this->yykypoxzjijfxv(24580, 4687, 3155, false, 22096, 10493, 3700);
    this->hjvpyhqvuzegbzssyl();
    this->auwimpqzbnqrqeujmyctizapx(2449);
    this->rizkklbignhmbevs();
    this->ygoozptvoituofewjnkhpwe(1050, false, false, 1049, 76871, string("cyhxzrswzzjbgqewfjenycfynnaqimgkswlpxredmdyjlkepubkpmgrevm"), 15860);
    this->qnzokfpcrkofebuzis(string("emelmgpjqfgxjiaynqoujenffnoumugpiyerhxrtpqdiyumlfncvhnyphzgaccazssluyqjuyjuelhfmmwjypnzj"), 57267, true, 4499, 7984);
    this->pdryybsgefoxs();
}


#pragma endregion

#pragma region J2

using namespace std;

class jhoweis {
public:
    bool eswzwkm;
    string bphweaeigu;
    int hucarjnpkrtq;
    jhoweis();
    bool dcyoubxydaonzgnnfxqfnjbss(bool iclhhy, string nsryrvxgafqi, bool lznrpebck, bool rsgklppckkqwzo, int htfwsvegmmcd, double ilvuq, double mcjlx, double olbrhkuyrogi, int sclckj);
    int rbiltfobqfxvjfazhjomlduc(double alfuqacqqmftxw, string iknerpfvpskesc, bool aappl, bool qjnsmfjk, int vxbvfohyplx, int svwsrwpwwdmwq);
    string gslhlqbwjlpvaegufankyrif(int dpdwssiemntup, bool cssfyhbu, double gzxajhezqtkq, bool srqvelk, double ulqgjjs, double xhibdyhsqhzmaz);
    int iiwvhjgpdkaekaavexwnvo(double ljmstp, int cmvehkjbd, bool rloaso, string orzwwtljrpuqgfs, int gjyaalhhyzuvd, string rkkyuhtjkvzuo, string usgyuiferakqns);
    int dybrlaobppwdikdyjm(string uwkksudarvk, int qwjpbfsbye, int osobkwaghca, int yfpeybrbs);
    double ieuwniuuwwuoxjpyiy();
    int jszcntdxjsmticsghhzwyzxme(string ckikq, double rutensfix, bool qyajsso, int aslqfmxsqubbvgr, double meqgmlwa, double jkdknwpgnhvs, double brlztwof, int fzpltrkftiaadzr, bool ymbynqcetcwep);
    bool soadiudhwnalyj(bool ecbggb, bool bpbxrkmvvkd, double efwxg, string gvwfschic, bool hbjodpytmguvdp, bool zivnptsnlh);
    void lynfdxvgozahpsnruatdbhgli();
    double nmnazrgxlpzfjgxrfbci(string bcznheupm, int ovtuxviwlvxpj, bool ikkhgsznf, int oldzrkqjluu, double tgbzugnttqddcpt, double wwcggokdykusvni, string yfsdqtpbdpnhg, bool bxdngamngzdqw, int tkrrjyeuwmdxm);

protected:
    bool jpdsyodqo;
    double zddiypdia;
    double bsuclsqclllj;

    void dwrbcymbveplbdzncib(string rvzgpbyni, double iwfjtbwvxq, bool cmikzbdkatdhogg, double naprzqadog, bool fofdli, bool llmftcovb, int lsugckvofsmgrb, double ndbxmckx, string vleqorrdkzh);
    string xhecefctahgoeqa(double gdmmi, string vmnkpeyowe, int kbohws, string wevagwrvjdxy, string vstydec, double hliapkhqtsdvb, bool wmzfddfhxinb, string xihqz);
    void bacwabkeqrjcr(string wugyrvlkmdfbvt, int jjadfqmebhgff, double ljhdzicefhsrazd, double wubuizkhubs, int evrfjtx);
    bool daanwvnvizobcuxsprpngg(int boqsxxrgdttm, double omjhtyccnknmee, bool gjeatsunwduhx, double yzoywdtnsrqwpd, string hcxzfzoicn, string tsygftmnfrb, string vslwqzhyok);
    void sqwwywfivekowlkqjlyuxy(double istkvyp, double hpornxztlxzv, bool cgveyy, string uitonbezi, double dqkwr, int jndlbl, double tixasgooid, string lilywsqv, int kpssejmetv, string bdcbqylnqn);
    int rjjpnkuvivoiiwbu(string vdgyohmjftqgxf, string qbfajxzabzzjc, string hvxcnhruzd, string demtsjblcpzuf, string fvarwjenfq, string tvrdcsaf, double tlutbebpt, string bfodhx);

private:
    string pecfinkigegzmw;
    double sgxjs;
    bool txaqzinfsiqe;

    double exxzksrmpd(bool nbbcwag, int drdlrzue);
    bool frjlcwvnneoxakhcr(string ijbwy, bool wrgsmkdoqwcfb, bool rajfc, int fcpbcwapfiqwrms, double sefjxexokrz, int erxcjhgwwspc);
    void sghadruzdjdkvponpxqeubo(bool ssfbheswquoyho, int izfjtrup, bool ktvfulxq);
    double jvqfbkbshemzavlem();
    int bgjuomaljdun(double aqponuisz, bool yuhwlcizpwwer);
    string hefqluuangelprhnpjknfx(bool dizzg);
    bool mvjivdlqfmvlcxiekbprbgflt(string fejbdozgfhgcep, int rcqycww, string cwqutynlgli, string fqpaxzsptrmprxw, int oedgosbyj, bool oogttzysbp);

};


double jhoweis::exxzksrmpd(bool nbbcwag, int drdlrzue) {
    double zamwvpr = 27722;
    double zsjhxivjvbedon = 46085;
    if (46085 == 46085) {
        int hwt;
        for (hwt = 95; hwt > 0; hwt--) {
            continue;
        }
    }
    return 67454;
}

bool jhoweis::frjlcwvnneoxakhcr(string ijbwy, bool wrgsmkdoqwcfb, bool rajfc, int fcpbcwapfiqwrms, double sefjxexokrz, int erxcjhgwwspc) {
    int whwpeialze = 305;
    bool yrmpehlktznctns = true;
    int qpwtsyqjrh = 2579;
    double yifiib = 14604;
    bool netanktu = false;
    double rqgvlgdvdza = 14095;
    bool pyzoib = false;
    string vyyowtihb = "prwrdpqghvjfmmdhtkrvrpdafuwpv";
    return false;
}

void jhoweis::sghadruzdjdkvponpxqeubo(bool ssfbheswquoyho, int izfjtrup, bool ktvfulxq) {
    int sglvrbe = 5168;
    double yoyqplmpzjeqh = 6098;
    bool ozwtyfymxlngjr = false;
    int dgcfdljqijnf = 4501;
    if (5168 == 5168) {
        int awipgha;
        for (awipgha = 92; awipgha > 0; awipgha--) {
            continue;
        }
    }
    if (false != false) {
        int bd;
        for (bd = 68; bd > 0; bd--) {
            continue;
        }
    }

}

double jhoweis::jvqfbkbshemzavlem() {
    double ywmzlpfbnewaffr = 37439;
    int wxlqq = 3117;
    string zjdjuvh = "gchlawtngeyuoaepcoqrscrgfmbxefhrafxmhzvcfouinzvdwpgnqoz";
    int acgmlgrjfqgx = 4669;
    string owbpcijp = "zjfvravlfqcrqmamxhnxzmggjwkprqutmcbuwntwdowikylr";
    string pkzseegmhxf = "norbbargbdraonlvlodnnbjjshujdffgfgifisqtoc";
    double aavyqwkmjvkck = 30221;
    double sbmybuy = 24721;
    double drvsrpxqcmxly = 8489;
    double wcsqtbtzdfymld = 6903;
    if (4669 == 4669) {
        int jezjpikao;
        for (jezjpikao = 42; jezjpikao > 0; jezjpikao--) {
            continue;
        }
    }
    if (string("zjfvravlfqcrqmamxhnxzmggjwkprqutmcbuwntwdowikylr") == string("zjfvravlfqcrqmamxhnxzmggjwkprqutmcbuwntwdowikylr")) {
        int cpctkysy;
        for (cpctkysy = 91; cpctkysy > 0; cpctkysy--) {
            continue;
        }
    }
    if (8489 == 8489) {
        int vqbr;
        for (vqbr = 5; vqbr > 0; vqbr--) {
            continue;
        }
    }
    if (4669 == 4669) {
        int ewp;
        for (ewp = 54; ewp > 0; ewp--) {
            continue;
        }
    }
    if (8489 == 8489) {
        int qcroxg;
        for (qcroxg = 69; qcroxg > 0; qcroxg--) {
            continue;
        }
    }
    return 77668;
}

int jhoweis::bgjuomaljdun(double aqponuisz, bool yuhwlcizpwwer) {
    double cfonwoniw = 9129;
    double gjayznarvxt = 13299;
    int hytpsb = 628;
    if (628 != 628) {
        int csv;
        for (csv = 12; csv > 0; csv--) {
            continue;
        }
    }
    if (628 == 628) {
        int edos;
        for (edos = 35; edos > 0; edos--) {
            continue;
        }
    }
    return 64877;
}

string jhoweis::hefqluuangelprhnpjknfx(bool dizzg) {
    bool oatiuththmonkx = false;
    double yffbkemhpyoh = 14080;
    int rdrlxgvpjqpox = 2175;
    string jluxoupwfx = "uklorctnawaoqomnqmzyimskmjgogestmpnaksaaadrwvbgzha";
    string dqmuktvo = "dptzytmhev";
    if (14080 != 14080) {
        int zqb;
        for (zqb = 5; zqb > 0; zqb--) {
            continue;
        }
    }
    if (string("dptzytmhev") == string("dptzytmhev")) {
        int dueixjlkb;
        for (dueixjlkb = 84; dueixjlkb > 0; dueixjlkb--) {
            continue;
        }
    }
    if (false != false) {
        int ryujzykz;
        for (ryujzykz = 99; ryujzykz > 0; ryujzykz--) {
            continue;
        }
    }
    return string("hth");
}

bool jhoweis::mvjivdlqfmvlcxiekbprbgflt(string fejbdozgfhgcep, int rcqycww, string cwqutynlgli, string fqpaxzsptrmprxw, int oedgosbyj, bool oogttzysbp) {
    int piwcednueqj = 558;
    bool kujzfgil = false;
    return false;
}

void jhoweis::dwrbcymbveplbdzncib(string rvzgpbyni, double iwfjtbwvxq, bool cmikzbdkatdhogg, double naprzqadog, bool fofdli, bool llmftcovb, int lsugckvofsmgrb, double ndbxmckx, string vleqorrdkzh) {
    double winyhbchqoekms = 27736;
    string vgjnwjemklpzqne = "zxydcazkenrgohsttckyjokyigfofpligmyjnqhsqdqkokjuirezmwgeakdhvnagntulpftt";
    string glrdghott = "ltofloskwigitohofyppxztdkprpgqoxotmylqtxzybqtrojhhwjfrdniuvrfgejigekqrehhhdozhmxfbuptuouhhtokn";
    double zhnczbrugbsxjea = 28830;
    int fabfkfzhrpmcejx = 6941;
    bool lumqour = false;
    bool kkrujdmdw = true;
    string gcchytsy = "sxceyaadgbcsggwhqqwnqzxothvaujlhmdcjchavlkbpawvqiuoolibaasbyygbmnpzpx";
    int bvxanhhthmwnj = 4898;
    if (false == false) {
        int gtocuzl;
        for (gtocuzl = 70; gtocuzl > 0; gtocuzl--) {
            continue;
        }
    }
    if (string("ltofloskwigitohofyppxztdkprpgqoxotmylqtxzybqtrojhhwjfrdniuvrfgejigekqrehhhdozhmxfbuptuouhhtokn") == string("ltofloskwigitohofyppxztdkprpgqoxotmylqtxzybqtrojhhwjfrdniuvrfgejigekqrehhhdozhmxfbuptuouhhtokn")) {
        int wj;
        for (wj = 88; wj > 0; wj--) {
            continue;
        }
    }
    if (6941 == 6941) {
        int tigngbn;
        for (tigngbn = 75; tigngbn > 0; tigngbn--) {
            continue;
        }
    }

}

string jhoweis::xhecefctahgoeqa(double gdmmi, string vmnkpeyowe, int kbohws, string wevagwrvjdxy, string vstydec, double hliapkhqtsdvb, bool wmzfddfhxinb, string xihqz) {
    string uhzgqyolmyya = "xfdgtdcafgmmmkvorhapembxddtdbioefasvaviniomkdsomsybbgj";
    int uwhqibdaw = 1241;
    int yctcewfm = 3437;
    bool ewgft = true;
    string ggpwe = "bghsrignjpqskouwvtnpz";
    string tecdvaeuo = "rxsnvjcvtwhizlswvidheguiw";
    double pgocifsviofn = 1265;
    bool uxmucmkdvmy = true;
    if (1241 == 1241) {
        int duitfzbchd;
        for (duitfzbchd = 77; duitfzbchd > 0; duitfzbchd--) {
            continue;
        }
    }
    return string("uvksmwyf");
}

void jhoweis::bacwabkeqrjcr(string wugyrvlkmdfbvt, int jjadfqmebhgff, double ljhdzicefhsrazd, double wubuizkhubs, int evrfjtx) {
    string jfnwqlrqxitq = "qnyqhcammzoqlsvsdjeqaxddwmkjr";
    string pgcfms = "slzimfbbjdhhqgongmnaeouohngydfvm";
    bool dkdgpdggucdbr = true;

}

bool jhoweis::daanwvnvizobcuxsprpngg(int boqsxxrgdttm, double omjhtyccnknmee, bool gjeatsunwduhx, double yzoywdtnsrqwpd, string hcxzfzoicn, string tsygftmnfrb, string vslwqzhyok) {
    string owimqsmgpj = "";
    int kyashfodyogkabj = 715;
    if (string("") == string("")) {
        int nixdb;
        for (nixdb = 50; nixdb > 0; nixdb--) {
            continue;
        }
    }
    if (string("") != string("")) {
        int lclfji;
        for (lclfji = 47; lclfji > 0; lclfji--) {
            continue;
        }
    }
    if (string("") != string("")) {
        int wendznyh;
        for (wendznyh = 60; wendznyh > 0; wendznyh--) {
            continue;
        }
    }
    return false;
}

void jhoweis::sqwwywfivekowlkqjlyuxy(double istkvyp, double hpornxztlxzv, bool cgveyy, string uitonbezi, double dqkwr, int jndlbl, double tixasgooid, string lilywsqv, int kpssejmetv, string bdcbqylnqn) {

}

int jhoweis::rjjpnkuvivoiiwbu(string vdgyohmjftqgxf, string qbfajxzabzzjc, string hvxcnhruzd, string demtsjblcpzuf, string fvarwjenfq, string tvrdcsaf, double tlutbebpt, string bfodhx) {
    int exdcisbmpsjtv = 2655;
    bool frzwid = false;
    string bphpuewwysen = "tkxrsgpgdeigxlfvupojkzgqxmyfmidbamwocebkkiegkarlqgiwhkjvgkhxduqsqjdxneijndeiuixxpeujgjogduf";
    string vavhtanuabrzcfc = "fpotwjuewhovvhpchgywxfoccie";
    double uzietg = 17849;
    string ahryajjdzedbtm = "lflqrwlsfqgvgxlvxvatpxtilaxaakyeidyxqmkmkjpyxfngeqphyvftjnlwmzncrmnbqleaxhqekybob";
    int yiddzrcnevokmdt = 681;
    int vjaebtthxyavu = 487;
    int qjmnferfnofqk = 522;
    if (522 != 522) {
        int dnpsolane;
        for (dnpsolane = 63; dnpsolane > 0; dnpsolane--) {
            continue;
        }
    }
    if (487 == 487) {
        int yvdrc;
        for (yvdrc = 8; yvdrc > 0; yvdrc--) {
            continue;
        }
    }
    if (487 == 487) {
        int ev;
        for (ev = 75; ev > 0; ev--) {
            continue;
        }
    }
    return 18397;
}

bool jhoweis::dcyoubxydaonzgnnfxqfnjbss(bool iclhhy, string nsryrvxgafqi, bool lznrpebck, bool rsgklppckkqwzo, int htfwsvegmmcd, double ilvuq, double mcjlx, double olbrhkuyrogi, int sclckj) {
    double qugfrrx = 33581;
    string meycruwymyr = "agmgnlxepmxvngof";
    if (33581 != 33581) {
        int yromd;
        for (yromd = 50; yromd > 0; yromd--) {
            continue;
        }
    }
    if (string("agmgnlxepmxvngof") == string("agmgnlxepmxvngof")) {
        int xujatalxr;
        for (xujatalxr = 60; xujatalxr > 0; xujatalxr--) {
            continue;
        }
    }
    if (33581 == 33581) {
        int wvmpbrbe;
        for (wvmpbrbe = 24; wvmpbrbe > 0; wvmpbrbe--) {
            continue;
        }
    }
    if (string("agmgnlxepmxvngof") == string("agmgnlxepmxvngof")) {
        int hbzsv;
        for (hbzsv = 59; hbzsv > 0; hbzsv--) {
            continue;
        }
    }
    return false;
}

int jhoweis::rbiltfobqfxvjfazhjomlduc(double alfuqacqqmftxw, string iknerpfvpskesc, bool aappl, bool qjnsmfjk, int vxbvfohyplx, int svwsrwpwwdmwq) {
    int ahbqqymduls = 4860;
    int ynrpvnmk = 3615;
    bool ifivnxkotiuxf = true;
    int nepkxnj = 527;
    string adxmnkfvqueyq = "rbsopaltwweypgqjyvbljbnvdmsnzjdpnjtlomckcvfgepzkbayhymzookwboluhbtrttyh";
    string stghy = "vcfopxynjsjgnofntwyqaigiojgirhknjeykopweqxlxdihd";
    bool qsmjcuze = false;
    if (4860 != 4860) {
        int ikwmu;
        for (ikwmu = 77; ikwmu > 0; ikwmu--) {
            continue;
        }
    }
    if (false != false) {
        int buj;
        for (buj = 26; buj > 0; buj--) {
            continue;
        }
    }
    return 61455;
}

string jhoweis::gslhlqbwjlpvaegufankyrif(int dpdwssiemntup, bool cssfyhbu, double gzxajhezqtkq, bool srqvelk, double ulqgjjs, double xhibdyhsqhzmaz) {
    string nwzalkz = "neierlkaiaprsjahrnsdygyxenkrgx";
    if (string("neierlkaiaprsjahrnsdygyxenkrgx") == string("neierlkaiaprsjahrnsdygyxenkrgx")) {
        int hcldcvq;
        for (hcldcvq = 44; hcldcvq > 0; hcldcvq--) {
            continue;
        }
    }
    return string("rpbyexuydcbwrooa");
}

int jhoweis::iiwvhjgpdkaekaavexwnvo(double ljmstp, int cmvehkjbd, bool rloaso, string orzwwtljrpuqgfs, int gjyaalhhyzuvd, string rkkyuhtjkvzuo, string usgyuiferakqns) {
    int xzuplehhtchlau = 7985;
    double csxknyslrxys = 17176;
    bool xxrthzbyiijbll = false;
    if (false != false) {
        int ttzxqgcudv;
        for (ttzxqgcudv = 60; ttzxqgcudv > 0; ttzxqgcudv--) {
            continue;
        }
    }
    return 90020;
}

int jhoweis::dybrlaobppwdikdyjm(string uwkksudarvk, int qwjpbfsbye, int osobkwaghca, int yfpeybrbs) {
    bool oljbgipjzmx = false;
    string czyrzbsa = "fbexvtkekimykbzxzmenxxbu";
    string usjljmst = "ktvmzqwfcmuarpdewtqarihuwrojqmdwzfeyqifdrphuxlluccxrj";
    string epqwkcyfnx = "hongnxggpoglomczokpybxnlwrnqbbuhqwazzguekoiduaakcgoukwbvtwauaniayfqznbwx";
    string lkafwhpw = "jxidjjdzjbrteykagcajwpvwqpltjxcwfqwocjivmeezmowqzpvpdrbhxnxijmihjgvx";
    string dvvpwqzrtswxc = "acwrwywj";
    bool hdxzlhkspdm = false;
    double czweozxydl = 40630;
    int ubwoczvpams = 1510;
    bool tudjp = true;
    if (1510 == 1510) {
        int ybof;
        for (ybof = 8; ybof > 0; ybof--) {
            continue;
        }
    }
    if (string("jxidjjdzjbrteykagcajwpvwqpltjxcwfqwocjivmeezmowqzpvpdrbhxnxijmihjgvx") == string("jxidjjdzjbrteykagcajwpvwqpltjxcwfqwocjivmeezmowqzpvpdrbhxnxijmihjgvx")) {
        int wiurikd;
        for (wiurikd = 26; wiurikd > 0; wiurikd--) {
            continue;
        }
    }
    if (false != false) {
        int eqqd;
        for (eqqd = 25; eqqd > 0; eqqd--) {
            continue;
        }
    }
    return 36337;
}

double jhoweis::ieuwniuuwwuoxjpyiy() {
    return 71016;
}

int jhoweis::jszcntdxjsmticsghhzwyzxme(string ckikq, double rutensfix, bool qyajsso, int aslqfmxsqubbvgr, double meqgmlwa, double jkdknwpgnhvs, double brlztwof, int fzpltrkftiaadzr, bool ymbynqcetcwep) {
    int uwzahghiyjcofb = 915;
    string uxyylyejzc = "niqpksnipfmhksmpbcszireauwghuiutygpvsnoxlkydengrapoavoxfshijpgsdsoy";
    if (915 == 915) {
        int tgue;
        for (tgue = 16; tgue > 0; tgue--) {
            continue;
        }
    }
    if (string("niqpksnipfmhksmpbcszireauwghuiutygpvsnoxlkydengrapoavoxfshijpgsdsoy") != string("niqpksnipfmhksmpbcszireauwghuiutygpvsnoxlkydengrapoavoxfshijpgsdsoy")) {
        int rtpotbc;
        for (rtpotbc = 23; rtpotbc > 0; rtpotbc--) {
            continue;
        }
    }
    if (string("niqpksnipfmhksmpbcszireauwghuiutygpvsnoxlkydengrapoavoxfshijpgsdsoy") == string("niqpksnipfmhksmpbcszireauwghuiutygpvsnoxlkydengrapoavoxfshijpgsdsoy")) {
        int fzpuxwv;
        for (fzpuxwv = 49; fzpuxwv > 0; fzpuxwv--) {
            continue;
        }
    }
    if (string("niqpksnipfmhksmpbcszireauwghuiutygpvsnoxlkydengrapoavoxfshijpgsdsoy") != string("niqpksnipfmhksmpbcszireauwghuiutygpvsnoxlkydengrapoavoxfshijpgsdsoy")) {
        int wdkwvat;
        for (wdkwvat = 21; wdkwvat > 0; wdkwvat--) {
            continue;
        }
    }
    if (string("niqpksnipfmhksmpbcszireauwghuiutygpvsnoxlkydengrapoavoxfshijpgsdsoy") != string("niqpksnipfmhksmpbcszireauwghuiutygpvsnoxlkydengrapoavoxfshijpgsdsoy")) {
        int uosdfrhys;
        for (uosdfrhys = 65; uosdfrhys > 0; uosdfrhys--) {
            continue;
        }
    }
    return 46499;
}

bool jhoweis::soadiudhwnalyj(bool ecbggb, bool bpbxrkmvvkd, double efwxg, string gvwfschic, bool hbjodpytmguvdp, bool zivnptsnlh) {
    bool wqahugrsp = true;
    string hqzrt = "ltenfigmtjiucgqwlniyxpwkxbhbgvvjlrobvuzbvtgcjrtqxhvsjujvuuvkjqprdctkzhhikehbwluxvwolvbl";
    int nzaacgjuidsyuxs = 2627;
    double mwqshaxkp = 32456;
    string byrljyioyhvvvzb = "mndqzunkmmhahbwswvwhdbssgslvthwjskwi";
    double pkybuhd = 20762;
    int kwcuewfjfbd = 4081;
    int jdmryje = 5250;
    return true;
}

void jhoweis::lynfdxvgozahpsnruatdbhgli() {
    string iumttqpvypocnq = "srxuhtfwljhcyyp";
    double eunyxzvji = 37002;
    double vnwwywzdkwsxb = 36974;
    int xcipxvubwriyxk = 4515;
    string mpvrsl = "bhlowyrmbkmaolvqxyldotyhdbvcbkrlwxgdhlizkfnlspzminmlhccthdum";
    double uxujrvsgnw = 71022;
    bool pqstjmhyticil = true;
    if (37002 != 37002) {
        int wthebfsvf;
        for (wthebfsvf = 96; wthebfsvf > 0; wthebfsvf--) {
            continue;
        }
    }

}

double jhoweis::nmnazrgxlpzfjgxrfbci(string bcznheupm, int ovtuxviwlvxpj, bool ikkhgsznf, int oldzrkqjluu, double tgbzugnttqddcpt, double wwcggokdykusvni, string yfsdqtpbdpnhg, bool bxdngamngzdqw, int tkrrjyeuwmdxm) {
    return 51275;
}

jhoweis::jhoweis() {
    this->dcyoubxydaonzgnnfxqfnjbss(true, string("nndjwhtbbrtifkfknlnntzenhspsjlgxvqsqoexaqnedcmcvssaackmfkpuezeiotgkksycx"), false, false, 2351, 1354, 81215, 4734, 4723);
    this->rbiltfobqfxvjfazhjomlduc(38007, string("yidxn"), false, false, 3967, 752);
    this->gslhlqbwjlpvaegufankyrif(3026, false, 36298, true, 11392, 7898);
    this->iiwvhjgpdkaekaavexwnvo(61415, 521, true, string("rmmgjmtybyhrhkgbucpxgzbauttwcptedspawxmfuuuwkzxjptndjgvebf"), 1912, string("pvylmuszosmmrgxqievfuqzjkktshhii"), string("verggtnpqodiotjhbotbytjrgvsmfssiigrycriufccxlyemnixmgkmxzeorx"));
    this->dybrlaobppwdikdyjm(string("lrfoaoukxxzxonkfqepieinwhjuwijjistcqjcahegfaabkeqeuuwijvxk"), 2914, 1838, 461);
    this->ieuwniuuwwuoxjpyiy();
    this->jszcntdxjsmticsghhzwyzxme(string("hepqpxryxkvjkvswdfveoyvzdaibqnduwowjldcmyfkjoxptwvbysfqnzdkkywuyxh"), 10027, false, 972, 16687, 21683, 74866, 4108, false);
    this->soadiudhwnalyj(false, true, 9156, string("guwgzlfnnbhnucztetfyzsjdwgurmsktpfjnxfmergfmmlccsivjokydnapsxswbztytznshwybxoykxatfjwytwr"), true, true);
    this->lynfdxvgozahpsnruatdbhgli();
    this->nmnazrgxlpzfjgxrfbci(string("j"), 3185, false, 2731, 18647, 3272, string("wndpxnxd"), true, 2900);
    this->dwrbcymbveplbdzncib(string("nrxafbteuuzqnhhmedsyjjgszmxllamatfnrqeuiawlroapzexiisscwr"), 20822, false, 95993, false, true, 1076, 33814, string("pawvdymraghhfohogbhgxcybnsnmbsdjjycahdulhbttqdjimvgpavatpqwkmmlvhzoxmklc"));
    this->xhecefctahgoeqa(38127, string("qrqbufabgjrphfzyydtbdtjvdefjvbwelndsuboptv"), 587, string("cpfguqykblqfviechmoymrrxphaidzpambejwqfidpipkgwfpvweougdaaznzx"), string("nuormlwvrcncukdhzoknsucnygqkqekwsamwpcndxkuuvoyhz"), 17376, true, string("ocvvdofflvox"));
    this->bacwabkeqrjcr(string("gbtpshtukclfnjwawcvoszkzudctnqkvnxcwnlrrtnhucpfdanokzllhptxgwj"), 939, 19695, 46189, 1490);
    this->daanwvnvizobcuxsprpngg(223, 27658, false, 66408, string("pvflerlhlxcxacaqgyubuqcctfvfhxwssrxmhpckwbsinnanlfngr"), string("xcbdceafbcmbocmbabkkpvoivdciuccrei"), string("qmbsuupbifapzqitetplolzceslkdslbgwwqrdmfofebcrfauneejmjkrfxkwhfezenkdrkgcwrglacqmn"));
    this->sqwwywfivekowlkqjlyuxy(990, 16937, true, string("ddwmxghynrxhlsk"), 10871, 6326, 41809, string("apvlhxsnyvpigowafbegfsuucdvmczflmoogmdczlqalecbejgonvvfznaimykiiqptbeh"), 5697, string("iukoutrrbicqmkkrdcjrphovljwhixkttrnfzgkaideytwkctypvdto"));
    this->rjjpnkuvivoiiwbu(string("nvxqymbpyjxwoyfjwuztjoaojksmiqwacytefow"), string("gqnuzfolrlsgcdzngnlcjyofeqmrohkbueizqrcvhytr"), string("fffkqmwgmaaeljfhonhkphfjjtogviuhqbyzktrqsnuyzgjqznphxxiqddjfyqj"), string("zbmitpotmruhaihnrpflqejjtywddqetokffadddshtdalqgczovsqmaltjhagsmuogx"), string("ogcuideszuhfmjaeoeqvuidelrwokmchrrivlrkijxxgwhppixvspamqfgbgrt"), string("wlgipicyipouooxyjjeoumnqkyljxuqgffpheamokffpkgulypzcloeipsswqpijcfjazufwzgcevvcnqmmfzv"), 7455, string("mjnlx"));
    this->exxzksrmpd(false, 217);
    this->frjlcwvnneoxakhcr(string("tjousunfbgmkriegsxmshlqoruxv"), false, true, 3584, 21980, 5269);
    this->sghadruzdjdkvponpxqeubo(true, 2138, true);
    this->jvqfbkbshemzavlem();
    this->bgjuomaljdun(23011, true);
    this->hefqluuangelprhnpjknfx(false);
    this->mvjivdlqfmvlcxiekbprbgflt(string("uovkgojmgqwgohmnxagyedytxqvjyjxcqijewatrhjxetijbssye"), 1587, string("tiwnloucgdvcscqxvxb"), string("smxmatcwewvqoaum"), 3773, false);
}

#pragma endregion


// dear imgui: Platform Binding for Windows (standard windows API for 32 and 64 bits applications)
// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)

// Implemented features:
//  [X] Platform: Clipboard support (for Win32 this is actually part of core dear imgui)
//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.
//  [X] Platform: Keyboard arrays indexed using VK_* Virtual Key Codes, e.g. ImGui::IsKeyPressed(VK_SPACE).
//  [X] Platform: Gamepad support. Enabled with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.

#include "imgui.h"
#include "imgui_impl_win32.h"
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <tchar.h>

// Using XInput library for gamepad (with recent Windows SDK this may leads to executables which won't run on Windows 7)
#ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD
#include <XInput.h>
#else
#define IMGUI_IMPL_WIN32_DISABLE_LINKING_XINPUT
#endif
#if defined(_MSC_VER) && !defined(IMGUI_IMPL_WIN32_DISABLE_LINKING_XINPUT)
#pragma comment(lib, "xinput")
//#pragma comment(lib, "Xinput9_1_0")
#endif

// CHANGELOG
// (minor and older changes stripped away, please see git history for details)
//  2020-03-03: Inputs: Calling AddInputCharacterUTF16() to support surrogate pairs leading to codepoint >= 0x10000 (for more complete CJK inputs)
//  2020-02-17: Added ImGui_ImplWin32_EnableDpiAwareness(), ImGui_ImplWin32_GetDpiScaleForHwnd(), ImGui_ImplWin32_GetDpiScaleForMonitor() helper functions.
//  2020-01-14: Inputs: Added support for #define IMGUI_IMPL_WIN32_DISABLE_GAMEPAD/IMGUI_IMPL_WIN32_DISABLE_LINKING_XINPUT.
//  2019-12-05: Inputs: Added support for ImGuiMouseCursor_NotAllowed mouse cursor.
//  2019-05-11: Inputs: Don't filter value from WM_CHAR before calling AddInputCharacter().
//  2019-01-17: Misc: Using GetForegroundWindow()+IsChild() instead of GetActiveWindow() to be compatible with windows created in a different thread or parent.
//  2019-01-17: Inputs: Added support for mouse buttons 4 and 5 via WM_XBUTTON* messages.
//  2019-01-15: Inputs: Added support for XInput gamepads (if ImGuiConfigFlags_NavEnableGamepad is set by user application).
//  2018-11-30: Misc: Setting up io.BackendPlatformName so it can be displayed in the About Window.
//  2018-06-29: Inputs: Added support for the ImGuiMouseCursor_Hand cursor.
//  2018-06-10: Inputs: Fixed handling of mouse wheel messages to support fine position messages (typically sent by track-pads).
//  2018-06-08: Misc: Extracted imgui_impl_win32.cpp/.h away from the old combined DX9/DX10/DX11/DX12 examples.
//  2018-03-20: Misc: Setup io.BackendFlags ImGuiBackendFlags_HasMouseCursors and ImGuiBackendFlags_HasSetMousePos flags + honor ImGuiConfigFlags_NoMouseCursorChange flag.
//  2018-02-20: Inputs: Added support for mouse cursors (ImGui::GetMouseCursor() value and WM_SETCURSOR message handling).
//  2018-02-06: Inputs: Added mapping for ImGuiKey_Space.
//  2018-02-06: Inputs: Honoring the io.WantSetMousePos by repositioning the mouse (when using navigation and ImGuiConfigFlags_NavMoveMouse is set).
//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.
//  2018-01-20: Inputs: Added Horizontal Mouse Wheel support.
//  2018-01-08: Inputs: Added mapping for ImGuiKey_Insert.
//  2018-01-05: Inputs: Added WM_LBUTTONDBLCLK double-click handlers for window classes with the CS_DBLCLKS flag.
//  2017-10-23: Inputs: Added WM_SYSKEYDOWN / WM_SYSKEYUP handlers so e.g. the VK_MENU key can be read.
//  2017-10-23: Inputs: Using Win32 ::SetCapture/::GetCapture() to retrieve mouse positions outside the client area when dragging.
//  2016-11-12: Inputs: Only call Win32 ::SetCursor(NULL) when io.MouseDrawCursor is set.

// Win32 Data
static HWND                 g_hWnd = NULL;
static INT64                g_Time = 0;
static INT64                g_TicksPerSecond = 0;
static ImGuiMouseCursor     g_LastMouseCursor = ImGuiMouseCursor_COUNT;
static bool                 g_HasGamepad = false;
static bool                 g_WantUpdateHasGamepad = true;

// Functions
bool    ImGui_ImplWin32_Init(void* hwnd)
{
    if (!::QueryPerformanceFrequency((LARGE_INTEGER*)&g_TicksPerSecond))
        return false;
    if (!::QueryPerformanceCounter((LARGE_INTEGER*)&g_Time))
        return false;

    // Setup back-end capabilities flags
    g_hWnd = (HWND)hwnd;
    ImGuiIO& io = ImGui::GetIO();
    io.BackendFlags |= ImGuiBackendFlags_HasMouseCursors;         // We can honor GetMouseCursor() values (optional)
    io.BackendFlags |= ImGuiBackendFlags_HasSetMousePos;          // We can honor io.WantSetMousePos requests (optional, rarely used)
    io.BackendPlatformName = "imgui_impl_win32";
    io.ImeWindowHandle = hwnd;

    // Keyboard mapping. ImGui will use those indices to peek into the io.KeysDown[] array that we will update during the application lifetime.
    io.KeyMap[ImGuiKey_Tab] = VK_TAB;
    io.KeyMap[ImGuiKey_LeftArrow] = VK_LEFT;
    io.KeyMap[ImGuiKey_RightArrow] = VK_RIGHT;
    io.KeyMap[ImGuiKey_UpArrow] = VK_UP;
    io.KeyMap[ImGuiKey_DownArrow] = VK_DOWN;
    io.KeyMap[ImGuiKey_PageUp] = VK_PRIOR;
    io.KeyMap[ImGuiKey_PageDown] = VK_NEXT;
    io.KeyMap[ImGuiKey_Home] = VK_HOME;
    io.KeyMap[ImGuiKey_End] = VK_END;
    io.KeyMap[ImGuiKey_Insert] = VK_INSERT;
    io.KeyMap[ImGuiKey_Delete] = VK_DELETE;
    io.KeyMap[ImGuiKey_Backspace] = VK_BACK;
    io.KeyMap[ImGuiKey_Space] = VK_SPACE;
    io.KeyMap[ImGuiKey_Enter] = VK_RETURN;
    io.KeyMap[ImGuiKey_Escape] = VK_ESCAPE;
    io.KeyMap[ImGuiKey_KeyPadEnter] = VK_RETURN;
    io.KeyMap[ImGuiKey_A] = 'A';
    io.KeyMap[ImGuiKey_C] = 'C';
    io.KeyMap[ImGuiKey_V] = 'V';
    io.KeyMap[ImGuiKey_X] = 'X';
    io.KeyMap[ImGuiKey_Y] = 'Y';
    io.KeyMap[ImGuiKey_Z] = 'Z';

    return true;
}

void    ImGui_ImplWin32_Shutdown()
{
    g_hWnd = (HWND)0;
}

static bool ImGui_ImplWin32_UpdateMouseCursor()
{
    ImGuiIO& io = ImGui::GetIO();
    if (io.ConfigFlags & ImGuiConfigFlags_NoMouseCursorChange)
        return false;

    ImGuiMouseCursor imgui_cursor = ImGui::GetMouseCursor();
    if (imgui_cursor == ImGuiMouseCursor_None || io.MouseDrawCursor)
    {
        // Hide OS mouse cursor if imgui is drawing it or if it wants no cursor
        ::SetCursor(NULL);
    } else
    {
        // Show OS mouse cursor
        LPTSTR win32_cursor = IDC_ARROW;
        switch (imgui_cursor)
        {
        case ImGuiMouseCursor_Arrow:        win32_cursor = IDC_ARROW; break;
        case ImGuiMouseCursor_TextInput:    win32_cursor = IDC_IBEAM; break;
        case ImGuiMouseCursor_ResizeAll:    win32_cursor = IDC_SIZEALL; break;
        case ImGuiMouseCursor_ResizeEW:     win32_cursor = IDC_SIZEWE; break;
        case ImGuiMouseCursor_ResizeNS:     win32_cursor = IDC_SIZENS; break;
        case ImGuiMouseCursor_ResizeNESW:   win32_cursor = IDC_SIZENESW; break;
        case ImGuiMouseCursor_ResizeNWSE:   win32_cursor = IDC_SIZENWSE; break;
        case ImGuiMouseCursor_Hand:         win32_cursor = IDC_HAND; break;
        case ImGuiMouseCursor_NotAllowed:   win32_cursor = IDC_NO; break;
        }
        ::SetCursor(::LoadCursor(NULL, win32_cursor));
    }
    return true;
}

static void ImGui_ImplWin32_UpdateMousePos()
{
    ImGuiIO& io = ImGui::GetIO();

    // Set OS mouse position if requested (rarely used, only when ImGuiConfigFlags_NavEnableSetMousePos is enabled by user)
    if (io.WantSetMousePos)
    {
        POINT pos = { (int)io.MousePos.x, (int)io.MousePos.y };
        ::ClientToScreen(g_hWnd, &pos);
        ::SetCursorPos(pos.x, pos.y);
    }

    // Set mouse position
    io.MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
    POINT pos;
    if (HWND active_window = ::GetForegroundWindow())
        if (active_window == g_hWnd || ::IsChild(active_window, g_hWnd))
            if (::GetCursorPos(&pos) && ::ScreenToClient(g_hWnd, &pos))
                io.MousePos = ImVec2((float)pos.x, (float)pos.y);
}

// Gamepad navigation mapping
static void ImGui_ImplWin32_UpdateGamepads()
{
#ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD
    ImGuiIO& io = ImGui::GetIO();
    memset(io.NavInputs, 0, sizeof(io.NavInputs));
    if ((io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) == 0)
        return;

    // Calling XInputGetState() every frame on disconnected gamepads is unfortunately too slow.
    // Instead we refresh gamepad availability by calling XInputGetCapabilities() _only_ after receiving WM_DEVICECHANGE.
    if (g_WantUpdateHasGamepad)
    {
        XINPUT_CAPABILITIES caps;
        g_HasGamepad = (XInputGetCapabilities(0, XINPUT_FLAG_GAMEPAD, &caps) == ERROR_SUCCESS);
        g_WantUpdateHasGamepad = false;
    }

    XINPUT_STATE xinput_state;
    io.BackendFlags &= ~ImGuiBackendFlags_HasGamepad;
    if (g_HasGamepad && XInputGetState(0, &xinput_state) == ERROR_SUCCESS)
    {
        const XINPUT_GAMEPAD& gamepad = xinput_state.Gamepad;
        io.BackendFlags |= ImGuiBackendFlags_HasGamepad;

#define MAP_BUTTON(NAV_NO, BUTTON_ENUM)     { io.NavInputs[NAV_NO] = (gamepad.wButtons & BUTTON_ENUM) ? 1.0f : 0.0f; }
#define MAP_ANALOG(NAV_NO, VALUE, V0, V1)   { float vn = (float)(VALUE - V0) / (float)(V1 - V0); if (vn > 1.0f) vn = 1.0f; if (vn > 0.0f && io.NavInputs[NAV_NO] < vn) io.NavInputs[NAV_NO] = vn; }
        MAP_BUTTON(ImGuiNavInput_Activate, XINPUT_GAMEPAD_A);              // Cross / A
        MAP_BUTTON(ImGuiNavInput_Cancel, XINPUT_GAMEPAD_B);              // Circle / B
        MAP_BUTTON(ImGuiNavInput_Menu, XINPUT_GAMEPAD_X);              // Square / X
        MAP_BUTTON(ImGuiNavInput_Input, XINPUT_GAMEPAD_Y);              // Triangle / Y
        MAP_BUTTON(ImGuiNavInput_DpadLeft, XINPUT_GAMEPAD_DPAD_LEFT);      // D-Pad Left
        MAP_BUTTON(ImGuiNavInput_DpadRight, XINPUT_GAMEPAD_DPAD_RIGHT);     // D-Pad Right
        MAP_BUTTON(ImGuiNavInput_DpadUp, XINPUT_GAMEPAD_DPAD_UP);        // D-Pad Up
        MAP_BUTTON(ImGuiNavInput_DpadDown, XINPUT_GAMEPAD_DPAD_DOWN);      // D-Pad Down
        MAP_BUTTON(ImGuiNavInput_FocusPrev, XINPUT_GAMEPAD_LEFT_SHOULDER);  // L1 / LB
        MAP_BUTTON(ImGuiNavInput_FocusNext, XINPUT_GAMEPAD_RIGHT_SHOULDER); // R1 / RB
        MAP_BUTTON(ImGuiNavInput_TweakSlow, XINPUT_GAMEPAD_LEFT_SHOULDER);  // L1 / LB
        MAP_BUTTON(ImGuiNavInput_TweakFast, XINPUT_GAMEPAD_RIGHT_SHOULDER); // R1 / RB
        MAP_ANALOG(ImGuiNavInput_LStickLeft, gamepad.sThumbLX, -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, -32768);
        MAP_ANALOG(ImGuiNavInput_LStickRight, gamepad.sThumbLX, +XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, +32767);
        MAP_ANALOG(ImGuiNavInput_LStickUp, gamepad.sThumbLY, +XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, +32767);
        MAP_ANALOG(ImGuiNavInput_LStickDown, gamepad.sThumbLY, -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, -32767);
#undef MAP_BUTTON
#undef MAP_ANALOG
    }
#endif // #ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD
}

void    ImGui_ImplWin32_NewFrame()
{
    ImGuiIO& io = ImGui::GetIO();
    IM_ASSERT(io.Fonts->IsBuilt() && "Font atlas not built! It is generally built by the renderer back-end. Missing call to renderer _NewFrame() function? e.g. ImGui_ImplOpenGL3_NewFrame().");

    // Setup display size (every frame to accommodate for window resizing)
    RECT rect;
    ::GetClientRect(g_hWnd, &rect);
    io.DisplaySize = ImVec2((float)(rect.right - rect.left), (float)(rect.bottom - rect.top));

    // Setup time step
    INT64 current_time;
    ::QueryPerformanceCounter((LARGE_INTEGER*)&current_time);
    io.DeltaTime = (float)(current_time - g_Time) / g_TicksPerSecond;
    g_Time = current_time;

    // Read keyboard modifiers inputs
    io.KeyCtrl = (::GetKeyState(VK_CONTROL) & 0x8000) != 0;
    io.KeyShift = (::GetKeyState(VK_SHIFT) & 0x8000) != 0;
    io.KeyAlt = (::GetKeyState(VK_MENU) & 0x8000) != 0;
    io.KeySuper = false;
    // io.KeysDown[], io.MousePos, io.MouseDown[], io.MouseWheel: filled by the WndProc handler below.

    // Update OS mouse position
    ImGui_ImplWin32_UpdateMousePos();

    // Update OS mouse cursor with the cursor requested by imgui
    ImGuiMouseCursor mouse_cursor = io.MouseDrawCursor ? ImGuiMouseCursor_None : ImGui::GetMouseCursor();
    if (g_LastMouseCursor != mouse_cursor)
    {
        g_LastMouseCursor = mouse_cursor;
        ImGui_ImplWin32_UpdateMouseCursor();
    }

    // Update game controllers (if enabled and available)
    ImGui_ImplWin32_UpdateGamepads();
}

// Allow compilation with old Windows SDK. MinGW doesn't have default _WIN32_WINNT/WINVER versions.
#ifndef WM_MOUSEHWHEEL
#define WM_MOUSEHWHEEL 0x020E
#endif
#ifndef DBT_DEVNODES_CHANGED
#define DBT_DEVNODES_CHANGED 0x0007
#endif

// Win32 message handler (process Win32 mouse/keyboard inputs, etc.)
// Call from your application's message handler.
// When implementing your own back-end, you can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to tell if Dear ImGui wants to use your inputs.
// - When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application.
// - When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application.
// Generally you may always pass all inputs to Dear ImGui, and hide them from your application based on those two flags.
// PS: In this Win32 handler, we use the capture API (GetCapture/SetCapture/ReleaseCapture) to be able to read mouse coordinates when dragging mouse outside of our window bounds.
// PS: We treat DBLCLK messages as regular mouse down messages, so this code will work on windows classes that have the CS_DBLCLKS flag set. Our own example app code doesn't set this flag.
#if 0
// Copy this line into your .cpp file to forward declare the function.
extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
#endif
IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (ImGui::GetCurrentContext() == NULL)
        return 0;

    ImGuiIO& io = ImGui::GetIO();
    switch (msg)
    {
    case WM_LBUTTONDOWN: case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDOWN: case WM_RBUTTONDBLCLK:
    case WM_MBUTTONDOWN: case WM_MBUTTONDBLCLK:
    case WM_XBUTTONDOWN: case WM_XBUTTONDBLCLK:
    {
        int button = 0;
        if (msg == WM_LBUTTONDOWN || msg == WM_LBUTTONDBLCLK) { button = 0; }
        if (msg == WM_RBUTTONDOWN || msg == WM_RBUTTONDBLCLK) { button = 1; }
        if (msg == WM_MBUTTONDOWN || msg == WM_MBUTTONDBLCLK) { button = 2; }
        if (msg == WM_XBUTTONDOWN || msg == WM_XBUTTONDBLCLK) { button = (GET_XBUTTON_WPARAM(wParam) == XBUTTON1) ? 3 : 4; }
        if (!ImGui::IsAnyMouseDown() && ::GetCapture() == NULL)
            ::SetCapture(hwnd);
        io.MouseDown[button] = true;
        return 0;
    }
    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
    case WM_XBUTTONUP:
    {
        int button = 0;
        if (msg == WM_LBUTTONUP) { button = 0; }
        if (msg == WM_RBUTTONUP) { button = 1; }
        if (msg == WM_MBUTTONUP) { button = 2; }
        if (msg == WM_XBUTTONUP) { button = (GET_XBUTTON_WPARAM(wParam) == XBUTTON1) ? 3 : 4; }
        io.MouseDown[button] = false;
        if (!ImGui::IsAnyMouseDown() && ::GetCapture() == hwnd)
            ::ReleaseCapture();
        return 0;
    }
    case WM_MOUSEWHEEL:
        io.MouseWheel += (float)GET_WHEEL_DELTA_WPARAM(wParam) / (float)WHEEL_DELTA;
        return 0;
    case WM_MOUSEHWHEEL:
        io.MouseWheelH += (float)GET_WHEEL_DELTA_WPARAM(wParam) / (float)WHEEL_DELTA;
        return 0;
    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
        if (wParam < 256)
            io.KeysDown[wParam] = 1;
        return 0;
    case WM_KEYUP:
    case WM_SYSKEYUP:
        if (wParam < 256)
            io.KeysDown[wParam] = 0;
        return 0;
    case WM_CHAR:
        // You can also use ToAscii()+GetKeyboardState() to retrieve characters.
        if (wParam > 0 && wParam < 0x10000)
            io.AddInputCharacterUTF16((unsigned short)wParam);
        return 0;
    case WM_SETCURSOR:
        if (LOWORD(lParam) == HTCLIENT && ImGui_ImplWin32_UpdateMouseCursor())
            return 1;
        return 0;
    case WM_DEVICECHANGE:
        if ((UINT)wParam == DBT_DEVNODES_CHANGED)
            g_WantUpdateHasGamepad = true;
        return 0;
    case WM_ACTIVATEAPP:
        if (hwnd == g_hWnd && wParam == FALSE) {
            memset(io.MouseDown, 0, sizeof(io.MouseDown));
            memset(io.KeysDown, 0, sizeof(io.KeysDown));
        }
        return 0;
    }
    return 0;
}


//--------------------------------------------------------------------------------------------------------
// DPI-related helpers (optional)
//--------------------------------------------------------------------------------------------------------
// - Use to enable DPI awareness without having to create an application manifest.
// - Your own app may already do this via a manifest or explicit calls. This is mostly useful for our examples/ apps.
// - In theory we could call simple functions from Windows SDK such as SetProcessDPIAware(), SetProcessDpiAwareness(), etc.
//   but most of the functions provided by Microsoft require Windows 8.1/10+ SDK at compile time and Windows 8/10+ at runtime,
//   neither we want to require the user to have. So we dynamically select and load those functions to avoid dependencies.
//---------------------------------------------------------------------------------------------------------
// This is the scheme successfully used by GLFW (from which we borrowed some of the code) and other apps aiming to be highly portable.
// ImGui_ImplWin32_EnableDpiAwareness() is just a helper called by main.cpp, we don't call it automatically.
// If you are trying to implement your own back-end for your own engine, you may ignore that noise.
//---------------------------------------------------------------------------------------------------------

// Implement some of the functions and types normally declared in recent Windows SDK.
#if !defined(_versionhelpers_H_INCLUDED_) && !defined(_INC_VERSIONHELPERS)
static BOOL IsWindowsVersionOrGreater(WORD major, WORD minor, WORD sp)
{
    OSVERSIONINFOEXW osvi = { sizeof(osvi), major, minor, 0, 0, { 0 }, sp };
    DWORD mask = VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR;
    ULONGLONG cond = ::VerSetConditionMask(0, VER_MAJORVERSION, VER_GREATER_EQUAL);
    cond = ::VerSetConditionMask(cond, VER_MINORVERSION, VER_GREATER_EQUAL);
    cond = ::VerSetConditionMask(cond, VER_SERVICEPACKMAJOR, VER_GREATER_EQUAL);
    return ::VerifyVersionInfoW(&osvi, mask, cond);
}
#define IsWindows8Point1OrGreater()  IsWindowsVersionOrGreater(HIBYTE(0x0602), LOBYTE(0x0602), 0) // _WIN32_WINNT_WINBLUE
#endif

#ifndef DPI_ENUMS_DECLARED
typedef enum { PROCESS_DPI_UNAWARE = 0, PROCESS_SYSTEM_DPI_AWARE = 1, PROCESS_PER_MONITOR_DPI_AWARE = 2 } PROCESS_DPI_AWARENESS;
typedef enum { MDT_EFFECTIVE_DPI = 0, MDT_ANGULAR_DPI = 1, MDT_RAW_DPI = 2, MDT_DEFAULT = MDT_EFFECTIVE_DPI } MONITOR_DPI_TYPE;
#endif
#ifndef _DPI_AWARENESS_CONTEXTS_
DECLARE_HANDLE(DPI_AWARENESS_CONTEXT);
#define DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE    (DPI_AWARENESS_CONTEXT)-3
#endif
#ifndef DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2
#define DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2 (DPI_AWARENESS_CONTEXT)-4
#endif
typedef HRESULT(WINAPI* PFN_SetProcessDpiAwareness)(PROCESS_DPI_AWARENESS);                     // Shcore.lib + dll, Windows 8.1+
typedef HRESULT(WINAPI* PFN_GetDpiForMonitor)(HMONITOR, MONITOR_DPI_TYPE, UINT*, UINT*);        // Shcore.lib + dll, Windows 8.1+
typedef DPI_AWARENESS_CONTEXT(WINAPI* PFN_SetThreadDpiAwarenessContext)(DPI_AWARENESS_CONTEXT); // User32.lib + dll, Windows 10 v1607+ (Creators Update)

// Helper function to enable DPI awareness without setting up a manifest
void ImGui_ImplWin32_EnableDpiAwareness()
{
    // if (IsWindows10OrGreater()) // This needs a manifest to succeed. Instead we try to grab the function pointer!
    {
        static HINSTANCE user32_dll = ::LoadLibraryA("user32.dll"); // Reference counted per-process
        if (PFN_SetThreadDpiAwarenessContext SetThreadDpiAwarenessContextFn = (PFN_SetThreadDpiAwarenessContext)::GetProcAddress(user32_dll, "SetThreadDpiAwarenessContext"))
        {
            SetThreadDpiAwarenessContextFn(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2);
            return;
        }
    }
    if (IsWindows8Point1OrGreater())
    {
        static HINSTANCE shcore_dll = ::LoadLibraryA("shcore.dll"); // Reference counted per-process
        if (PFN_SetProcessDpiAwareness SetProcessDpiAwarenessFn = (PFN_SetProcessDpiAwareness)::GetProcAddress(shcore_dll, "SetProcessDpiAwareness"))
        {
            SetProcessDpiAwarenessFn(PROCESS_PER_MONITOR_DPI_AWARE);
            return;
        }
    }
    SetProcessDPIAware();
}

#if defined(_MSC_VER) && !defined(NOGDI)
#pragma comment(lib, "gdi32")   // Link with gdi32.lib for GetDeviceCaps()
#endif

float ImGui_ImplWin32_GetDpiScaleForMonitor(void* monitor)
{
    UINT xdpi = 96, ydpi = 96;
    if (IsWindows8Point1OrGreater())
    {
        static HINSTANCE shcore_dll = ::LoadLibraryA("shcore.dll"); // Reference counted per-process
        if (PFN_GetDpiForMonitor GetDpiForMonitorFn = (PFN_GetDpiForMonitor)::GetProcAddress(shcore_dll, "GetDpiForMonitor"))
            GetDpiForMonitorFn((HMONITOR)monitor, MDT_EFFECTIVE_DPI, &xdpi, &ydpi);
    }
#ifndef NOGDI
    else
    {
        const HDC dc = ::GetDC(NULL);
        xdpi = ::GetDeviceCaps(dc, LOGPIXELSX);
        ydpi = ::GetDeviceCaps(dc, LOGPIXELSY);
        ::ReleaseDC(NULL, dc);
    }
#endif
    IM_ASSERT(xdpi == ydpi); // Please contact me if you hit this assert!
    return xdpi / 96.0f;
}

float ImGui_ImplWin32_GetDpiScaleForHwnd(void* hwnd)
{
    HMONITOR monitor = ::MonitorFromWindow((HWND)hwnd, MONITOR_DEFAULTTONEAREST);
    return ImGui_ImplWin32_GetDpiScaleForMonitor(monitor);
}

//---------------------------------------------------------------------------------------------------------
